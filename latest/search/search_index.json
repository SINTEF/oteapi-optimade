{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OTE-API OPTIMADE","text":"<p>An OTE-API Plugin with OTE strategies.</p> <p>Further reading:</p> <ul> <li>OTE-API Core Documentation</li> <li>OTE-API Services Documentation</li> </ul>"},{"location":"#license-and-copyright","title":"License and copyright","text":"<p>OTE-API OPTIMADE is released under the MIT license with copyright \u00a9 SINTEF.</p>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>OTE-API OPTIMADE has been created via the cookiecutter template for OTE-API plugins.</p> <p>OTE-API OPTIMADE has been supported by the following projects:</p> <ul> <li> <p>OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136.</p> </li> <li> <p>VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903.</p> </li> <li> <p>OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.</p> </li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#unreleased-changes-2023-04-18","title":"Unreleased changes (2023-04-18)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li><code>Segmentation fault</code> from dlite in CI #115</li> </ul> <p>Merged pull requests:</p> <ul> <li>Avoid psycopg2-binary v2.9.6 #117 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v030-2023-03-30","title":"v0.3.0 (2023-03-30)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Use <code>SINTEF/ci-cd</code> CI - Tests workflow #71</li> <li>Implement support for DLite #31</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fix CI/CD workflows for external usage #84</li> <li>Update to <code>SINTEF/ci-cd</code> instead of <code>CasperWA/ci-cd</code> #72</li> </ul> <p>Closed issues:</p> <ul> <li>Use SINTEF/ci-cd v2 #104</li> <li>Reinstate pre-commit hooks for docs #68</li> </ul> <p>Merged pull requests:</p> <ul> <li>Support DLite #109 (CasperWA)</li> <li>Update to SINTEF/ci-cd v2 #105 (CasperWA)</li> <li>Update input keywords for SINTEF/ci-cd workflows #85 (CasperWA)</li> <li>Use CasperWA/ci-cd pre-commit hooks #69 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v022-2022-07-06","title":"v0.2.2 (2022-07-06)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Update to use all workflows from CasperWA/gh-actions #63 (CasperWA)</li> </ul> <p>Fixed bugs:</p> <ul> <li>New workflow is removing API reference in documentation #64</li> </ul> <p>Closed issues:</p> <ul> <li>Update to new repository name for callable workflows #66</li> </ul> <p>Merged pull requests:</p> <ul> <li>Use new repo name for callable workflows repo #67 (CasperWA)</li> <li>Properly create API reference and clean up #65 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v021-2022-07-01","title":"v0.2.1 (2022-07-01)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>Set <code>test: false</code> for publish workflow #61</li> </ul> <p>Merged pull requests:</p> <ul> <li>Don't run publish workflow as a test #62 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v021-alpha1-2022-07-01","title":"v0.2.1-alpha.1 (2022-07-01)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Auto-merge generated PR from new workflow #49</li> <li>Properly update dependencies #46</li> <li>Use CasperWA/gh-actions workflows #60 (CasperWA)</li> </ul> <p>Fixed bugs:</p> <ul> <li>New workflow failing #48</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #53 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #52 (TEAM4-0)</li> <li>Auto-merge new CD workflow-generated PR #50 (CasperWA)</li> <li>New CD workflow to update dependencies in pyproject.toml #47 (CasperWA)</li> <li>[Auto-generated] Update dependencies #44 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v020-2022-05-18","title":"v0.2.0 (2022-05-18)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Implement OPTIMADE filter strategy #4</li> </ul> <p>Fixed bugs:</p> <ul> <li>CI docker connection issues #34</li> </ul> <p>Closed issues:</p> <ul> <li>Use the <code>optimade</code> container image in CI #41</li> <li>Extend acknowledgements in README #38</li> </ul> <p>Merged pull requests:</p> <ul> <li>Use the optimade container image in CI #42 (CasperWA)</li> <li>[Auto-generated] Update dependencies #40 (TEAM4-0)</li> <li>Add VIPCOAT and OpenModel to README ack #39 (CasperWA)</li> <li>Fix real backend CI job #37 (CasperWA)</li> <li>[Auto-generated] Update dependencies #36 (TEAM4-0)</li> <li>Add a Filter strategy #33 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v010-2022-03-29","title":"v0.1.0 (2022-03-29)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Correctly handle trailing slashes (<code>/</code>) #28</li> </ul> <p>Merged pull requests:</p> <ul> <li>Trailing slash in base URL #29 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v002-2022-03-29","title":"v0.0.2 (2022-03-29)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Implement OPTIMADE parse strategy #5</li> <li>Implement OPTIMADE resource strategy #3</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fix CI connection refusal for pytest-real-backend job #26</li> <li>CD workflow failing - flit not building #23</li> <li>Black issue with click #21</li> <li>CD workflow failing #18</li> <li>GH GraphQL type issue in auto-merge workflow #6</li> <li>Fix CI #1</li> </ul> <p>Closed issues:</p> <ul> <li>CI test with end-to-end #17</li> </ul> <p>Merged pull requests:</p> <ul> <li>Fix pytest-real-backend CI job #27 (CasperWA)</li> <li>Test release workflow #25 (CasperWA)</li> <li>Build package prior to polluting git tree #24 (CasperWA)</li> <li>Update pre-commit hooks #22 (CasperWA)</li> <li>Fix failing release workflow #20 (CasperWA)</li> <li>Setup CI end-to-end test #19 (CasperWA)</li> <li>[Auto-generated] Update dependencies #15 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #13 (TEAM4-0)</li> <li>Implement an OPTIMADE Resource strategy #12 (CasperWA)</li> <li>[Auto-generated] Update dependencies #11 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #10 (TEAM4-0)</li> <li>Use <code>ID!</code> type instead of <code>String!</code> #7 (CasperWA)</li> <li>Fix CI and use flit #2 (CasperWA)</li> </ul> <p>* This Changelog was automatically generated by github_changelog_generator</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2022 SINTEF</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"all_strategies/","title":"OTE-API OPTIMADE Strategies","text":"<p>This page provides documentation for the <code>oteapi_optimade.strategies</code> submodule, where all the OTE-API OPTIMADE strategies are located.</p> <p>These strategies will be available when setting up a server in an environment with oteapi-optimade installed.</p>"},{"location":"all_strategies/#oteapi_optimade.strategies.filter","title":"<code>filter</code>","text":"<p>Demo filter strategy.</p>"},{"location":"all_strategies/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy","title":"<code> OPTIMADEFilterStrategy        </code>  <code>dataclass</code>","text":"<p>Filter Strategy.</p> <p>Implements strategies:</p> <ul> <li><code>(\"filterType\", \"OPTIMADE\")</code></li> <li><code>(\"filterType\", \"optimade\")</code></li> <li><code>(\"filterType\", \"OPTiMaDe\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>@dataclass\nclass OPTIMADEFilterStrategy:\n\"\"\"Filter Strategy.\n\n    **Implements strategies**:\n\n    - `(\"filterType\", \"OPTIMADE\")`\n    - `(\"filterType\", \"optimade\")`\n    - `(\"filterType\", \"OPTiMaDe\")`\n\n    \"\"\"\n\n    filter_config: OPTIMADEFilterConfig\n\n    def initialize(\n        self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n    ) -&gt; OPTIMADEFilterSession:\n\"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Configuration values, specifically URL query parameters, can be provided to the\n        OPTIMADE resource strategy through this filter strategy.\n\n        Workflow:\n\n        1. Compile received information.\n        2. Update session with compiled information.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEFilterSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEFilterSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEFilterSession()\n\n        if session.optimade_config:\n            self.filter_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        optimade_config = self.filter_config.configuration.copy()\n\n        if not optimade_config.query_parameters:\n            optimade_config.query_parameters = OPTIMADEQueryParameters()\n\n        if self.filter_config.query:\n            LOGGER.debug(\"Setting filter from query.\")\n            optimade_config.query_parameters.filter = self.filter_config.query\n\n        if self.filter_config.limit:\n            LOGGER.debug(\"Setting page_limit from limit.\")\n            optimade_config.query_parameters.page_limit = self.filter_config.limit\n\n        return session.copy(\n            update={\n                \"optimade_config\": optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            },\n        )\n\n    def get(  # pylint: disable=unused-argument\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; SessionUpdate:\n\"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n        return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>def get(  # pylint: disable=unused-argument\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; SessionUpdate:\n\"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy.</p> <p>Workflow:</p> <ol> <li>Compile received information.</li> <li>Update session with compiled information.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Union[SessionUpdate, Dict[str, Any]]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEFilterSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>def initialize(\n    self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n) -&gt; OPTIMADEFilterSession:\n\"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Configuration values, specifically URL query parameters, can be provided to the\n    OPTIMADE resource strategy through this filter strategy.\n\n    Workflow:\n\n    1. Compile received information.\n    2. Update session with compiled information.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEFilterSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEFilterSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEFilterSession()\n\n    if session.optimade_config:\n        self.filter_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    optimade_config = self.filter_config.configuration.copy()\n\n    if not optimade_config.query_parameters:\n        optimade_config.query_parameters = OPTIMADEQueryParameters()\n\n    if self.filter_config.query:\n        LOGGER.debug(\"Setting filter from query.\")\n        optimade_config.query_parameters.filter = self.filter_config.query\n\n    if self.filter_config.limit:\n        LOGGER.debug(\"Setting page_limit from limit.\")\n        optimade_config.query_parameters.page_limit = self.filter_config.limit\n\n    return session.copy(\n        update={\n            \"optimade_config\": optimade_config.copy(\n                update={\n                    \"query_parameters\": model2dict(\n                        optimade_config.query_parameters,\n                        exclude_defaults=True,\n                        exclude_unset=True,\n                    )\n                }\n            )\n        },\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.parse","title":"<code>parse</code>","text":"<p>Demo strategy class for text/json.</p>"},{"location":"all_strategies/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy","title":"<code> OPTIMADEParseStrategy        </code>  <code>dataclass</code>","text":"<p>Parse strategy for JSON.</p> <p>Implements strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.optimade+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.optimade+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.optimade\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>@dataclass\nclass OPTIMADEParseStrategy:\n\"\"\"Parse strategy for JSON.\n\n    **Implements strategies**:\n\n    - `(\"mediaType\", \"application/vnd.optimade+json\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE+json\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe+json\")`\n    - `(\"mediaType\", \"application/vnd.optimade+JSON\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")`\n    - `(\"mediaType\", \"application/vnd.optimade\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe\")`\n\n    \"\"\"\n\n    parse_config: OPTIMADEParseConfig\n\n    def initialize(  # pylint: disable=unused-argument\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        return SessionUpdate()\n\n    def get(  # pylint: disable=too-many-branches\n        self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n    ) -&gt; OPTIMADEParseSession:\n\"\"\"Request and parse an OPTIMADE response using OPT.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Configuration values provided in `resource_config.configuration` take\n        precedence over the derived values from `downloadUrl`.\n\n        Workflow:\n\n        1. Request OPTIMADE response.\n        2. Parse as an OPTIMADE Python tools (OPT) pydantic response model.\n\n        Parameters:\n            session: A session-specific dictionary-like context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEParseSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEParseSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEParseSession()\n\n        if session.optimade_config:\n            self.parse_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        if self.parse_config.downloadUrl in cache:\n            response: \"Dict[str, Any]\" = cache.get(self.parse_config.downloadUrl)\n        elif (\n            self.parse_config.configuration.datacache_config.accessKey\n            and self.parse_config.configuration.datacache_config.accessKey in cache\n        ):\n            response = cache.get(\n                self.parse_config.configuration.datacache_config.accessKey\n            )\n        else:\n            download_config = self.parse_config.copy()\n            session.update(\n                create_strategy(StrategyType.DOWNLOAD, download_config).initialize(\n                    model2dict(session, exclude_defaults=True, exclude_unset=True)\n                )\n            )\n            session.update(\n                create_strategy(StrategyType.DOWNLOAD, download_config).get(\n                    model2dict(session, exclude_defaults=True, exclude_unset=True)\n                )\n            )\n\n            response = {\"json\": json.loads(cache.get(session.pop(\"key\")))}\n\n        if (\n            not response.get(\"ok\", True)\n            or (\n                200 &gt; response.get(\"status_code\", 200)\n                or response.get(\"status_code\", 200) &gt;= 300\n            )\n            or \"errors\" in response.get(\"json\", {})\n        ):\n            # Error response\n            try:\n                response_object = ErrorResponse(**response.get(\"json\", {}))\n            except ValidationError as exc:\n                LOGGER.error(\n                    \"Could not validate an error response.\\nValidationError: \"\n                    \"%s\\nresponse=%r\",\n                    exc,\n                    response,\n                )\n                raise OPTIMADEParseError(\n                    \"Could not validate an error response.\"\n                ) from exc\n        else:\n            # Successful response\n            response_model = self.parse_config.downloadUrl.response_model()\n            if response_model:\n                if not isinstance(response_model, tuple):\n                    response_model = (response_model,)\n                for model_cls in response_model:\n                    try:\n                        response_object = model_cls(**response.get(\"json\", {}))\n                    except ValidationError:\n                        pass\n                    else:\n                        break\n                else:\n                    LOGGER.error(\n                        \"Could not validate for an expected response model.\\nURL=%r\\n\"\n                        \"response_models=%r\\nresponse=%s\",\n                        self.parse_config.downloadUrl,\n                        response_model,\n                        response,\n                    )\n                    raise OPTIMADEParseError(\n                        \"Could not validate for an expected response model.\"\n                    )\n            else:\n                # No \"endpoint\" or unknown\n                try:\n                    response_object = Success(**response.get(\"json\", {}))\n                except ValidationError as exc:\n                    LOGGER.error(\n                        \"Unknown or unparseable endpoint.\\nValidatonError: %s\\n\"\n                        \"URL=%r\\nendpoint=%r\\nresponse_model=%r\\nresponse=%s\",\n                        exc,\n                        self.parse_config.downloadUrl,\n                        self.parse_config.downloadUrl.endpoint,\n                        response_model,\n                        response,\n                    )\n                    raise OPTIMADEParseError(\n                        \"Unknown or unparseable endpoint.\"\n                    ) from exc\n\n        if self.parse_config.configuration.return_object:\n            session.optimade_response_object = response_object\n        else:\n            session.optimade_response = model2dict(response_object)\n\n        if session.optimade_config and session.optimade_config.query_parameters:\n            session = session.copy(\n                update={\n                    \"optimade_config\": session.optimade_config.copy(\n                        update={\n                            \"query_parameters\": model2dict(\n                                session.optimade_config.query_parameters,\n                                exclude_defaults=True,\n                                exclude_unset=True,\n                            )\n                        }\n                    )\n                }\n            )\n\n        return session\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Request and parse an OPTIMADE response using OPT.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Configuration values provided in <code>resource_config.configuration</code> take precedence over the derived values from <code>downloadUrl</code>.</p> <p>Workflow:</p> <ol> <li>Request OPTIMADE response.</li> <li>Parse as an OPTIMADE Python tools (OPT) pydantic response model.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Union[SessionUpdate, Dict[str, Any]]]</code> <p>A session-specific dictionary-like context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEParseSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>def get(  # pylint: disable=too-many-branches\n    self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n) -&gt; OPTIMADEParseSession:\n\"\"\"Request and parse an OPTIMADE response using OPT.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Configuration values provided in `resource_config.configuration` take\n    precedence over the derived values from `downloadUrl`.\n\n    Workflow:\n\n    1. Request OPTIMADE response.\n    2. Parse as an OPTIMADE Python tools (OPT) pydantic response model.\n\n    Parameters:\n        session: A session-specific dictionary-like context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEParseSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEParseSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEParseSession()\n\n    if session.optimade_config:\n        self.parse_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    if self.parse_config.downloadUrl in cache:\n        response: \"Dict[str, Any]\" = cache.get(self.parse_config.downloadUrl)\n    elif (\n        self.parse_config.configuration.datacache_config.accessKey\n        and self.parse_config.configuration.datacache_config.accessKey in cache\n    ):\n        response = cache.get(\n            self.parse_config.configuration.datacache_config.accessKey\n        )\n    else:\n        download_config = self.parse_config.copy()\n        session.update(\n            create_strategy(StrategyType.DOWNLOAD, download_config).initialize(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n        session.update(\n            create_strategy(StrategyType.DOWNLOAD, download_config).get(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n\n        response = {\"json\": json.loads(cache.get(session.pop(\"key\")))}\n\n    if (\n        not response.get(\"ok\", True)\n        or (\n            200 &gt; response.get(\"status_code\", 200)\n            or response.get(\"status_code\", 200) &gt;= 300\n        )\n        or \"errors\" in response.get(\"json\", {})\n    ):\n        # Error response\n        try:\n            response_object = ErrorResponse(**response.get(\"json\", {}))\n        except ValidationError as exc:\n            LOGGER.error(\n                \"Could not validate an error response.\\nValidationError: \"\n                \"%s\\nresponse=%r\",\n                exc,\n                response,\n            )\n            raise OPTIMADEParseError(\n                \"Could not validate an error response.\"\n            ) from exc\n    else:\n        # Successful response\n        response_model = self.parse_config.downloadUrl.response_model()\n        if response_model:\n            if not isinstance(response_model, tuple):\n                response_model = (response_model,)\n            for model_cls in response_model:\n                try:\n                    response_object = model_cls(**response.get(\"json\", {}))\n                except ValidationError:\n                    pass\n                else:\n                    break\n            else:\n                LOGGER.error(\n                    \"Could not validate for an expected response model.\\nURL=%r\\n\"\n                    \"response_models=%r\\nresponse=%s\",\n                    self.parse_config.downloadUrl,\n                    response_model,\n                    response,\n                )\n                raise OPTIMADEParseError(\n                    \"Could not validate for an expected response model.\"\n                )\n        else:\n            # No \"endpoint\" or unknown\n            try:\n                response_object = Success(**response.get(\"json\", {}))\n            except ValidationError as exc:\n                LOGGER.error(\n                    \"Unknown or unparseable endpoint.\\nValidatonError: %s\\n\"\n                    \"URL=%r\\nendpoint=%r\\nresponse_model=%r\\nresponse=%s\",\n                    exc,\n                    self.parse_config.downloadUrl,\n                    self.parse_config.downloadUrl.endpoint,\n                    response_model,\n                    response,\n                )\n                raise OPTIMADEParseError(\n                    \"Unknown or unparseable endpoint.\"\n                ) from exc\n\n    if self.parse_config.configuration.return_object:\n        session.optimade_response_object = response_object\n    else:\n        session.optimade_response = model2dict(response_object)\n\n    if session.optimade_config and session.optimade_config.query_parameters:\n        session = session.copy(\n            update={\n                \"optimade_config\": session.optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            session.optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            }\n        )\n\n    return session\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>def initialize(  # pylint: disable=unused-argument\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.resource","title":"<code>resource</code>","text":"<p>OPTIMADE resource strategy.</p>"},{"location":"all_strategies/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy","title":"<code> OPTIMADEResourceStrategy        </code>  <code>dataclass</code>","text":"<p>OPTIMADE Resource Strategy.</p> <p>Implements strategies:</p> <ul> <li><code>(\"accessService\", \"optimade\")</code></li> <li><code>(\"accessService\", \"OPTIMADE\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe\")</code></li> <li><code>(\"accessService\", \"optimade+dlite\")</code></li> <li><code>(\"accessService\", \"OPTIMADE+dlite\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe+dlite\")</code></li> <li><code>(\"accessService\", \"optimade+DLite\")</code></li> <li><code>(\"accessService\", \"OPTIMADE+DLite\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe+DLite\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>@dataclass\nclass OPTIMADEResourceStrategy:\n\"\"\"OPTIMADE Resource Strategy.\n\n    **Implements strategies**:\n\n    - `(\"accessService\", \"optimade\")`\n    - `(\"accessService\", \"OPTIMADE\")`\n    - `(\"accessService\", \"OPTiMaDe\")`\n    - `(\"accessService\", \"optimade+dlite\")`\n    - `(\"accessService\", \"OPTIMADE+dlite\")`\n    - `(\"accessService\", \"OPTiMaDe+dlite\")`\n    - `(\"accessService\", \"optimade+DLite\")`\n    - `(\"accessService\", \"OPTIMADE+DLite\")`\n    - `(\"accessService\", \"OPTiMaDe+DLite\")`\n\n    \"\"\"\n\n    resource_config: OPTIMADEResourceConfig\n\n    def initialize(  # pylint: disable=unused-argument\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; \"Union[SessionUpdate, DLiteSessionUpdate]\":\n\"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if use_dlite(\n            self.resource_config.accessService,\n            self.resource_config.configuration.use_dlite,\n        ):\n            return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n        return SessionUpdate()\n\n    def get(  # pylint: disable=too-many-branches,too-many-statements\n        self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n    ) -&gt; OPTIMADEResourceSession:\n\"\"\"Execute an OPTIMADE query to `accessUrl`.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Configuration values provided in `resource_config.configuration` take\n        precedence over the derived values from `accessUrl`.\n\n        Workflow:\n        1. Update configuration according to session.\n        2. Deconstruct `accessUrl` (done partly by\n           `oteapi_optimade.models.custom_types.OPTIMADEUrl`).\n        3. Reconstruct the complete query URL.\n        4. Send query.\n        5. Store result in data cache.\n\n        Parameters:\n            session: A session-specific dictionary-like context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEResourceSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEResourceSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEResourceSession()\n\n        if session.optimade_config:\n            self.resource_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        optimade_endpoint = self.resource_config.accessUrl.endpoint or \"structures\"\n        optimade_query = (\n            self.resource_config.configuration.query_parameters\n            or OPTIMADEQueryParameters()\n        )\n        LOGGER.debug(\"resource_config: %r\", self.resource_config)\n\n        if self.resource_config.accessUrl.query:\n            parsed_query = parse_qs(self.resource_config.accessUrl.query)\n            for field, value in parsed_query.items():\n                # Only use the latest defined value for any parameter\n                if field not in optimade_query.__fields_set__:\n                    LOGGER.debug(\n                        \"Setting %r from accessUrl (value=%r)\", field, value[-1]\n                    )\n                    setattr(optimade_query, field, value[-1])\n\n        LOGGER.debug(\"optimade_query after update: %r\", optimade_query)\n\n        optimade_url = OPTIMADEUrl(\n            f\"{self.resource_config.accessUrl.base_url}\"\n            f\"/{self.resource_config.accessUrl.version or 'v1'}\"\n            f\"/{optimade_endpoint}?{optimade_query.generate_query_string()}\"\n        )\n        LOGGER.debug(\"OPTIMADE URL to be requested: %s\", optimade_url)\n\n        # Set cache access key to the full OPTIMADE URL.\n        self.resource_config.configuration.datacache_config.accessKey = optimade_url\n\n        # Perform query\n        response = requests.get(\n            optimade_url,\n            allow_redirects=True,\n            timeout=(3, 27),  # timeout in seconds (connect, read)\n        )\n\n        if optimade_query.response_format and optimade_query.response_format != \"json\":\n            raise NotImplementedError(\n                \"Can only handle JSON responses for now. Requested response format: \"\n                f\"{optimade_query.response_format!r}\"\n            )\n\n        cache = DataCache(config=self.resource_config.configuration.datacache_config)\n        cache.add(\n            {\n                \"status_code\": response.status_code,\n                \"ok\": response.ok,\n                \"json\": response.json(),\n            }\n        )\n\n        parse_with_dlite = use_dlite(\n            self.resource_config.accessService,\n            self.resource_config.configuration.use_dlite,\n        )\n\n        parse_mediaType = f\"application/vnd.{self.resource_config.accessService.split('+', maxsplit=1)[0]}\"  # pylint: disable=invalid-name,line-too-long\n        if parse_with_dlite:\n            parse_mediaType += \"+DLite\"  # pylint: disable=invalid-name\n        elif optimade_query.response_format:\n            parse_mediaType += (  # pylint: disable=invalid-name\n                f\"+{optimade_query.response_format}\"\n            )\n\n        parse_config = {\n            \"downloadUrl\": optimade_url,\n            \"mediaType\": parse_mediaType,\n            \"configuration\": {\n                \"datacache_config\": self.resource_config.configuration.datacache_config,\n                \"return_object\": True,\n            },\n        }\n\n        session.update(\n            create_strategy(StrategyType.PARSE, parse_config).initialize(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n        session.update(\n            create_strategy(StrategyType.PARSE, parse_config).get(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n\n        if \"optimade_response_object\" not in session:\n            raise ValueError(\n                \"'optimade_response_object' was expected to be present in the session.\"\n            )\n        optimade_response: \"OPTIMADEResponse\" = session.pop(\"optimade_response_object\")\n        if \"optimade_response\" in session and not session.get(\"optimade_response\"):\n            del session[\"optimade_response\"]\n\n        if isinstance(optimade_response, ErrorResponse):\n            optimade_resources = optimade_response.errors\n            session.optimade_resource_model = (\n                f\"{OptimadeError.__module__}:OptimadeError\"\n            )\n        elif isinstance(optimade_response, ReferenceResponseMany):\n            optimade_resources = [\n                Reference(entry).as_dict\n                if isinstance(entry, dict)\n                else Reference(entry.dict()).as_dict\n                for entry in optimade_response.data\n            ]\n            session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n        elif isinstance(optimade_response, ReferenceResponseOne):\n            optimade_resources = [\n                Reference(optimade_response.data).as_dict\n                if isinstance(optimade_response.data, dict)\n                else Reference(optimade_response.data.dict()).as_dict\n            ]\n            session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n        elif isinstance(optimade_response, StructureResponseMany):\n            optimade_resources = [\n                Structure(entry).as_dict\n                if isinstance(entry, dict)\n                else Structure(entry.dict()).as_dict\n                for entry in optimade_response.data\n            ]\n            session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n        elif isinstance(optimade_response, StructureResponseOne):\n            optimade_resources = [\n                Structure(optimade_response.data).as_dict\n                if isinstance(optimade_response.data, dict)\n                else Structure(optimade_response.data.dict()).as_dict\n            ]\n            session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n        else:\n            LOGGER.debug(\n                \"Could not parse response as errors, references or structures. \"\n                \"Response:\\n%r\",\n                optimade_response,\n            )\n            raise OPTIMADEParseError(\n                \"Could not retrieve errors, references or structures from response \"\n                f\"from {optimade_url}. It could be a valid OPTIMADE API response, \"\n                \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \"\n                \"invalid response completely.\"\n            )\n\n        session.optimade_resources = [\n            model2dict(resource) for resource in optimade_resources\n        ]\n\n        if session.optimade_config and session.optimade_config.query_parameters:\n            session = session.copy(\n                update={\n                    \"optimade_config\": session.optimade_config.copy(\n                        update={\n                            \"query_parameters\": model2dict(\n                                session.optimade_config.query_parameters,\n                                exclude_defaults=True,\n                                exclude_unset=True,\n                            )\n                        }\n                    )\n                }\n            )\n\n        return session\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Execute an OPTIMADE query to <code>accessUrl</code>.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Configuration values provided in <code>resource_config.configuration</code> take precedence over the derived values from <code>accessUrl</code>.</p> <p>Workflow: 1. Update configuration according to session. 2. Deconstruct <code>accessUrl</code> (done partly by    <code>oteapi_optimade.models.custom_types.OPTIMADEUrl</code>). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Union[SessionUpdate, Dict[str, Any]]]</code> <p>A session-specific dictionary-like context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEResourceSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def get(  # pylint: disable=too-many-branches,too-many-statements\n    self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n) -&gt; OPTIMADEResourceSession:\n\"\"\"Execute an OPTIMADE query to `accessUrl`.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Configuration values provided in `resource_config.configuration` take\n    precedence over the derived values from `accessUrl`.\n\n    Workflow:\n    1. Update configuration according to session.\n    2. Deconstruct `accessUrl` (done partly by\n       `oteapi_optimade.models.custom_types.OPTIMADEUrl`).\n    3. Reconstruct the complete query URL.\n    4. Send query.\n    5. Store result in data cache.\n\n    Parameters:\n        session: A session-specific dictionary-like context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEResourceSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEResourceSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEResourceSession()\n\n    if session.optimade_config:\n        self.resource_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    optimade_endpoint = self.resource_config.accessUrl.endpoint or \"structures\"\n    optimade_query = (\n        self.resource_config.configuration.query_parameters\n        or OPTIMADEQueryParameters()\n    )\n    LOGGER.debug(\"resource_config: %r\", self.resource_config)\n\n    if self.resource_config.accessUrl.query:\n        parsed_query = parse_qs(self.resource_config.accessUrl.query)\n        for field, value in parsed_query.items():\n            # Only use the latest defined value for any parameter\n            if field not in optimade_query.__fields_set__:\n                LOGGER.debug(\n                    \"Setting %r from accessUrl (value=%r)\", field, value[-1]\n                )\n                setattr(optimade_query, field, value[-1])\n\n    LOGGER.debug(\"optimade_query after update: %r\", optimade_query)\n\n    optimade_url = OPTIMADEUrl(\n        f\"{self.resource_config.accessUrl.base_url}\"\n        f\"/{self.resource_config.accessUrl.version or 'v1'}\"\n        f\"/{optimade_endpoint}?{optimade_query.generate_query_string()}\"\n    )\n    LOGGER.debug(\"OPTIMADE URL to be requested: %s\", optimade_url)\n\n    # Set cache access key to the full OPTIMADE URL.\n    self.resource_config.configuration.datacache_config.accessKey = optimade_url\n\n    # Perform query\n    response = requests.get(\n        optimade_url,\n        allow_redirects=True,\n        timeout=(3, 27),  # timeout in seconds (connect, read)\n    )\n\n    if optimade_query.response_format and optimade_query.response_format != \"json\":\n        raise NotImplementedError(\n            \"Can only handle JSON responses for now. Requested response format: \"\n            f\"{optimade_query.response_format!r}\"\n        )\n\n    cache = DataCache(config=self.resource_config.configuration.datacache_config)\n    cache.add(\n        {\n            \"status_code\": response.status_code,\n            \"ok\": response.ok,\n            \"json\": response.json(),\n        }\n    )\n\n    parse_with_dlite = use_dlite(\n        self.resource_config.accessService,\n        self.resource_config.configuration.use_dlite,\n    )\n\n    parse_mediaType = f\"application/vnd.{self.resource_config.accessService.split('+', maxsplit=1)[0]}\"  # pylint: disable=invalid-name,line-too-long\n    if parse_with_dlite:\n        parse_mediaType += \"+DLite\"  # pylint: disable=invalid-name\n    elif optimade_query.response_format:\n        parse_mediaType += (  # pylint: disable=invalid-name\n            f\"+{optimade_query.response_format}\"\n        )\n\n    parse_config = {\n        \"downloadUrl\": optimade_url,\n        \"mediaType\": parse_mediaType,\n        \"configuration\": {\n            \"datacache_config\": self.resource_config.configuration.datacache_config,\n            \"return_object\": True,\n        },\n    }\n\n    session.update(\n        create_strategy(StrategyType.PARSE, parse_config).initialize(\n            model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    )\n    session.update(\n        create_strategy(StrategyType.PARSE, parse_config).get(\n            model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    )\n\n    if \"optimade_response_object\" not in session:\n        raise ValueError(\n            \"'optimade_response_object' was expected to be present in the session.\"\n        )\n    optimade_response: \"OPTIMADEResponse\" = session.pop(\"optimade_response_object\")\n    if \"optimade_response\" in session and not session.get(\"optimade_response\"):\n        del session[\"optimade_response\"]\n\n    if isinstance(optimade_response, ErrorResponse):\n        optimade_resources = optimade_response.errors\n        session.optimade_resource_model = (\n            f\"{OptimadeError.__module__}:OptimadeError\"\n        )\n    elif isinstance(optimade_response, ReferenceResponseMany):\n        optimade_resources = [\n            Reference(entry).as_dict\n            if isinstance(entry, dict)\n            else Reference(entry.dict()).as_dict\n            for entry in optimade_response.data\n        ]\n        session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n    elif isinstance(optimade_response, ReferenceResponseOne):\n        optimade_resources = [\n            Reference(optimade_response.data).as_dict\n            if isinstance(optimade_response.data, dict)\n            else Reference(optimade_response.data.dict()).as_dict\n        ]\n        session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n    elif isinstance(optimade_response, StructureResponseMany):\n        optimade_resources = [\n            Structure(entry).as_dict\n            if isinstance(entry, dict)\n            else Structure(entry.dict()).as_dict\n            for entry in optimade_response.data\n        ]\n        session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n    elif isinstance(optimade_response, StructureResponseOne):\n        optimade_resources = [\n            Structure(optimade_response.data).as_dict\n            if isinstance(optimade_response.data, dict)\n            else Structure(optimade_response.data.dict()).as_dict\n        ]\n        session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n    else:\n        LOGGER.debug(\n            \"Could not parse response as errors, references or structures. \"\n            \"Response:\\n%r\",\n            optimade_response,\n        )\n        raise OPTIMADEParseError(\n            \"Could not retrieve errors, references or structures from response \"\n            f\"from {optimade_url}. It could be a valid OPTIMADE API response, \"\n            \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \"\n            \"invalid response completely.\"\n        )\n\n    session.optimade_resources = [\n        model2dict(resource) for resource in optimade_resources\n    ]\n\n    if session.optimade_config and session.optimade_config.query_parameters:\n        session = session.copy(\n            update={\n                \"optimade_config\": session.optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            session.optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            }\n        )\n\n    return session\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[SessionUpdate, DLiteSessionUpdate]</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def initialize(  # pylint: disable=unused-argument\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; \"Union[SessionUpdate, DLiteSessionUpdate]\":\n\"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if use_dlite(\n        self.resource_config.accessService,\n        self.resource_config.configuration.use_dlite,\n    ):\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.resource.use_dlite","title":"<code>use_dlite(access_service, use_dlite_flag)</code>","text":"<p>Determine whether DLite should be utilized in the Resource strategy.</p> <p>Parameters:</p> Name Type Description Default <code>access_service</code> <code>str</code> <p>The accessService value from the resource's configuration.</p> required <code>use_dlite_flag</code> <code>bool</code> <p>The strategy-specific <code>use_dlite</code> configuration option.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Based on the accessService value, then whether DLite should be used or not.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def use_dlite(access_service: str, use_dlite_flag: bool) -&gt; bool:\n\"\"\"Determine whether DLite should be utilized in the Resource strategy.\n\n    Parameters:\n        access_service: The accessService value from the resource's configuration.\n        use_dlite_flag: The strategy-specific `use_dlite` configuration option.\n\n    Returns:\n        Based on the accessService value, then whether DLite should be used or not.\n\n    \"\"\"\n    if (\n        any(dlite_form in access_service for dlite_form in [\"DLite\", \"dlite\"])\n        or use_dlite_flag\n    ):\n        if oteapi_dlite_version is None:\n            raise MissingDependency(\n                \"OTEAPI-DLite is not found on the system. This is required to use \"\n                \"DLite with the OTEAPI-OPTIMADE strategies.\"\n            )\n        return True\n    return False\n</code></pre>"},{"location":"api_reference/exceptions/","title":"exceptions","text":"<p>OTE-API OPTIMADE-specific Python exceptions.</p>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.BaseOteapiOptimadeException","title":"<code> BaseOteapiOptimadeException            (Exception)         </code>","text":"<p>Base OTE-API OPTIMADE exception.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class BaseOteapiOptimadeException(Exception):\n\"\"\"Base OTE-API OPTIMADE exception.\"\"\"\n</code></pre>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.ConfigurationError","title":"<code> ConfigurationError            (BaseOteapiOptimadeException)         </code>","text":"<p>An error occurred when dealing with strategy configurations.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class ConfigurationError(BaseOteapiOptimadeException):\n\"\"\"An error occurred when dealing with strategy configurations.\"\"\"\n</code></pre>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.MissingDependency","title":"<code> MissingDependency            (BaseOteapiOptimadeException)         </code>","text":"<p>A required dependency is missing.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class MissingDependency(BaseOteapiOptimadeException):\n\"\"\"A required dependency is missing.\"\"\"\n</code></pre>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.OPTIMADEParseError","title":"<code> OPTIMADEParseError            (BaseOteapiOptimadeException)         </code>","text":"<p>Could not use OPTIMADE Python tools to parse an OPTIMADE API response.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class OPTIMADEParseError(BaseOteapiOptimadeException):\n\"\"\"Could not use OPTIMADE Python tools to parse an OPTIMADE API response.\"\"\"\n</code></pre>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.OPTIMADEResponseError","title":"<code> OPTIMADEResponseError            (RequestError)         </code>","text":"<p>An OPTIMADE error was returned from a URL request.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class OPTIMADEResponseError(RequestError):\n\"\"\"An OPTIMADE error was returned from a URL request.\"\"\"\n</code></pre>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.RequestError","title":"<code> RequestError            (BaseOteapiOptimadeException)         </code>","text":"<p>A general error occured when performing a URL request.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class RequestError(BaseOteapiOptimadeException):\n\"\"\"A general error occured when performing a URL request.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/","title":"utils","text":"<p>Utility functions to be used in OTEAPI OPTIMADE.</p>"},{"location":"api_reference/utils/#oteapi_optimade.utils.model2dict","title":"<code>model2dict(model, **dict_kwargs)</code>","text":"<p>Convert a pydantic model to a Python dictionary.</p> <p>This works similarly to the <code>dict()</code> method for pydantic models, but ensures any and all nested pydantic models are also converted to dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Union[BaseModel, dict[str, Any]]</code> <p>The pydantic model or Python dictionary to be converted fully to a Python dictionary, through and through.</p> required <code>**dict_kwargs</code> <code>Dict[Any, Any]</code> <p>Keyword arguments to be passed to <code>dict()</code> method calls for pydantic models. Note, this will be used for all <code>dict()</code> method calls.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A Python dictionary, where all nested values that were pydantic models are also converted to Python dictionaries.</p> Source code in <code>oteapi_optimade/utils.py</code> <pre><code>def model2dict(\n    model: \"Union[BaseModel, dict[str, Any]]\", **dict_kwargs: \"Any\"\n) -&gt; \"dict[str, Any]\":\n\"\"\"Convert a pydantic model to a Python dictionary.\n\n    This works similarly to the `dict()` method for pydantic models, but ensures any\n    and all nested pydantic models are also converted to dictionaries.\n\n    Parameters:\n        model: The pydantic model or Python dictionary to be converted fully to a\n            Python dictionary, through and through.\n        **dict_kwargs (Dict[Any, Any]): Keyword arguments to be passed to `dict()`\n            method calls for pydantic models.\n            Note, this will be used for _all_ `dict()` method calls.\n\n    Returns:\n        A Python dictionary, where all nested values that were pydantic models are also\n        converted to Python dictionaries.\n\n    \"\"\"\n\n    def _internal(model_: \"Any\") -&gt; \"Any\":\n\"\"\"Internal function to be used recursively.\"\"\"\n        if isinstance(model_, dict):\n            return {key: _internal(value) for key, value in model_.items()}\n        if isinstance(model_, Iterable) and not isinstance(model_, (bytes, str)):\n            return type(model_)(_internal(value) for value in model_)  # type: ignore[call-arg]  # pylint: disable=line-too-long\n        if isinstance(model_, BaseModel):\n            return _internal(model_.dict(**dict_kwargs))\n        return model_\n\n    if isinstance(model, BaseModel):\n        res = model.dict(**dict_kwargs)\n    elif isinstance(model, dict):\n        res = deepcopy(model)\n    else:\n        raise TypeError(\"model must be either a pydantic model or a dict.\")\n\n    return _internal(res)\n</code></pre>"},{"location":"api_reference/models/config/","title":"config","text":"<p>General OPTIMADE configuration models.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.DEFAULT_CACHE_CONFIG_VALUES","title":"<code>DEFAULT_CACHE_CONFIG_VALUES</code>","text":"<p>Set the <code>expireTime</code> and <code>tag</code> to default values for the data cache.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig","title":"<code> OPTIMADEConfig            (AttrDict)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE configuration.</p> Source code in <code>oteapi_optimade/models/config.py</code> <pre><code>class OPTIMADEConfig(AttrDict):\n\"\"\"OPTIMADE configuration.\"\"\"\n\n    version: str = Field(\n        \"v1\",\n        description=\"The version part of the OPTIMADE versioned base URL.\",\n        regex=r\"^v[0-9]+(\\.[0-9]+){,2}$\",\n    )\n    endpoint: Literal[\"references\", \"structures\"] = Field(\n        \"structures\",\n        description=\"Supported OPTIMADE entry resource endpoint.\",\n    )\n    query_parameters: Optional[OPTIMADEQueryParameters] = Field(\n        None,\n        description=\"URL query parameters to be used in the OPTIMADE query.\",\n    )\n    datacache_config: DataCacheConfig = Field(\n        DataCacheConfig(**DEFAULT_CACHE_CONFIG_VALUES),\n        description=\"Configuration options for the local data cache.\",\n    )\n    return_object: bool = Field(\n        False,\n        description=(\n            \"Whether or not to return a response object (using the pydantic model).\\n\"\n            \"\\nImportant:\\n    This should _only_ be used if the strategy is called \"\n            \"directly and not via an OTEAPI REST API service.\"\n        ),\n    )\n    use_dlite: bool = Field(\n        False,\n        description=\"Whether or not to store the results in a DLite Collection.\",\n    )\n\n    @validator(\"datacache_config\")\n    def default_datacache_config(cls, value: DataCacheConfig) -&gt; DataCacheConfig:\n\"\"\"Use default values for `DataCacheConfig` if not supplied.\"\"\"\n        original_set_values = len(value.__fields_set__)\n\n        for field, default_value in DEFAULT_CACHE_CONFIG_VALUES.items():\n            if field in value.__fields_set__:\n                # Use the set value instead of the default\n                continue\n            setattr(value, field, default_value)\n\n        if len(value.__fields_set__) &gt; original_set_values:\n            # Re-validate model and return it\n            return value.validate(\n                {\n                    field: field_value\n                    for field, field_value in value.dict().items()\n                    if field in value.__fields_set__\n                }\n            )\n        return value\n</code></pre>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.datacache_config","title":"<code>datacache_config: DataCacheConfig</code>  <code>pydantic-field</code>","text":"<p>Configuration options for the local data cache.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.endpoint","title":"<code>endpoint: Literal['references', 'structures']</code>  <code>pydantic-field</code>","text":"<p>Supported OPTIMADE entry resource endpoint.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.query_parameters","title":"<code>query_parameters: OPTIMADEQueryParameters</code>  <code>pydantic-field</code>","text":"<p>URL query parameters to be used in the OPTIMADE query.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.return_object","title":"<code>return_object: bool</code>  <code>pydantic-field</code>","text":"<p>Whether or not to return a response object (using the pydantic model).</p> <p>Important</p> <p>This should only be used if the strategy is called directly and not via an OTEAPI REST API service.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.use_dlite","title":"<code>use_dlite: bool</code>  <code>pydantic-field</code>","text":"<p>Whether or not to store the results in a DLite Collection.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.version","title":"<code>version: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>The version part of the OPTIMADE versioned base URL.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.default_datacache_config","title":"<code>default_datacache_config(value)</code>  <code>classmethod</code>","text":"<p>Use default values for <code>DataCacheConfig</code> if not supplied.</p> Source code in <code>oteapi_optimade/models/config.py</code> <pre><code>@validator(\"datacache_config\")\ndef default_datacache_config(cls, value: DataCacheConfig) -&gt; DataCacheConfig:\n\"\"\"Use default values for `DataCacheConfig` if not supplied.\"\"\"\n    original_set_values = len(value.__fields_set__)\n\n    for field, default_value in DEFAULT_CACHE_CONFIG_VALUES.items():\n        if field in value.__fields_set__:\n            # Use the set value instead of the default\n            continue\n        setattr(value, field, default_value)\n\n    if len(value.__fields_set__) &gt; original_set_values:\n        # Re-validate model and return it\n        return value.validate(\n            {\n                field: field_value\n                for field, field_value in value.dict().items()\n                if field in value.__fields_set__\n            }\n        )\n    return value\n</code></pre>"},{"location":"api_reference/models/custom_types/","title":"custom_types","text":"<p>Custom \"pydantic\" types used in OTEAPI-OPTIMADE.</p>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.LOGGER","title":"<code>LOGGER</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl","title":"<code> OPTIMADEUrl            (str)         </code>","text":"<p>A deconstructed OPTIMADE URL.</p> <p>An OPTIMADE URL is made up in the following way:</p> <pre><code>&lt;BASE URL&gt;/[&lt;VERSION&gt;/]&lt;ENDPOINT&gt;?&lt;QUERY PARAMETERS&gt;\n</code></pre> <p>Where parts in square brackets (<code>[]</code>) are optional.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>class OPTIMADEUrl(str):\n\"\"\"A deconstructed OPTIMADE URL.\n\n    An OPTIMADE URL is made up in the following way:\n\n        &lt;BASE URL&gt;/[&lt;VERSION&gt;/]&lt;ENDPOINT&gt;?&lt;QUERY PARAMETERS&gt;\n\n    Where parts in square brackets (`[]`) are optional.\n    \"\"\"\n\n    strip_whitespace = True\n    min_length = 1\n    # https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers  # pylint: disable=line-too-long\n    max_length = 2083\n    allowed_schemes = {\"http\", \"https\"}\n    tld_required = False\n    user_required = False\n\n    __slots__ = (\n        \"base_url\",\n        \"version\",\n        \"endpoint\",\n        \"query\",\n        \"scheme\",\n        \"tld\",\n        \"host_type\",\n    )\n\n    @no_type_check\n    def __new__(cls, url: \"Optional[str]\" = None, **kwargs) -&gt; object:\n        return str.__new__(\n            cls,\n            cls.build(**kwargs) if url is None else url,  # pylint: disable=missing-kwoa\n        )\n\n    def __init__(\n        self,\n        url: str,\n        *,\n        base_url: \"Optional[str]\" = None,\n        version: \"Optional[str]\" = None,\n        endpoint: \"Optional[str]\" = None,\n        query: \"Optional[str]\" = None,\n        scheme: \"Optional[str]\" = None,\n        tld: \"Optional[str]\" = None,\n        host_type: str = \"domain\",\n    ) -&gt; None:\n        str.__init__(url)\n        self.base_url = base_url\n        self.version = version\n        self.endpoint = endpoint\n        self.query = query\n        self.scheme = scheme\n        self.tld = tld\n        self.host_type = host_type\n\n    @classmethod\n    def build(\n        cls,\n        *,\n        base_url: \"str\",\n        version: \"Optional[str]\" = None,\n        endpoint: \"Optional[str]\" = None,\n        query: \"Optional[str]\" = None,\n        **_kwargs: str,\n    ) -&gt; str:\n\"\"\"Build complete URL from URL parts.\"\"\"\n        url = base_url.rstrip(\"/\")\n        if version:\n            url += f\"/{version}\"\n        if endpoint:\n            url += f\"/{endpoint}\"\n        if query:\n            url += f\"?{query}\"\n        return url\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: \"Dict[str, Any]\") -&gt; None:\n        update_not_none(\n            field_schema,\n            minLength=cls.min_length,\n            maxLength=cls.max_length,\n            format=\"uri\",\n        )\n\n    @classmethod\n    def __get_validators__(cls) -&gt; \"CallableGenerator\":\n        yield cls.validate\n\n    @staticmethod\n    def urlquote_qs(url: str) -&gt; str:\n\"\"\"Use `urllib.parse.quote` for query part of URL.\"\"\"\n        parsed_url = urlparse(url)\n        quoted_query = urlquote(parsed_url.query, safe=\"=&amp;,\")\n        parsed_url_list = list(parsed_url)\n        parsed_url_list[-2] = quoted_query\n        return urlunparse(parsed_url_list)\n\n    @classmethod\n    def validate(\n        cls, value: \"Any\", field: \"ModelField\", config: \"BaseConfig\"\n    ) -&gt; \"OPTIMADEUrl\":\n\"\"\"Pydantic validation of an OPTIMADE URL.\"\"\"\n        if value.__class__ == cls:\n            return value\n\n        value: str = str_validator(value)\n        if cls.strip_whitespace:\n            value = value.strip()\n        url: str = cast(str, constr_length_validator(value, field, config))\n        url = cls.urlquote_qs(url)\n\n        url_match = url_regex().match(url)\n        if url_match is None:\n            raise ValueError(f\"Cannot match URL ({url!r}) as a valid URL.\")\n\n        original_parts = cast(\"Parts\", url_match.groupdict())\n        parts = cls.apply_default_parts(original_parts)\n        host, tld, host_type, rebuild = cls.validate_host(parts)\n        optimade_parts = cls.build_optimade_parts(parts, host)\n        optimade_parts = cls.validate_parts(parts, optimade_parts)\n\n        if url_match.end() != len(url):\n            raise errors.UrlExtraError(extra=url[url_match.end() :])\n\n        return cls(\n            None if rebuild else url,\n            base_url=optimade_parts[\"base_url\"],\n            version=optimade_parts[\"version\"],\n            endpoint=optimade_parts[\"endpoint\"],\n            query=optimade_parts[\"query\"],\n            scheme=parts[\"scheme\"],\n            tld=tld,\n            host_type=host_type,\n        )\n\n    @classmethod\n    def validate_host(cls, parts: \"Parts\") -&gt; \"Tuple[str, Optional[str], str, bool]\":\n\"\"\"Validate host-part of the URL.\"\"\"\n        host: \"Optional[str]\" = None\n        tld: \"Optional[str]\" = None\n        rebuild: bool = False\n        for host_type in (\"domain\", \"ipv4\", \"ipv6\"):\n            host = parts[host_type]  # type: ignore[literal-required]\n            if host:\n                break\n        else:\n            raise errors.UrlHostError()\n\n        if host_type == \"domain\":\n            is_international = False\n            domain = ascii_domain_regex().fullmatch(host)\n            if domain is None:\n                domain = int_domain_regex().fullmatch(host)\n                if domain is None:\n                    raise errors.UrlHostError()\n                is_international = True\n\n            tld = domain.group(\"tld\")\n            if tld is None and not is_international:\n                domain = int_domain_regex().fullmatch(host)\n                if domain is None:\n                    raise ValueError(\"domain cannot be None\")\n                tld = domain.group(\"tld\")\n                is_international = True\n\n            if tld is not None:\n                tld = tld[1:]\n            elif cls.tld_required:\n                raise errors.UrlHostTldError()\n\n            if is_international:\n                host_type = \"int_domain\"\n                rebuild = True\n                host = host.encode(\"idna\").decode(\"ascii\")\n                if tld is not None:\n                    tld = tld.encode(\"idna\").decode(\"ascii\")\n\n        return host, tld, host_type, rebuild\n\n    @staticmethod\n    def get_default_parts(parts: \"Parts\") -&gt; \"Parts\":\n\"\"\"Dictionary of default URL-part values.\"\"\"\n        return {\"port\": \"80\" if parts[\"scheme\"] == \"http\" else \"443\"}\n\n    @classmethod\n    def apply_default_parts(cls, parts: \"Parts\") -&gt; \"Parts\":\n\"\"\"Apply default URL-part values if no value is given.\"\"\"\n        for key, value in cls.get_default_parts(parts).items():\n            if not parts[key]:  # type: ignore[literal-required]\n                parts[key] = value  # type: ignore[literal-required]\n        return parts\n\n    @classmethod\n    def build_optimade_parts(cls, parts: \"Parts\", host: str) -&gt; \"OPTIMADEParts\":\n\"\"\"Convert URL parts to equivalent OPTIMADE URL parts.\"\"\"\n        base_url = f\"{parts['scheme']}://\"\n        if parts[\"user\"]:\n            base_url += parts[\"user\"]\n        if parts[\"password\"]:\n            base_url += f\":{parts['password']}\"\n        if parts[\"user\"] or parts[\"password\"]:\n            base_url += \"@\"\n        base_url += host\n        # Hide port if it's a standard HTTP (80) or HTTPS (443) port.\n        if parts[\"port\"] and parts[\"port\"] not in (\"80\", \"443\"):\n            base_url += f\":{parts['port']}\"\n        if parts[\"path\"]:\n            base_url += parts[\"path\"]\n\n        base_url_match = optimade_base_url_regex().fullmatch(base_url)\n        LOGGER.debug(\n            \"OPTIMADE base URL regex match groups: %s\",\n            base_url_match.groupdict() if base_url_match else base_url_match,\n        )\n        if base_url_match is None:\n            raise ValueError(\n                \"Could not match given string with OPTIMADE base URL regex.\"\n            )\n\n        endpoint_match = optimade_endpoint_regex().findall(\n            base_url_match.group(\"path\") if base_url_match.group(\"path\") else \"\"\n        )\n        LOGGER.debug(\"OPTIMADE endpoint regex matches: %s\", endpoint_match)\n        for path_version, path_endpoint in endpoint_match:\n            if path_endpoint:\n                break\n        else:\n            LOGGER.debug(\"Could not match given string with OPTIMADE endpoint regex.\")\n            path_version, path_endpoint = \"\", \"\"\n\n        base_url = base_url_match.group(\"base_url\")\n        if path_version:\n            base_url = base_url[: -(len(path_version) + len(path_endpoint) + 2)]\n        elif path_endpoint:\n            base_url = base_url[: -(len(path_endpoint) + 1)]\n\n        optimade_parts = {\n            \"base_url\": base_url.rstrip(\"/\"),\n            \"version\": path_version or None,\n            \"endpoint\": path_endpoint or None,\n            \"query\": parts[\"query\"],\n        }\n        return cast(\"OPTIMADEParts\", optimade_parts)\n\n    @classmethod\n    def validate_parts(\n        cls, parts: \"Parts\", optimade_parts: \"OPTIMADEParts\"\n    ) -&gt; \"OPTIMADEParts\":\n\"\"\"\n        A method used to validate parts of an URL.\n        Could be overridden to set default values for parts if missing\n        \"\"\"\n        scheme = parts[\"scheme\"]\n        if scheme is None:\n            raise errors.UrlSchemeError()\n\n        if cls.allowed_schemes and scheme.lower() not in cls.allowed_schemes:\n            raise errors.UrlSchemePermittedError(set(cls.allowed_schemes))\n\n        port = parts[\"port\"]\n        if port is not None and int(port) &gt; 65_535:\n            raise errors.UrlPortError()\n\n        user = parts[\"user\"]\n        if cls.user_required and user is None:\n            raise errors.UrlUserInfoError()\n\n        base_url = optimade_parts[\"base_url\"]\n        if base_url is None:\n            raise errors.UrlError()\n\n        return optimade_parts\n\n    def __repr__(self) -&gt; str:\n        extra = \", \".join(\n            f\"{n}={getattr(self, n)!r}\"\n            for n in self.__slots__\n            if getattr(self, n) is not None\n        )\n        return f\"{self.__class__.__name__}({super().__repr__()}, {extra})\"\n\n    def response_model(self) -&gt; \"Union[Tuple[Success, ...], Success, None]\":\n\"\"\"Return the endpoint's corresponding response model (from OPT).\"\"\"\n        if not self.endpoint or self.endpoint == \"versions\":\n            return None\n        return {\n            \"info\": (InfoResponse, EntryInfoResponse),\n            \"links\": LinksResponse,\n            \"structures\": (StructureResponseMany, StructureResponseOne),\n            \"references\": (ReferenceResponseMany, ReferenceResponseOne),\n            \"calculations\": (EntryResponseMany, EntryResponseOne),\n        }.get(self.endpoint, Success)\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.allowed_schemes","title":"<code>allowed_schemes</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.max_length","title":"<code>max_length</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.min_length","title":"<code>min_length</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.strip_whitespace","title":"<code>strip_whitespace</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.tld_required","title":"<code>tld_required</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.user_required","title":"<code>user_required</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.__init__","title":"<code>__init__(self, url, *, base_url=None, version=None, endpoint=None, query=None, scheme=None, tld=None, host_type='domain')</code>  <code>special</code>","text":"Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    *,\n    base_url: \"Optional[str]\" = None,\n    version: \"Optional[str]\" = None,\n    endpoint: \"Optional[str]\" = None,\n    query: \"Optional[str]\" = None,\n    scheme: \"Optional[str]\" = None,\n    tld: \"Optional[str]\" = None,\n    host_type: str = \"domain\",\n) -&gt; None:\n    str.__init__(url)\n    self.base_url = base_url\n    self.version = version\n    self.endpoint = endpoint\n    self.query = query\n    self.scheme = scheme\n    self.tld = tld\n    self.host_type = host_type\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.apply_default_parts","title":"<code>apply_default_parts(parts)</code>  <code>classmethod</code>","text":"<p>Apply default URL-part values if no value is given.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef apply_default_parts(cls, parts: \"Parts\") -&gt; \"Parts\":\n\"\"\"Apply default URL-part values if no value is given.\"\"\"\n    for key, value in cls.get_default_parts(parts).items():\n        if not parts[key]:  # type: ignore[literal-required]\n            parts[key] = value  # type: ignore[literal-required]\n    return parts\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.build","title":"<code>build(*, base_url, version=None, endpoint=None, query=None, **_kwargs)</code>  <code>classmethod</code>","text":"<p>Build complete URL from URL parts.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef build(\n    cls,\n    *,\n    base_url: \"str\",\n    version: \"Optional[str]\" = None,\n    endpoint: \"Optional[str]\" = None,\n    query: \"Optional[str]\" = None,\n    **_kwargs: str,\n) -&gt; str:\n\"\"\"Build complete URL from URL parts.\"\"\"\n    url = base_url.rstrip(\"/\")\n    if version:\n        url += f\"/{version}\"\n    if endpoint:\n        url += f\"/{endpoint}\"\n    if query:\n        url += f\"?{query}\"\n    return url\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.build_optimade_parts","title":"<code>build_optimade_parts(parts, host)</code>  <code>classmethod</code>","text":"<p>Convert URL parts to equivalent OPTIMADE URL parts.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef build_optimade_parts(cls, parts: \"Parts\", host: str) -&gt; \"OPTIMADEParts\":\n\"\"\"Convert URL parts to equivalent OPTIMADE URL parts.\"\"\"\n    base_url = f\"{parts['scheme']}://\"\n    if parts[\"user\"]:\n        base_url += parts[\"user\"]\n    if parts[\"password\"]:\n        base_url += f\":{parts['password']}\"\n    if parts[\"user\"] or parts[\"password\"]:\n        base_url += \"@\"\n    base_url += host\n    # Hide port if it's a standard HTTP (80) or HTTPS (443) port.\n    if parts[\"port\"] and parts[\"port\"] not in (\"80\", \"443\"):\n        base_url += f\":{parts['port']}\"\n    if parts[\"path\"]:\n        base_url += parts[\"path\"]\n\n    base_url_match = optimade_base_url_regex().fullmatch(base_url)\n    LOGGER.debug(\n        \"OPTIMADE base URL regex match groups: %s\",\n        base_url_match.groupdict() if base_url_match else base_url_match,\n    )\n    if base_url_match is None:\n        raise ValueError(\n            \"Could not match given string with OPTIMADE base URL regex.\"\n        )\n\n    endpoint_match = optimade_endpoint_regex().findall(\n        base_url_match.group(\"path\") if base_url_match.group(\"path\") else \"\"\n    )\n    LOGGER.debug(\"OPTIMADE endpoint regex matches: %s\", endpoint_match)\n    for path_version, path_endpoint in endpoint_match:\n        if path_endpoint:\n            break\n    else:\n        LOGGER.debug(\"Could not match given string with OPTIMADE endpoint regex.\")\n        path_version, path_endpoint = \"\", \"\"\n\n    base_url = base_url_match.group(\"base_url\")\n    if path_version:\n        base_url = base_url[: -(len(path_version) + len(path_endpoint) + 2)]\n    elif path_endpoint:\n        base_url = base_url[: -(len(path_endpoint) + 1)]\n\n    optimade_parts = {\n        \"base_url\": base_url.rstrip(\"/\"),\n        \"version\": path_version or None,\n        \"endpoint\": path_endpoint or None,\n        \"query\": parts[\"query\"],\n    }\n    return cast(\"OPTIMADEParts\", optimade_parts)\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.get_default_parts","title":"<code>get_default_parts(parts)</code>  <code>staticmethod</code>","text":"<p>Dictionary of default URL-part values.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@staticmethod\ndef get_default_parts(parts: \"Parts\") -&gt; \"Parts\":\n\"\"\"Dictionary of default URL-part values.\"\"\"\n    return {\"port\": \"80\" if parts[\"scheme\"] == \"http\" else \"443\"}\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.response_model","title":"<code>response_model(self)</code>","text":"<p>Return the endpoint's corresponding response model (from OPT).</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>def response_model(self) -&gt; \"Union[Tuple[Success, ...], Success, None]\":\n\"\"\"Return the endpoint's corresponding response model (from OPT).\"\"\"\n    if not self.endpoint or self.endpoint == \"versions\":\n        return None\n    return {\n        \"info\": (InfoResponse, EntryInfoResponse),\n        \"links\": LinksResponse,\n        \"structures\": (StructureResponseMany, StructureResponseOne),\n        \"references\": (ReferenceResponseMany, ReferenceResponseOne),\n        \"calculations\": (EntryResponseMany, EntryResponseOne),\n    }.get(self.endpoint, Success)\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.urlquote_qs","title":"<code>urlquote_qs(url)</code>  <code>staticmethod</code>","text":"<p>Use <code>urllib.parse.quote</code> for query part of URL.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@staticmethod\ndef urlquote_qs(url: str) -&gt; str:\n\"\"\"Use `urllib.parse.quote` for query part of URL.\"\"\"\n    parsed_url = urlparse(url)\n    quoted_query = urlquote(parsed_url.query, safe=\"=&amp;,\")\n    parsed_url_list = list(parsed_url)\n    parsed_url_list[-2] = quoted_query\n    return urlunparse(parsed_url_list)\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.validate","title":"<code>validate(value, field, config)</code>  <code>classmethod</code>","text":"<p>Pydantic validation of an OPTIMADE URL.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef validate(\n    cls, value: \"Any\", field: \"ModelField\", config: \"BaseConfig\"\n) -&gt; \"OPTIMADEUrl\":\n\"\"\"Pydantic validation of an OPTIMADE URL.\"\"\"\n    if value.__class__ == cls:\n        return value\n\n    value: str = str_validator(value)\n    if cls.strip_whitespace:\n        value = value.strip()\n    url: str = cast(str, constr_length_validator(value, field, config))\n    url = cls.urlquote_qs(url)\n\n    url_match = url_regex().match(url)\n    if url_match is None:\n        raise ValueError(f\"Cannot match URL ({url!r}) as a valid URL.\")\n\n    original_parts = cast(\"Parts\", url_match.groupdict())\n    parts = cls.apply_default_parts(original_parts)\n    host, tld, host_type, rebuild = cls.validate_host(parts)\n    optimade_parts = cls.build_optimade_parts(parts, host)\n    optimade_parts = cls.validate_parts(parts, optimade_parts)\n\n    if url_match.end() != len(url):\n        raise errors.UrlExtraError(extra=url[url_match.end() :])\n\n    return cls(\n        None if rebuild else url,\n        base_url=optimade_parts[\"base_url\"],\n        version=optimade_parts[\"version\"],\n        endpoint=optimade_parts[\"endpoint\"],\n        query=optimade_parts[\"query\"],\n        scheme=parts[\"scheme\"],\n        tld=tld,\n        host_type=host_type,\n    )\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.validate_host","title":"<code>validate_host(parts)</code>  <code>classmethod</code>","text":"<p>Validate host-part of the URL.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef validate_host(cls, parts: \"Parts\") -&gt; \"Tuple[str, Optional[str], str, bool]\":\n\"\"\"Validate host-part of the URL.\"\"\"\n    host: \"Optional[str]\" = None\n    tld: \"Optional[str]\" = None\n    rebuild: bool = False\n    for host_type in (\"domain\", \"ipv4\", \"ipv6\"):\n        host = parts[host_type]  # type: ignore[literal-required]\n        if host:\n            break\n    else:\n        raise errors.UrlHostError()\n\n    if host_type == \"domain\":\n        is_international = False\n        domain = ascii_domain_regex().fullmatch(host)\n        if domain is None:\n            domain = int_domain_regex().fullmatch(host)\n            if domain is None:\n                raise errors.UrlHostError()\n            is_international = True\n\n        tld = domain.group(\"tld\")\n        if tld is None and not is_international:\n            domain = int_domain_regex().fullmatch(host)\n            if domain is None:\n                raise ValueError(\"domain cannot be None\")\n            tld = domain.group(\"tld\")\n            is_international = True\n\n        if tld is not None:\n            tld = tld[1:]\n        elif cls.tld_required:\n            raise errors.UrlHostTldError()\n\n        if is_international:\n            host_type = \"int_domain\"\n            rebuild = True\n            host = host.encode(\"idna\").decode(\"ascii\")\n            if tld is not None:\n                tld = tld.encode(\"idna\").decode(\"ascii\")\n\n    return host, tld, host_type, rebuild\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.validate_parts","title":"<code>validate_parts(parts, optimade_parts)</code>  <code>classmethod</code>","text":"<p>A method used to validate parts of an URL. Could be overridden to set default values for parts if missing</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef validate_parts(\n    cls, parts: \"Parts\", optimade_parts: \"OPTIMADEParts\"\n) -&gt; \"OPTIMADEParts\":\n\"\"\"\n    A method used to validate parts of an URL.\n    Could be overridden to set default values for parts if missing\n    \"\"\"\n    scheme = parts[\"scheme\"]\n    if scheme is None:\n        raise errors.UrlSchemeError()\n\n    if cls.allowed_schemes and scheme.lower() not in cls.allowed_schemes:\n        raise errors.UrlSchemePermittedError(set(cls.allowed_schemes))\n\n    port = parts[\"port\"]\n    if port is not None and int(port) &gt; 65_535:\n        raise errors.UrlPortError()\n\n    user = parts[\"user\"]\n    if cls.user_required and user is None:\n        raise errors.UrlUserInfoError()\n\n    base_url = optimade_parts[\"base_url\"]\n    if base_url is None:\n        raise errors.UrlError()\n\n    return optimade_parts\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.optimade_base_url_regex","title":"<code>optimade_base_url_regex()</code>","text":"<p>A regular expression for an OPTIMADE base URL.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>def optimade_base_url_regex() -&gt; \"Pattern[str]\":\n\"\"\"A regular expression for an OPTIMADE base URL.\"\"\"\n    global _OPTIMADE_BASE_URL_REGEX  # pylint: disable=global-statement\n    if _OPTIMADE_BASE_URL_REGEX is None:\n        _OPTIMADE_BASE_URL_REGEX = re.compile(\n            r\"^(?P&lt;base_url&gt;\"\n            # scheme https://tools.ietf.org/html/rfc3986#appendix-A\n            r\"(?:[a-z][a-z0-9+\\-.]+://)?\"\n            r\"(?:[^\\s:/]*(?::[^\\s/]*)?@)?\"  # user info\n            r\"(?:\"\n            r\"(?:\\d{1,3}\\.){3}\\d{1,3}(?=$|[/:#?])|\"  # ipv4\n            r\"\\[[A-F0-9]*:[A-F0-9:]+\\](?=$|[/:#?])|\"  # ipv6\n            r\"[^\\s/:?#]+\"  # domain, validation occurs later\n            r\")?\"\n            r\"(?::\\d+)?\"  # port\n            r\"(?P&lt;path&gt;/[^\\s?#]*)?\"  # path\n            r\")\",\n            re.IGNORECASE,\n        )\n    return _OPTIMADE_BASE_URL_REGEX\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.optimade_endpoint_regex","title":"<code>optimade_endpoint_regex()</code>","text":"<p>A regular expression for an OPTIMADE base URL.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>def optimade_endpoint_regex() -&gt; \"Pattern[str]\":\n\"\"\"A regular expression for an OPTIMADE base URL.\"\"\"\n    global _OPTIMADE_ENDPOINT_REGEX  # pylint: disable=global-statement\n    if _OPTIMADE_ENDPOINT_REGEX is None:\n        _OPTIMADE_ENDPOINT_REGEX = re.compile(\n            # version\n            r\"(?:/(?P&lt;version&gt;v[0-9]+(?:\\.[0-9+]){0,2})\"\n            r\"(?=/info|/links|/version|/structures|/references|/calculations\"\n            r\"|/extensions))?\"\n            # endpoint\n            r\"(?:/(?P&lt;endpoint&gt;(?:info|links|versions|structures|references\"\n            r\"|calculations|extensions)(?:/[^\\s?#]*)?))?$\"\n        )\n    return _OPTIMADE_ENDPOINT_REGEX\n</code></pre>"},{"location":"api_reference/models/query/","title":"query","text":"<p>Data models related to OPTIMADE queries.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.QUERY_PARAMETERS","title":"<code>QUERY_PARAMETERS</code>","text":"<p>Entry listing URL query parameters from the <code>optimade</code> package (<code>EntryListingQueryParams</code>).</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters","title":"<code> OPTIMADEQueryParameters            (BaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Common OPTIMADE entry listing endpoint query parameters.</p> Source code in <code>oteapi_optimade/models/query.py</code> <pre><code>class OPTIMADEQueryParameters(BaseModel, validate_assignment=True):\n\"\"\"Common OPTIMADE entry listing endpoint query parameters.\"\"\"\n\n    filter: Optional[str] = Field(\n        QUERY_PARAMETERS.filter.default,\n        description=QUERY_PARAMETERS.filter.description,\n    )\n    response_format: Optional[str] = Field(\n        QUERY_PARAMETERS.response_format.default,\n        description=QUERY_PARAMETERS.response_format.description,\n    )\n    email_address: Optional[EmailStr] = Field(\n        QUERY_PARAMETERS.email_address.default,\n        description=QUERY_PARAMETERS.email_address.description,\n    )\n    response_fields: Optional[str] = Field(\n        QUERY_PARAMETERS.response_fields.default,\n        description=QUERY_PARAMETERS.response_fields.description,\n        regex=QUERY_PARAMETERS.response_fields.regex,\n    )\n    sort: Optional[str] = Field(\n        QUERY_PARAMETERS.sort.default,\n        description=QUERY_PARAMETERS.sort.description,\n        regex=QUERY_PARAMETERS.sort.regex,\n    )\n    page_limit: Optional[int] = Field(\n        QUERY_PARAMETERS.page_limit.default,\n        description=QUERY_PARAMETERS.page_limit.description,\n        ge=QUERY_PARAMETERS.page_limit.ge,\n    )\n    page_offset: Optional[int] = Field(\n        QUERY_PARAMETERS.page_offset.default,\n        description=QUERY_PARAMETERS.page_offset.description,\n        ge=QUERY_PARAMETERS.page_offset.ge,\n    )\n    page_number: Optional[int] = Field(\n        QUERY_PARAMETERS.page_number.default,\n        description=QUERY_PARAMETERS.page_number.description,\n        ge=QUERY_PARAMETERS.page_number.ge,\n    )\n    page_cursor: Optional[int] = Field(\n        QUERY_PARAMETERS.page_cursor.default,\n        description=QUERY_PARAMETERS.page_cursor.description,\n        ge=QUERY_PARAMETERS.page_cursor.ge,\n    )\n    page_above: Optional[int] = Field(\n        QUERY_PARAMETERS.page_above.default,\n        description=QUERY_PARAMETERS.page_above.description,\n        ge=QUERY_PARAMETERS.page_above.ge,\n    )\n    page_below: Optional[int] = Field(\n        QUERY_PARAMETERS.page_below.default,\n        description=QUERY_PARAMETERS.page_below.description,\n        ge=QUERY_PARAMETERS.page_below.ge,\n    )\n    include: Optional[str] = Field(\n        QUERY_PARAMETERS.include.default,\n        description=QUERY_PARAMETERS.include.description,\n    )\n    # api_hint is not yet initialized in `EntryListingQueryParams`.\n    # These values are copied verbatim from `optimade==0.16.10`.\n    api_hint: Optional[str] = Field(\n        \"\",\n        description=(\n            \"If the client provides the parameter, the value SHOULD have the format \"\n            \"`vMAJOR` or `vMAJOR.MINOR`, where MAJOR is a major version and MINOR is a\"\n            \" minor version of the API. For example, if a client appends \"\n            \"`api_hint=v1.0` to the query string, the hint provided is for major \"\n            \"version 1 and minor version 0.\"\n        ),\n        regex=r\"(v[0-9]+(\\.[0-9]+)?)?\",\n    )\n\n    def generate_query_string(self) -&gt; str:\n\"\"\"Generate a valid URL query string based on the set fields.\"\"\"\n        res = {}\n        for field, value in self.dict().items():\n            if (\n                value\n                or field\n                in self.__fields_set__  # pylint: disable=unsupported-membership-test\n            ):\n                res[field] = unquote(value) if isinstance(value, str) else value\n        return urlencode(res, quote_via=quote)\n</code></pre>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.api_hint","title":"<code>api_hint: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>If the client provides the parameter, the value SHOULD have the format <code>vMAJOR</code> or <code>vMAJOR.MINOR</code>, where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends <code>api_hint=v1.0</code> to the query string, the hint provided is for major version 1 and minor version 0.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.email_address","title":"<code>email_address: EmailStr</code>  <code>pydantic-field</code>","text":"<p>An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: <code>http://example.com/v1/structures?email_address=user@example.com</code></p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.filter","title":"<code>filter: str</code>  <code>pydantic-field</code>","text":"<p>A filter string, in the format described in section API Filtering Format Specification of the specification.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.include","title":"<code>include: str</code>  <code>pydantic-field</code>","text":"<p>A server MAY implement the JSON API concept of returning compound documents by utilizing the <code>include</code> query parameter as specified by JSON API 1.0.</p> <p>All related resource objects MUST be returned as part of an array value for the top-level <code>included</code> field, see the section JSON Response Schema: Common Fields.</p> <p>The value of <code>include</code> MUST be a comma-separated list of \"relationship paths\", as defined in the JSON API. If relationship paths are not supported, or a server is unable to identify a relationship path a <code>400 Bad Request</code> response MUST be made.</p> <p>The default value for <code>include</code> is <code>references</code>. This means <code>references</code> entries MUST always be included under the top-level field <code>included</code> as default, since a server assumes if <code>include</code> is not specified by a client in the request, it is still specified as <code>include=references</code>. Note, if a client explicitly specifies <code>include</code> and leaves out <code>references</code>, <code>references</code> resource objects MUST NOT be included under the top-level field <code>included</code>, as per the definition of <code>included</code>, see section JSON Response Schema: Common Fields.</p> <p>Note: A query with the parameter <code>include</code> set to the empty string means no related resource objects are to be returned under the top-level field <code>included</code>.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_above","title":"<code>page_above: int</code>  <code>pydantic-field</code>","text":"<p>RECOMMENDED for use with value-based pagination: using <code>page_above</code>/<code>page_below</code> and <code>page_limit</code> is RECOMMENDED. Example: Fetch up to 100 structures above sort-field value 4000 (in this example, server chooses to fetch results sorted by increasing <code>id</code>, so <code>page_above</code> value refers to an <code>id</code> value): <code>/structures?page_above=4000&amp;page_limit=100</code>.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_below","title":"<code>page_below: int</code>  <code>pydantic-field</code>","text":"<p>RECOMMENDED for use with value-based pagination: using <code>page_above</code>/<code>page_below</code> and <code>page_limit</code> is RECOMMENDED.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_cursor","title":"<code>page_cursor: ConstrainedIntValue</code>  <code>pydantic-field</code>","text":"<p>RECOMMENDED for use with cursor-based pagination: using <code>page_cursor</code> and <code>page_limit</code> is RECOMMENDED.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_limit","title":"<code>page_limit: ConstrainedIntValue</code>  <code>pydantic-field</code>","text":"<p>Sets a numerical limit on the number of entries returned. See JSON API 1.0. The API implementation MUST return no more than the number specified. It MAY return fewer. The database MAY have a maximum limit and not accept larger numbers (in which case an error code -- 403 Forbidden -- MUST be returned). The default limit value is up to the API implementation to decide. Example: <code>http://example.com/optimade/v1/structures?page_limit=100</code></p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_number","title":"<code>page_number: int</code>  <code>pydantic-field</code>","text":"<p>RECOMMENDED for use with page-based pagination: using <code>page_number</code> and <code>page_limit</code> is RECOMMENDED. It is RECOMMENDED that the first page has number 1, i.e., that <code>page_number</code> is 1-based. Example: Fetch page 2 of up to 50 structures per page: <code>/structures?page_number=2&amp;page_limit=50</code>.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_offset","title":"<code>page_offset: ConstrainedIntValue</code>  <code>pydantic-field</code>","text":"<p>RECOMMENDED for use with offset-based pagination: using <code>page_offset</code> and <code>page_limit</code> is RECOMMENDED. Example: Skip 50 structures and fetch up to 100: <code>/structures?page_offset=50&amp;page_limit=100</code>.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.response_fields","title":"<code>response_fields: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: <code>http://example.com/v1/structures?response_fields=last_modified,nsites</code></p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.response_format","title":"<code>response_format: str</code>  <code>pydantic-field</code>","text":"<p>The output format requested (see section Response Format). Defaults to the format string 'json', which specifies the standard output format described in this specification. Example: <code>http://example.com/v1/structures?response_format=xml</code></p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.sort","title":"<code>sort: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>If supporting sortable queries, an implementation MUST use the <code>sort</code> query parameter with format as specified by JSON API 1.0.</p> <p>An implementation MAY support multiple sort fields for a single query. If it does, it again MUST conform to the JSON API 1.0 specification.</p> <p>If an implementation supports sorting for an entry listing endpoint, then the <code>/info/&lt;entries&gt;</code> endpoint MUST include, for each field name <code>&lt;fieldname&gt;</code> in its <code>data.properties.&lt;fieldname&gt;</code> response value that can be used for sorting, the key <code>sortable</code> with value <code>true</code>. If a field name under an entry listing endpoint supporting sorting cannot be used for sorting, the server MUST either leave out the <code>sortable</code> key or set it equal to <code>false</code> for the specific field name. The set of field names, with <code>sortable</code> equal to <code>true</code> are allowed to be used in the \"sort fields\" list according to its definition in the JSON API 1.0 specification. The field <code>sortable</code> is in addition to each property description and other OPTIONAL fields. An example is shown in the section Entry Listing Info Endpoints.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.generate_query_string","title":"<code>generate_query_string(self)</code>","text":"<p>Generate a valid URL query string based on the set fields.</p> Source code in <code>oteapi_optimade/models/query.py</code> <pre><code>def generate_query_string(self) -&gt; str:\n\"\"\"Generate a valid URL query string based on the set fields.\"\"\"\n    res = {}\n    for field, value in self.dict().items():\n        if (\n            value\n            or field\n            in self.__fields_set__  # pylint: disable=unsupported-membership-test\n        ):\n            res[field] = unquote(value) if isinstance(value, str) else value\n    return urlencode(res, quote_via=quote)\n</code></pre>"},{"location":"api_reference/models/strategies/filter/","title":"filter","text":"<p>Models specific to the filter strategy.</p>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterConfig","title":"<code> OPTIMADEFilterConfig            (FilterConfig)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE-specific filter strategy config.</p> <p>Note</p> <p>The <code>condition</code> parameter is not taken into account.</p> Source code in <code>oteapi_optimade/models/strategies/filter.py</code> <pre><code>class OPTIMADEFilterConfig(FilterConfig):\n\"\"\"OPTIMADE-specific filter strategy config.\n\n    Note:\n        The `condition` parameter is not taken into account.\n\n    \"\"\"\n\n    filterType: Literal[\"optimade\", \"OPTIMADE\", \"OPTiMaDe\"] = Field(\n        ...,\n        description=\"The registered strategy name for OPTIMADEFilterStrategy.\",\n    )\n    query: Optional[str] = Field(\n        None,\n        description=(\n            \"The `filter` OPTIMADE query parameter value. This parameter value can \"\n            \"also be provided through the [`configuration.query_parameters.filter`]\"\n            \"[oteapi_optimade.models.query.OPTIMADEQueryParameters.filter] parameter. \"\n            \"Note, this value takes precedence over [`configuration`][oteapi_optimade.\"\n            \"models.strategies.filter.OPTIMADEFilterConfig.configuration] values.\"\n        ),\n    )\n    limit: Optional[int] = Field(\n        None,\n        description=(\n            \"The `page_limit` OPTIMADE query parameter value. This parameter value can\"\n            \" also be provided through the [`configuration.query_parameters.\"\n            \"page_limit`][oteapi_optimade.models.query.OPTIMADEQueryParameters.\"\n            \"page_limit] parameter. Note, this value takes precedence over \"\n            \"[`configuration`][oteapi_optimade.models.strategies.filter.\"\n            \"OPTIMADEFilterConfig.configuration] values.\"\n        ),\n    )\n    configuration: OPTIMADEConfig = Field(\n        OPTIMADEConfig(),\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession","title":"<code> OPTIMADEFilterSession            (SessionUpdate)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE session for the filter strategy.</p> Source code in <code>oteapi_optimade/models/strategies/filter.py</code> <pre><code>class OPTIMADEFilterSession(SessionUpdate):\n\"\"\"OPTIMADE session for the filter strategy.\"\"\"\n\n    optimade_config: Optional[OPTIMADEConfig] = Field(\n        None,\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n    optimade_response_object: Optional[Response] = Field(\n        None,\n        description=\"An OPTIMADE Python tools (OPT) pydantic response object.\",\n    )\n    optimade_response: Optional[Dict[str, Any]] = Field(\n        None,\n        description=\"An OPTIMADE response as a Python dictionary.\",\n    )\n\n    class Config:\n\"\"\"Pydantic configuration for `OPTIMADEFilterSession`.\"\"\"\n\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession.optimade_config","title":"<code>optimade_config: OPTIMADEConfig</code>  <code>pydantic-field</code>","text":"<p>OPTIMADE configuration. Contains relevant information necessary to perform OPTIMADE queries.</p>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession.optimade_response","title":"<code>optimade_response: Dict[str, Any]</code>  <code>pydantic-field</code>","text":"<p>An OPTIMADE response as a Python dictionary.</p>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession.optimade_response_object","title":"<code>optimade_response_object: Response</code>  <code>pydantic-field</code>","text":"<p>An OPTIMADE Python tools (OPT) pydantic response object.</p>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession.Config","title":"<code> Config        </code>","text":"<p>Pydantic configuration for <code>OPTIMADEFilterSession</code>.</p> Source code in <code>oteapi_optimade/models/strategies/filter.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for `OPTIMADEFilterSession`.\"\"\"\n\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/strategies/parse/","title":"parse","text":"<p>Models specific to the parse strategy.</p>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEDLiteParseConfig","title":"<code> OPTIMADEDLiteParseConfig            (OPTIMADEParseConfig)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE-specific parse strategy config.</p> Source code in <code>oteapi_optimade/models/strategies/parse.py</code> <pre><code>class OPTIMADEDLiteParseConfig(OPTIMADEParseConfig):\n\"\"\"OPTIMADE-specific parse strategy config.\"\"\"\n\n    mediaType: Literal[\n        \"application/vnd.optimade+dlite\",\n        \"application/vnd.OPTIMADE+dlite\",\n        \"application/vnd.OPTiMaDe+dlite\",\n        \"application/vnd.optimade+DLite\",\n        \"application/vnd.OPTIMADE+DLite\",\n        \"application/vnd.OPTiMaDe+DLite\",\n    ] = Field(  # type: ignore[assignment]\n        ...,\n        description=\"The registered strategy name for OPTIMADEDLiteParseStrategy.\",\n    )\n</code></pre>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseConfig","title":"<code> OPTIMADEParseConfig            (ResourceConfig)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE-specific parse strategy config.</p> Source code in <code>oteapi_optimade/models/strategies/parse.py</code> <pre><code>class OPTIMADEParseConfig(ResourceConfig):\n\"\"\"OPTIMADE-specific parse strategy config.\"\"\"\n\n    downloadUrl: OPTIMADEUrl = Field(\n        ...,\n        description=\"Either a base OPTIMADE URL or a full OPTIMADE URL.\",\n    )\n    mediaType: Literal[\n        \"application/vnd.optimade+json\",\n        \"application/vnd.OPTIMADE+json\",\n        \"application/vnd.OPTiMaDe+json\",\n        \"application/vnd.optimade+JSON\",\n        \"application/vnd.OPTIMADE+JSON\",\n        \"application/vnd.OPTiMaDe+JSON\",\n        \"application/vnd.optimade\",\n        \"application/vnd.OPTIMADE\",\n        \"application/vnd.OPTiMaDe\",\n    ] = Field(\n        ...,\n        description=\"The registered strategy name for OPTIMADEParseStrategy.\",\n    )\n    configuration: OPTIMADEConfig = Field(\n        OPTIMADEConfig(),\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession","title":"<code> OPTIMADEParseSession            (SessionUpdate)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE session for the parse strategy.</p> Source code in <code>oteapi_optimade/models/strategies/parse.py</code> <pre><code>class OPTIMADEParseSession(SessionUpdate):\n\"\"\"OPTIMADE session for the parse strategy.\"\"\"\n\n    optimade_config: Optional[OPTIMADEConfig] = Field(\n        None,\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n    optimade_response_object: Optional[Response] = Field(\n        None,\n        description=\"An OPTIMADE Python tools (OPT) pydantic response object.\",\n    )\n    optimade_response: Optional[Dict[str, Any]] = Field(\n        None,\n        description=\"An OPTIMADE response as a Python dictionary.\",\n    )\n\n    class Config:\n\"\"\"Pydantic configuration for `OPTIMADEParseSession`.\"\"\"\n\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession.optimade_config","title":"<code>optimade_config: OPTIMADEConfig</code>  <code>pydantic-field</code>","text":"<p>OPTIMADE configuration. Contains relevant information necessary to perform OPTIMADE queries.</p>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession.optimade_response","title":"<code>optimade_response: Dict[str, Any]</code>  <code>pydantic-field</code>","text":"<p>An OPTIMADE response as a Python dictionary.</p>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession.optimade_response_object","title":"<code>optimade_response_object: Response</code>  <code>pydantic-field</code>","text":"<p>An OPTIMADE Python tools (OPT) pydantic response object.</p>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession.Config","title":"<code> Config        </code>","text":"<p>Pydantic configuration for <code>OPTIMADEParseSession</code>.</p> Source code in <code>oteapi_optimade/models/strategies/parse.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for `OPTIMADEParseSession`.\"\"\"\n\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/strategies/resource/","title":"resource","text":"<p>Models specific to the resource strategy.</p>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceConfig","title":"<code> OPTIMADEResourceConfig            (ResourceConfig)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE-specific resource strategy config.</p> Source code in <code>oteapi_optimade/models/strategies/resource.py</code> <pre><code>class OPTIMADEResourceConfig(ResourceConfig):\n\"\"\"OPTIMADE-specific resource strategy config.\"\"\"\n\n    accessUrl: OPTIMADEUrl = Field(\n        ...,\n        description=\"Either a base OPTIMADE URL or a full OPTIMADE URL.\",\n    )\n    accessService: Literal[\n        \"optimade\",\n        \"OPTIMADE\",\n        \"OPTiMaDe\",\n        \"optimade+dlite\",\n        \"OPTIMADE+dlite\",\n        \"OPTiMaDe+dlite\",\n        \"optimade+DLite\",\n        \"OPTIMADE+DLite\",\n        \"OPTiMaDe+DLite\",\n    ] = Field(\n        ...,\n        description=\"The registered strategy name for OPTIMADEResourceStrategy.\",\n    )\n    configuration: OPTIMADEConfig = Field(\n        OPTIMADEConfig(),\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession","title":"<code> OPTIMADEResourceSession            (SessionUpdate)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE session for the resource strategy.</p> Source code in <code>oteapi_optimade/models/strategies/resource.py</code> <pre><code>class OPTIMADEResourceSession(SessionUpdate):\n\"\"\"OPTIMADE session for the resource strategy.\"\"\"\n\n    optimade_config: Optional[OPTIMADEConfig] = Field(\n        None,\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n    optimade_resources: List[Dict[str, Any]] = Field(\n        [],\n        description=(\n            \"List of OPTIMADE resources (structures, references, errors, ...) returned\"\n            \" from the OPTIMADE request.\"\n        ),\n    )\n    optimade_resource_model: str = Field(\n        \"\",\n        description=(\n            \"Importable path to the resource model to be used to parse the OPTIMADE \"\n            \"resources in `optimade_resource`. The importable path should be a fully \"\n            \"importable path to a module separated by a colon (`:`) to then define the \"\n            \"resource model class name. This means one can then do:\\n\\n```python\\n\"\n            \"from PACKAGE.MODULE import RESOURCE_CLS\\n```\\nFrom the value \"\n            \"`PACKAGE.MODULE:RESOURCE_CLS`\"\n        ),\n        regex=(\n            r\"^([a-zA-Z][a-zA-Z0-9_]*(\\.[a-zA-Z][a-zA-Z0-9_]*)*\"  # package.module\n            r\":[a-zA-Z][a-zA-Z0-9_]*)?$\"  # class\n        ),\n    )\n\n    class Config:\n\"\"\"Pydantic configuration for `OPTIMADEResourceSession`.\"\"\"\n\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession.optimade_config","title":"<code>optimade_config: OPTIMADEConfig</code>  <code>pydantic-field</code>","text":"<p>OPTIMADE configuration. Contains relevant information necessary to perform OPTIMADE queries.</p>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession.optimade_resource_model","title":"<code>optimade_resource_model: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Importable path to the resource model to be used to parse the OPTIMADE resources in <code>optimade_resource</code>. The importable path should be a fully importable path to a module separated by a colon (<code>:</code>) to then define the resource model class name. This means one can then do:</p> <p><pre><code>from PACKAGE.MODULE import RESOURCE_CLS\n</code></pre> From the value <code>PACKAGE.MODULE:RESOURCE_CLS</code></p>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession.optimade_resources","title":"<code>optimade_resources: List[Dict[str, Any]]</code>  <code>pydantic-field</code>","text":"<p>List of OPTIMADE resources (structures, references, errors, ...) returned from the OPTIMADE request.</p>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession.Config","title":"<code> Config        </code>","text":"<p>Pydantic configuration for <code>OPTIMADEResourceSession</code>.</p> Source code in <code>oteapi_optimade/models/strategies/resource.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for `OPTIMADEResourceSession`.\"\"\"\n\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/strategies/filter/","title":"filter","text":"<p>Demo filter strategy.</p>"},{"location":"api_reference/strategies/filter/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy","title":"<code> OPTIMADEFilterStrategy        </code>  <code>dataclass</code>","text":"<p>Filter Strategy.</p> <p>Implements strategies:</p> <ul> <li><code>(\"filterType\", \"OPTIMADE\")</code></li> <li><code>(\"filterType\", \"optimade\")</code></li> <li><code>(\"filterType\", \"OPTiMaDe\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>@dataclass\nclass OPTIMADEFilterStrategy:\n\"\"\"Filter Strategy.\n\n    **Implements strategies**:\n\n    - `(\"filterType\", \"OPTIMADE\")`\n    - `(\"filterType\", \"optimade\")`\n    - `(\"filterType\", \"OPTiMaDe\")`\n\n    \"\"\"\n\n    filter_config: OPTIMADEFilterConfig\n\n    def initialize(\n        self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n    ) -&gt; OPTIMADEFilterSession:\n\"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Configuration values, specifically URL query parameters, can be provided to the\n        OPTIMADE resource strategy through this filter strategy.\n\n        Workflow:\n\n        1. Compile received information.\n        2. Update session with compiled information.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEFilterSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEFilterSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEFilterSession()\n\n        if session.optimade_config:\n            self.filter_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        optimade_config = self.filter_config.configuration.copy()\n\n        if not optimade_config.query_parameters:\n            optimade_config.query_parameters = OPTIMADEQueryParameters()\n\n        if self.filter_config.query:\n            LOGGER.debug(\"Setting filter from query.\")\n            optimade_config.query_parameters.filter = self.filter_config.query\n\n        if self.filter_config.limit:\n            LOGGER.debug(\"Setting page_limit from limit.\")\n            optimade_config.query_parameters.page_limit = self.filter_config.limit\n\n        return session.copy(\n            update={\n                \"optimade_config\": optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            },\n        )\n\n    def get(  # pylint: disable=unused-argument\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; SessionUpdate:\n\"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n        return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/filter/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>def get(  # pylint: disable=unused-argument\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; SessionUpdate:\n\"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/filter/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy.</p> <p>Workflow:</p> <ol> <li>Compile received information.</li> <li>Update session with compiled information.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Union[SessionUpdate, Dict[str, Any]]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEFilterSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>def initialize(\n    self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n) -&gt; OPTIMADEFilterSession:\n\"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Configuration values, specifically URL query parameters, can be provided to the\n    OPTIMADE resource strategy through this filter strategy.\n\n    Workflow:\n\n    1. Compile received information.\n    2. Update session with compiled information.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEFilterSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEFilterSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEFilterSession()\n\n    if session.optimade_config:\n        self.filter_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    optimade_config = self.filter_config.configuration.copy()\n\n    if not optimade_config.query_parameters:\n        optimade_config.query_parameters = OPTIMADEQueryParameters()\n\n    if self.filter_config.query:\n        LOGGER.debug(\"Setting filter from query.\")\n        optimade_config.query_parameters.filter = self.filter_config.query\n\n    if self.filter_config.limit:\n        LOGGER.debug(\"Setting page_limit from limit.\")\n        optimade_config.query_parameters.page_limit = self.filter_config.limit\n\n    return session.copy(\n        update={\n            \"optimade_config\": optimade_config.copy(\n                update={\n                    \"query_parameters\": model2dict(\n                        optimade_config.query_parameters,\n                        exclude_defaults=True,\n                        exclude_unset=True,\n                    )\n                }\n            )\n        },\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/","title":"parse","text":"<p>Demo strategy class for text/json.</p>"},{"location":"api_reference/strategies/parse/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy","title":"<code> OPTIMADEParseStrategy        </code>  <code>dataclass</code>","text":"<p>Parse strategy for JSON.</p> <p>Implements strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.optimade+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.optimade+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.optimade\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>@dataclass\nclass OPTIMADEParseStrategy:\n\"\"\"Parse strategy for JSON.\n\n    **Implements strategies**:\n\n    - `(\"mediaType\", \"application/vnd.optimade+json\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE+json\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe+json\")`\n    - `(\"mediaType\", \"application/vnd.optimade+JSON\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")`\n    - `(\"mediaType\", \"application/vnd.optimade\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe\")`\n\n    \"\"\"\n\n    parse_config: OPTIMADEParseConfig\n\n    def initialize(  # pylint: disable=unused-argument\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        return SessionUpdate()\n\n    def get(  # pylint: disable=too-many-branches\n        self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n    ) -&gt; OPTIMADEParseSession:\n\"\"\"Request and parse an OPTIMADE response using OPT.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Configuration values provided in `resource_config.configuration` take\n        precedence over the derived values from `downloadUrl`.\n\n        Workflow:\n\n        1. Request OPTIMADE response.\n        2. Parse as an OPTIMADE Python tools (OPT) pydantic response model.\n\n        Parameters:\n            session: A session-specific dictionary-like context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEParseSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEParseSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEParseSession()\n\n        if session.optimade_config:\n            self.parse_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        if self.parse_config.downloadUrl in cache:\n            response: \"Dict[str, Any]\" = cache.get(self.parse_config.downloadUrl)\n        elif (\n            self.parse_config.configuration.datacache_config.accessKey\n            and self.parse_config.configuration.datacache_config.accessKey in cache\n        ):\n            response = cache.get(\n                self.parse_config.configuration.datacache_config.accessKey\n            )\n        else:\n            download_config = self.parse_config.copy()\n            session.update(\n                create_strategy(StrategyType.DOWNLOAD, download_config).initialize(\n                    model2dict(session, exclude_defaults=True, exclude_unset=True)\n                )\n            )\n            session.update(\n                create_strategy(StrategyType.DOWNLOAD, download_config).get(\n                    model2dict(session, exclude_defaults=True, exclude_unset=True)\n                )\n            )\n\n            response = {\"json\": json.loads(cache.get(session.pop(\"key\")))}\n\n        if (\n            not response.get(\"ok\", True)\n            or (\n                200 &gt; response.get(\"status_code\", 200)\n                or response.get(\"status_code\", 200) &gt;= 300\n            )\n            or \"errors\" in response.get(\"json\", {})\n        ):\n            # Error response\n            try:\n                response_object = ErrorResponse(**response.get(\"json\", {}))\n            except ValidationError as exc:\n                LOGGER.error(\n                    \"Could not validate an error response.\\nValidationError: \"\n                    \"%s\\nresponse=%r\",\n                    exc,\n                    response,\n                )\n                raise OPTIMADEParseError(\n                    \"Could not validate an error response.\"\n                ) from exc\n        else:\n            # Successful response\n            response_model = self.parse_config.downloadUrl.response_model()\n            if response_model:\n                if not isinstance(response_model, tuple):\n                    response_model = (response_model,)\n                for model_cls in response_model:\n                    try:\n                        response_object = model_cls(**response.get(\"json\", {}))\n                    except ValidationError:\n                        pass\n                    else:\n                        break\n                else:\n                    LOGGER.error(\n                        \"Could not validate for an expected response model.\\nURL=%r\\n\"\n                        \"response_models=%r\\nresponse=%s\",\n                        self.parse_config.downloadUrl,\n                        response_model,\n                        response,\n                    )\n                    raise OPTIMADEParseError(\n                        \"Could not validate for an expected response model.\"\n                    )\n            else:\n                # No \"endpoint\" or unknown\n                try:\n                    response_object = Success(**response.get(\"json\", {}))\n                except ValidationError as exc:\n                    LOGGER.error(\n                        \"Unknown or unparseable endpoint.\\nValidatonError: %s\\n\"\n                        \"URL=%r\\nendpoint=%r\\nresponse_model=%r\\nresponse=%s\",\n                        exc,\n                        self.parse_config.downloadUrl,\n                        self.parse_config.downloadUrl.endpoint,\n                        response_model,\n                        response,\n                    )\n                    raise OPTIMADEParseError(\n                        \"Unknown or unparseable endpoint.\"\n                    ) from exc\n\n        if self.parse_config.configuration.return_object:\n            session.optimade_response_object = response_object\n        else:\n            session.optimade_response = model2dict(response_object)\n\n        if session.optimade_config and session.optimade_config.query_parameters:\n            session = session.copy(\n                update={\n                    \"optimade_config\": session.optimade_config.copy(\n                        update={\n                            \"query_parameters\": model2dict(\n                                session.optimade_config.query_parameters,\n                                exclude_defaults=True,\n                                exclude_unset=True,\n                            )\n                        }\n                    )\n                }\n            )\n\n        return session\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Request and parse an OPTIMADE response using OPT.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Configuration values provided in <code>resource_config.configuration</code> take precedence over the derived values from <code>downloadUrl</code>.</p> <p>Workflow:</p> <ol> <li>Request OPTIMADE response.</li> <li>Parse as an OPTIMADE Python tools (OPT) pydantic response model.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Union[SessionUpdate, Dict[str, Any]]]</code> <p>A session-specific dictionary-like context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEParseSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>def get(  # pylint: disable=too-many-branches\n    self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n) -&gt; OPTIMADEParseSession:\n\"\"\"Request and parse an OPTIMADE response using OPT.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Configuration values provided in `resource_config.configuration` take\n    precedence over the derived values from `downloadUrl`.\n\n    Workflow:\n\n    1. Request OPTIMADE response.\n    2. Parse as an OPTIMADE Python tools (OPT) pydantic response model.\n\n    Parameters:\n        session: A session-specific dictionary-like context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEParseSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEParseSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEParseSession()\n\n    if session.optimade_config:\n        self.parse_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    if self.parse_config.downloadUrl in cache:\n        response: \"Dict[str, Any]\" = cache.get(self.parse_config.downloadUrl)\n    elif (\n        self.parse_config.configuration.datacache_config.accessKey\n        and self.parse_config.configuration.datacache_config.accessKey in cache\n    ):\n        response = cache.get(\n            self.parse_config.configuration.datacache_config.accessKey\n        )\n    else:\n        download_config = self.parse_config.copy()\n        session.update(\n            create_strategy(StrategyType.DOWNLOAD, download_config).initialize(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n        session.update(\n            create_strategy(StrategyType.DOWNLOAD, download_config).get(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n\n        response = {\"json\": json.loads(cache.get(session.pop(\"key\")))}\n\n    if (\n        not response.get(\"ok\", True)\n        or (\n            200 &gt; response.get(\"status_code\", 200)\n            or response.get(\"status_code\", 200) &gt;= 300\n        )\n        or \"errors\" in response.get(\"json\", {})\n    ):\n        # Error response\n        try:\n            response_object = ErrorResponse(**response.get(\"json\", {}))\n        except ValidationError as exc:\n            LOGGER.error(\n                \"Could not validate an error response.\\nValidationError: \"\n                \"%s\\nresponse=%r\",\n                exc,\n                response,\n            )\n            raise OPTIMADEParseError(\n                \"Could not validate an error response.\"\n            ) from exc\n    else:\n        # Successful response\n        response_model = self.parse_config.downloadUrl.response_model()\n        if response_model:\n            if not isinstance(response_model, tuple):\n                response_model = (response_model,)\n            for model_cls in response_model:\n                try:\n                    response_object = model_cls(**response.get(\"json\", {}))\n                except ValidationError:\n                    pass\n                else:\n                    break\n            else:\n                LOGGER.error(\n                    \"Could not validate for an expected response model.\\nURL=%r\\n\"\n                    \"response_models=%r\\nresponse=%s\",\n                    self.parse_config.downloadUrl,\n                    response_model,\n                    response,\n                )\n                raise OPTIMADEParseError(\n                    \"Could not validate for an expected response model.\"\n                )\n        else:\n            # No \"endpoint\" or unknown\n            try:\n                response_object = Success(**response.get(\"json\", {}))\n            except ValidationError as exc:\n                LOGGER.error(\n                    \"Unknown or unparseable endpoint.\\nValidatonError: %s\\n\"\n                    \"URL=%r\\nendpoint=%r\\nresponse_model=%r\\nresponse=%s\",\n                    exc,\n                    self.parse_config.downloadUrl,\n                    self.parse_config.downloadUrl.endpoint,\n                    response_model,\n                    response,\n                )\n                raise OPTIMADEParseError(\n                    \"Unknown or unparseable endpoint.\"\n                ) from exc\n\n    if self.parse_config.configuration.return_object:\n        session.optimade_response_object = response_object\n    else:\n        session.optimade_response = model2dict(response_object)\n\n    if session.optimade_config and session.optimade_config.query_parameters:\n        session = session.copy(\n            update={\n                \"optimade_config\": session.optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            session.optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            }\n        )\n\n    return session\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>def initialize(  # pylint: disable=unused-argument\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/resource/","title":"resource","text":"<p>OPTIMADE resource strategy.</p>"},{"location":"api_reference/strategies/resource/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy","title":"<code> OPTIMADEResourceStrategy        </code>  <code>dataclass</code>","text":"<p>OPTIMADE Resource Strategy.</p> <p>Implements strategies:</p> <ul> <li><code>(\"accessService\", \"optimade\")</code></li> <li><code>(\"accessService\", \"OPTIMADE\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe\")</code></li> <li><code>(\"accessService\", \"optimade+dlite\")</code></li> <li><code>(\"accessService\", \"OPTIMADE+dlite\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe+dlite\")</code></li> <li><code>(\"accessService\", \"optimade+DLite\")</code></li> <li><code>(\"accessService\", \"OPTIMADE+DLite\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe+DLite\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>@dataclass\nclass OPTIMADEResourceStrategy:\n\"\"\"OPTIMADE Resource Strategy.\n\n    **Implements strategies**:\n\n    - `(\"accessService\", \"optimade\")`\n    - `(\"accessService\", \"OPTIMADE\")`\n    - `(\"accessService\", \"OPTiMaDe\")`\n    - `(\"accessService\", \"optimade+dlite\")`\n    - `(\"accessService\", \"OPTIMADE+dlite\")`\n    - `(\"accessService\", \"OPTiMaDe+dlite\")`\n    - `(\"accessService\", \"optimade+DLite\")`\n    - `(\"accessService\", \"OPTIMADE+DLite\")`\n    - `(\"accessService\", \"OPTiMaDe+DLite\")`\n\n    \"\"\"\n\n    resource_config: OPTIMADEResourceConfig\n\n    def initialize(  # pylint: disable=unused-argument\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; \"Union[SessionUpdate, DLiteSessionUpdate]\":\n\"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if use_dlite(\n            self.resource_config.accessService,\n            self.resource_config.configuration.use_dlite,\n        ):\n            return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n        return SessionUpdate()\n\n    def get(  # pylint: disable=too-many-branches,too-many-statements\n        self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n    ) -&gt; OPTIMADEResourceSession:\n\"\"\"Execute an OPTIMADE query to `accessUrl`.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Configuration values provided in `resource_config.configuration` take\n        precedence over the derived values from `accessUrl`.\n\n        Workflow:\n        1. Update configuration according to session.\n        2. Deconstruct `accessUrl` (done partly by\n           `oteapi_optimade.models.custom_types.OPTIMADEUrl`).\n        3. Reconstruct the complete query URL.\n        4. Send query.\n        5. Store result in data cache.\n\n        Parameters:\n            session: A session-specific dictionary-like context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEResourceSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEResourceSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEResourceSession()\n\n        if session.optimade_config:\n            self.resource_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        optimade_endpoint = self.resource_config.accessUrl.endpoint or \"structures\"\n        optimade_query = (\n            self.resource_config.configuration.query_parameters\n            or OPTIMADEQueryParameters()\n        )\n        LOGGER.debug(\"resource_config: %r\", self.resource_config)\n\n        if self.resource_config.accessUrl.query:\n            parsed_query = parse_qs(self.resource_config.accessUrl.query)\n            for field, value in parsed_query.items():\n                # Only use the latest defined value for any parameter\n                if field not in optimade_query.__fields_set__:\n                    LOGGER.debug(\n                        \"Setting %r from accessUrl (value=%r)\", field, value[-1]\n                    )\n                    setattr(optimade_query, field, value[-1])\n\n        LOGGER.debug(\"optimade_query after update: %r\", optimade_query)\n\n        optimade_url = OPTIMADEUrl(\n            f\"{self.resource_config.accessUrl.base_url}\"\n            f\"/{self.resource_config.accessUrl.version or 'v1'}\"\n            f\"/{optimade_endpoint}?{optimade_query.generate_query_string()}\"\n        )\n        LOGGER.debug(\"OPTIMADE URL to be requested: %s\", optimade_url)\n\n        # Set cache access key to the full OPTIMADE URL.\n        self.resource_config.configuration.datacache_config.accessKey = optimade_url\n\n        # Perform query\n        response = requests.get(\n            optimade_url,\n            allow_redirects=True,\n            timeout=(3, 27),  # timeout in seconds (connect, read)\n        )\n\n        if optimade_query.response_format and optimade_query.response_format != \"json\":\n            raise NotImplementedError(\n                \"Can only handle JSON responses for now. Requested response format: \"\n                f\"{optimade_query.response_format!r}\"\n            )\n\n        cache = DataCache(config=self.resource_config.configuration.datacache_config)\n        cache.add(\n            {\n                \"status_code\": response.status_code,\n                \"ok\": response.ok,\n                \"json\": response.json(),\n            }\n        )\n\n        parse_with_dlite = use_dlite(\n            self.resource_config.accessService,\n            self.resource_config.configuration.use_dlite,\n        )\n\n        parse_mediaType = f\"application/vnd.{self.resource_config.accessService.split('+', maxsplit=1)[0]}\"  # pylint: disable=invalid-name,line-too-long\n        if parse_with_dlite:\n            parse_mediaType += \"+DLite\"  # pylint: disable=invalid-name\n        elif optimade_query.response_format:\n            parse_mediaType += (  # pylint: disable=invalid-name\n                f\"+{optimade_query.response_format}\"\n            )\n\n        parse_config = {\n            \"downloadUrl\": optimade_url,\n            \"mediaType\": parse_mediaType,\n            \"configuration\": {\n                \"datacache_config\": self.resource_config.configuration.datacache_config,\n                \"return_object\": True,\n            },\n        }\n\n        session.update(\n            create_strategy(StrategyType.PARSE, parse_config).initialize(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n        session.update(\n            create_strategy(StrategyType.PARSE, parse_config).get(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n\n        if \"optimade_response_object\" not in session:\n            raise ValueError(\n                \"'optimade_response_object' was expected to be present in the session.\"\n            )\n        optimade_response: \"OPTIMADEResponse\" = session.pop(\"optimade_response_object\")\n        if \"optimade_response\" in session and not session.get(\"optimade_response\"):\n            del session[\"optimade_response\"]\n\n        if isinstance(optimade_response, ErrorResponse):\n            optimade_resources = optimade_response.errors\n            session.optimade_resource_model = (\n                f\"{OptimadeError.__module__}:OptimadeError\"\n            )\n        elif isinstance(optimade_response, ReferenceResponseMany):\n            optimade_resources = [\n                Reference(entry).as_dict\n                if isinstance(entry, dict)\n                else Reference(entry.dict()).as_dict\n                for entry in optimade_response.data\n            ]\n            session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n        elif isinstance(optimade_response, ReferenceResponseOne):\n            optimade_resources = [\n                Reference(optimade_response.data).as_dict\n                if isinstance(optimade_response.data, dict)\n                else Reference(optimade_response.data.dict()).as_dict\n            ]\n            session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n        elif isinstance(optimade_response, StructureResponseMany):\n            optimade_resources = [\n                Structure(entry).as_dict\n                if isinstance(entry, dict)\n                else Structure(entry.dict()).as_dict\n                for entry in optimade_response.data\n            ]\n            session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n        elif isinstance(optimade_response, StructureResponseOne):\n            optimade_resources = [\n                Structure(optimade_response.data).as_dict\n                if isinstance(optimade_response.data, dict)\n                else Structure(optimade_response.data.dict()).as_dict\n            ]\n            session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n        else:\n            LOGGER.debug(\n                \"Could not parse response as errors, references or structures. \"\n                \"Response:\\n%r\",\n                optimade_response,\n            )\n            raise OPTIMADEParseError(\n                \"Could not retrieve errors, references or structures from response \"\n                f\"from {optimade_url}. It could be a valid OPTIMADE API response, \"\n                \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \"\n                \"invalid response completely.\"\n            )\n\n        session.optimade_resources = [\n            model2dict(resource) for resource in optimade_resources\n        ]\n\n        if session.optimade_config and session.optimade_config.query_parameters:\n            session = session.copy(\n                update={\n                    \"optimade_config\": session.optimade_config.copy(\n                        update={\n                            \"query_parameters\": model2dict(\n                                session.optimade_config.query_parameters,\n                                exclude_defaults=True,\n                                exclude_unset=True,\n                            )\n                        }\n                    )\n                }\n            )\n\n        return session\n</code></pre>"},{"location":"api_reference/strategies/resource/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Execute an OPTIMADE query to <code>accessUrl</code>.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Configuration values provided in <code>resource_config.configuration</code> take precedence over the derived values from <code>accessUrl</code>.</p> <p>Workflow: 1. Update configuration according to session. 2. Deconstruct <code>accessUrl</code> (done partly by    <code>oteapi_optimade.models.custom_types.OPTIMADEUrl</code>). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Union[SessionUpdate, Dict[str, Any]]]</code> <p>A session-specific dictionary-like context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEResourceSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def get(  # pylint: disable=too-many-branches,too-many-statements\n    self, session: \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None\n) -&gt; OPTIMADEResourceSession:\n\"\"\"Execute an OPTIMADE query to `accessUrl`.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Configuration values provided in `resource_config.configuration` take\n    precedence over the derived values from `accessUrl`.\n\n    Workflow:\n    1. Update configuration according to session.\n    2. Deconstruct `accessUrl` (done partly by\n       `oteapi_optimade.models.custom_types.OPTIMADEUrl`).\n    3. Reconstruct the complete query URL.\n    4. Send query.\n    5. Store result in data cache.\n\n    Parameters:\n        session: A session-specific dictionary-like context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEResourceSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEResourceSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEResourceSession()\n\n    if session.optimade_config:\n        self.resource_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    optimade_endpoint = self.resource_config.accessUrl.endpoint or \"structures\"\n    optimade_query = (\n        self.resource_config.configuration.query_parameters\n        or OPTIMADEQueryParameters()\n    )\n    LOGGER.debug(\"resource_config: %r\", self.resource_config)\n\n    if self.resource_config.accessUrl.query:\n        parsed_query = parse_qs(self.resource_config.accessUrl.query)\n        for field, value in parsed_query.items():\n            # Only use the latest defined value for any parameter\n            if field not in optimade_query.__fields_set__:\n                LOGGER.debug(\n                    \"Setting %r from accessUrl (value=%r)\", field, value[-1]\n                )\n                setattr(optimade_query, field, value[-1])\n\n    LOGGER.debug(\"optimade_query after update: %r\", optimade_query)\n\n    optimade_url = OPTIMADEUrl(\n        f\"{self.resource_config.accessUrl.base_url}\"\n        f\"/{self.resource_config.accessUrl.version or 'v1'}\"\n        f\"/{optimade_endpoint}?{optimade_query.generate_query_string()}\"\n    )\n    LOGGER.debug(\"OPTIMADE URL to be requested: %s\", optimade_url)\n\n    # Set cache access key to the full OPTIMADE URL.\n    self.resource_config.configuration.datacache_config.accessKey = optimade_url\n\n    # Perform query\n    response = requests.get(\n        optimade_url,\n        allow_redirects=True,\n        timeout=(3, 27),  # timeout in seconds (connect, read)\n    )\n\n    if optimade_query.response_format and optimade_query.response_format != \"json\":\n        raise NotImplementedError(\n            \"Can only handle JSON responses for now. Requested response format: \"\n            f\"{optimade_query.response_format!r}\"\n        )\n\n    cache = DataCache(config=self.resource_config.configuration.datacache_config)\n    cache.add(\n        {\n            \"status_code\": response.status_code,\n            \"ok\": response.ok,\n            \"json\": response.json(),\n        }\n    )\n\n    parse_with_dlite = use_dlite(\n        self.resource_config.accessService,\n        self.resource_config.configuration.use_dlite,\n    )\n\n    parse_mediaType = f\"application/vnd.{self.resource_config.accessService.split('+', maxsplit=1)[0]}\"  # pylint: disable=invalid-name,line-too-long\n    if parse_with_dlite:\n        parse_mediaType += \"+DLite\"  # pylint: disable=invalid-name\n    elif optimade_query.response_format:\n        parse_mediaType += (  # pylint: disable=invalid-name\n            f\"+{optimade_query.response_format}\"\n        )\n\n    parse_config = {\n        \"downloadUrl\": optimade_url,\n        \"mediaType\": parse_mediaType,\n        \"configuration\": {\n            \"datacache_config\": self.resource_config.configuration.datacache_config,\n            \"return_object\": True,\n        },\n    }\n\n    session.update(\n        create_strategy(StrategyType.PARSE, parse_config).initialize(\n            model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    )\n    session.update(\n        create_strategy(StrategyType.PARSE, parse_config).get(\n            model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    )\n\n    if \"optimade_response_object\" not in session:\n        raise ValueError(\n            \"'optimade_response_object' was expected to be present in the session.\"\n        )\n    optimade_response: \"OPTIMADEResponse\" = session.pop(\"optimade_response_object\")\n    if \"optimade_response\" in session and not session.get(\"optimade_response\"):\n        del session[\"optimade_response\"]\n\n    if isinstance(optimade_response, ErrorResponse):\n        optimade_resources = optimade_response.errors\n        session.optimade_resource_model = (\n            f\"{OptimadeError.__module__}:OptimadeError\"\n        )\n    elif isinstance(optimade_response, ReferenceResponseMany):\n        optimade_resources = [\n            Reference(entry).as_dict\n            if isinstance(entry, dict)\n            else Reference(entry.dict()).as_dict\n            for entry in optimade_response.data\n        ]\n        session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n    elif isinstance(optimade_response, ReferenceResponseOne):\n        optimade_resources = [\n            Reference(optimade_response.data).as_dict\n            if isinstance(optimade_response.data, dict)\n            else Reference(optimade_response.data.dict()).as_dict\n        ]\n        session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n    elif isinstance(optimade_response, StructureResponseMany):\n        optimade_resources = [\n            Structure(entry).as_dict\n            if isinstance(entry, dict)\n            else Structure(entry.dict()).as_dict\n            for entry in optimade_response.data\n        ]\n        session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n    elif isinstance(optimade_response, StructureResponseOne):\n        optimade_resources = [\n            Structure(optimade_response.data).as_dict\n            if isinstance(optimade_response.data, dict)\n            else Structure(optimade_response.data.dict()).as_dict\n        ]\n        session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n    else:\n        LOGGER.debug(\n            \"Could not parse response as errors, references or structures. \"\n            \"Response:\\n%r\",\n            optimade_response,\n        )\n        raise OPTIMADEParseError(\n            \"Could not retrieve errors, references or structures from response \"\n            f\"from {optimade_url}. It could be a valid OPTIMADE API response, \"\n            \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \"\n            \"invalid response completely.\"\n        )\n\n    session.optimade_resources = [\n        model2dict(resource) for resource in optimade_resources\n    ]\n\n    if session.optimade_config and session.optimade_config.query_parameters:\n        session = session.copy(\n            update={\n                \"optimade_config\": session.optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            session.optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            }\n        )\n\n    return session\n</code></pre>"},{"location":"api_reference/strategies/resource/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[SessionUpdate, DLiteSessionUpdate]</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def initialize(  # pylint: disable=unused-argument\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; \"Union[SessionUpdate, DLiteSessionUpdate]\":\n\"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if use_dlite(\n        self.resource_config.accessService,\n        self.resource_config.configuration.use_dlite,\n    ):\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/resource/#oteapi_optimade.strategies.resource.use_dlite","title":"<code>use_dlite(access_service, use_dlite_flag)</code>","text":"<p>Determine whether DLite should be utilized in the Resource strategy.</p> <p>Parameters:</p> Name Type Description Default <code>access_service</code> <code>str</code> <p>The accessService value from the resource's configuration.</p> required <code>use_dlite_flag</code> <code>bool</code> <p>The strategy-specific <code>use_dlite</code> configuration option.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Based on the accessService value, then whether DLite should be used or not.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def use_dlite(access_service: str, use_dlite_flag: bool) -&gt; bool:\n\"\"\"Determine whether DLite should be utilized in the Resource strategy.\n\n    Parameters:\n        access_service: The accessService value from the resource's configuration.\n        use_dlite_flag: The strategy-specific `use_dlite` configuration option.\n\n    Returns:\n        Based on the accessService value, then whether DLite should be used or not.\n\n    \"\"\"\n    if (\n        any(dlite_form in access_service for dlite_form in [\"DLite\", \"dlite\"])\n        or use_dlite_flag\n    ):\n        if oteapi_dlite_version is None:\n            raise MissingDependency(\n                \"OTEAPI-DLite is not found on the system. This is required to use \"\n                \"DLite with the OTEAPI-OPTIMADE strategies.\"\n            )\n        return True\n    return False\n</code></pre>"}]}