{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OTE-API OPTIMADE \u00b6 An OTE-API Plugin with OTE strategies. Further reading: OTE-API Core Documentation OTE-API Services Documentation License and copyright \u00b6 OTE-API OPTIMADE is released under the MIT license with copyright \u00a9 SINTEF. Acknowledgment \u00b6 OTE-API OPTIMADE has been created via the cookiecutter template for OTE-API plugins . OTE-API OPTIMADE has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136. VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903. OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.","title":"Home"},{"location":"#ote-api-optimade","text":"An OTE-API Plugin with OTE strategies. Further reading: OTE-API Core Documentation OTE-API Services Documentation","title":"OTE-API OPTIMADE"},{"location":"#license-and-copyright","text":"OTE-API OPTIMADE is released under the MIT license with copyright \u00a9 SINTEF.","title":"License and copyright"},{"location":"#acknowledgment","text":"OTE-API OPTIMADE has been created via the cookiecutter template for OTE-API plugins . OTE-API OPTIMADE has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136. VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903. OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.","title":"Acknowledgment"},{"location":"CHANGELOG/","text":"Changelog \u00b6 This file will hold an auto-generated changelog for you project.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"This file will hold an auto-generated changelog for you project.","title":"Changelog"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2022 SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"all_strategies/","text":"OTE-API OPTIMADE Strategies \u00b6 This page provides documentation for the oteapi_optimade.strategies submodule, where all the OTE-API OPTIMADE strategies are located. These strategies will be available when setting up a server in an environment with oteapi-optimade installed. filter \u00b6 Demo filter strategy. OPTIMADEFilterStrategy \u00b6 Filter Strategy. Implements strategies : (\"filterType\", \"OPTIMADE\") (\"filterType\", \"optimade\") (\"filterType\", \"OPTiMaDe\") Source code in oteapi_optimade/strategies/filter.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 @dataclass class OPTIMADEFilterStrategy : \"\"\"Filter Strategy. **Implements strategies**: - `(\"filterType\", \"OPTIMADE\")` - `(\"filterType\", \"optimade\")` - `(\"filterType\", \"OPTiMaDe\")` \"\"\" filter_config : OPTIMADEFilterConfig def initialize ( self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEFilterSession : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEFilterSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEFilterSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEFilterSession () if session . optimade_config : self . filter_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_config = self . filter_config . configuration . copy () if not optimade_config . query_parameters : optimade_config . query_parameters = OPTIMADEQueryParameters () if self . filter_config . query : LOGGER . debug ( \"Setting filter from query.\" ) optimade_config . query_parameters . filter = self . filter_config . query if self . filter_config . limit : LOGGER . debug ( \"Setting page_limit from limit.\" ) optimade_config . query_parameters . page_limit = self . filter_config . limit return session . copy ( update = { \"optimade_config\" : optimade_config . copy ( update = { \"query_parameters\" : model2dict ( optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) }, ) def get ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () get ( session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the SessionUpdate session-specific context from services. Source code in oteapi_optimade/strategies/filter.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () initialize ( session = None ) \u00b6 Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary context. None Returns: Type Description OPTIMADEFilterSession An update model of key/value-pairs to be stored in the OPTIMADEFilterSession session-specific context from services. Source code in oteapi_optimade/strategies/filter.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def initialize ( self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEFilterSession : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEFilterSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEFilterSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEFilterSession () if session . optimade_config : self . filter_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_config = self . filter_config . configuration . copy () if not optimade_config . query_parameters : optimade_config . query_parameters = OPTIMADEQueryParameters () if self . filter_config . query : LOGGER . debug ( \"Setting filter from query.\" ) optimade_config . query_parameters . filter = self . filter_config . query if self . filter_config . limit : LOGGER . debug ( \"Setting page_limit from limit.\" ) optimade_config . query_parameters . page_limit = self . filter_config . limit return session . copy ( update = { \"optimade_config\" : optimade_config . copy ( update = { \"query_parameters\" : model2dict ( optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) }, ) parse \u00b6 Demo strategy class for text/json. OPTIMADEParseStrategy \u00b6 Parse strategy for JSON. Implements strategies : (\"mediaType\", \"application/vnd.optimade+json\") (\"mediaType\", \"application/vnd.OPTIMADE+json\") (\"mediaType\", \"application/vnd.OPTiMaDe+json\") (\"mediaType\", \"application/vnd.optimade+JSON\") (\"mediaType\", \"application/vnd.OPTIMADE+JSON\") (\"mediaType\", \"application/vnd.OPTiMaDe+JSON\") (\"mediaType\", \"application/vnd.optimade\") (\"mediaType\", \"application/vnd.OPTIMADE\") (\"mediaType\", \"application/vnd.OPTiMaDe\") Source code in oteapi_optimade/strategies/parse.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 @dataclass class OPTIMADEParseStrategy : \"\"\"Parse strategy for JSON. **Implements strategies**: - `(\"mediaType\", \"application/vnd.optimade+json\")` - `(\"mediaType\", \"application/vnd.OPTIMADE+json\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe+json\")` - `(\"mediaType\", \"application/vnd.optimade+JSON\")` - `(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")` - `(\"mediaType\", \"application/vnd.optimade\")` - `(\"mediaType\", \"application/vnd.OPTIMADE\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe\")` \"\"\" parse_config : OPTIMADEParseConfig def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () def get ( # pylint: disable=too-many-branches self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEParseSession : \"\"\"Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `downloadUrl`. Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEParseSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEParseSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEParseSession () if session . optimade_config : self . parse_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) cache = DataCache ( self . parse_config . configuration . datacache_config ) if self . parse_config . downloadUrl in cache : response : \"Dict[str, Any]\" = cache . get ( self . parse_config . downloadUrl ) elif ( self . parse_config . configuration . datacache_config . accessKey and self . parse_config . configuration . datacache_config . accessKey in cache ): response = cache . get ( self . parse_config . configuration . datacache_config . accessKey ) else : download_config = self . parse_config . copy () session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) response = { \"json\" : json . loads ( cache . get ( session . pop ( \"key\" )))} if ( not response . get ( \"ok\" , True ) or ( 200 > response . get ( \"status_code\" , 200 ) or response . get ( \"status_code\" , 200 ) >= 300 ) or \"errors\" in response . get ( \"json\" , {}) ): # Error response try : response_object = ErrorResponse ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Could not validate an error response. \\n ValidationError: \" \" %s \\n response= %r \" , exc , response , ) raise OPTIMADEParseError ( \"Could not validate an error response.\" ) from exc else : # Successful response response_model = self . parse_config . downloadUrl . response_model () if response_model : if not isinstance ( response_model , tuple ): response_model = ( response_model ,) for model_cls in response_model : try : response_object = model_cls ( ** response . get ( \"json\" , {})) except ValidationError : pass else : break else : LOGGER . error ( \"Could not validate for an expected response model. \\n URL= %r \\n \" \"response_models= %r \\n response= %s \" , self . parse_config . downloadUrl , response_model , response , ) raise OPTIMADEParseError ( \"Could not validate for an expected response model.\" ) else : # No \"endpoint\" or unknown try : response_object = Success ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Unknown or unparseable endpoint. \\n ValidatonError: %s \\n \" \"URL= %r \\n endpoint= %r \\n response_model= %r \\n response= %s \" , exc , self . parse_config . downloadUrl , self . parse_config . downloadUrl . endpoint , response_model , response , ) raise OPTIMADEParseError ( \"Unknown or unparseable endpoint.\" ) from exc if self . parse_config . configuration . return_object : session . optimade_response_object = response_object else : session . optimade_response = model2dict ( response_object ) if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session get ( session = None ) \u00b6 Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in resource_config.configuration take precedence over the derived values from downloadUrl . Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary-like context. None Returns: Type Description OPTIMADEParseSession An update model of key/value-pairs to be stored in the session-specific OPTIMADEParseSession context from services. Source code in oteapi_optimade/strategies/parse.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def get ( # pylint: disable=too-many-branches self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEParseSession : \"\"\"Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `downloadUrl`. Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEParseSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEParseSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEParseSession () if session . optimade_config : self . parse_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) cache = DataCache ( self . parse_config . configuration . datacache_config ) if self . parse_config . downloadUrl in cache : response : \"Dict[str, Any]\" = cache . get ( self . parse_config . downloadUrl ) elif ( self . parse_config . configuration . datacache_config . accessKey and self . parse_config . configuration . datacache_config . accessKey in cache ): response = cache . get ( self . parse_config . configuration . datacache_config . accessKey ) else : download_config = self . parse_config . copy () session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) response = { \"json\" : json . loads ( cache . get ( session . pop ( \"key\" )))} if ( not response . get ( \"ok\" , True ) or ( 200 > response . get ( \"status_code\" , 200 ) or response . get ( \"status_code\" , 200 ) >= 300 ) or \"errors\" in response . get ( \"json\" , {}) ): # Error response try : response_object = ErrorResponse ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Could not validate an error response. \\n ValidationError: \" \" %s \\n response= %r \" , exc , response , ) raise OPTIMADEParseError ( \"Could not validate an error response.\" ) from exc else : # Successful response response_model = self . parse_config . downloadUrl . response_model () if response_model : if not isinstance ( response_model , tuple ): response_model = ( response_model ,) for model_cls in response_model : try : response_object = model_cls ( ** response . get ( \"json\" , {})) except ValidationError : pass else : break else : LOGGER . error ( \"Could not validate for an expected response model. \\n URL= %r \\n \" \"response_models= %r \\n response= %s \" , self . parse_config . downloadUrl , response_model , response , ) raise OPTIMADEParseError ( \"Could not validate for an expected response model.\" ) else : # No \"endpoint\" or unknown try : response_object = Success ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Unknown or unparseable endpoint. \\n ValidatonError: %s \\n \" \"URL= %r \\n endpoint= %r \\n response_model= %r \\n response= %s \" , exc , self . parse_config . downloadUrl , self . parse_config . downloadUrl . endpoint , response_model , response , ) raise OPTIMADEParseError ( \"Unknown or unparseable endpoint.\" ) from exc if self . parse_config . configuration . return_object : session . optimade_response_object = response_object else : session . optimade_response = model2dict ( response_object ) if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session initialize ( session = None ) \u00b6 Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific SessionUpdate context from services. Source code in oteapi_optimade/strategies/parse.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () resource \u00b6 OPTIMADE resource strategy. OPTIMADEResourceStrategy \u00b6 OPTIMADE Resource Strategy. Implements strategies : (\"accessService\", \"optimade\") (\"accessService\", \"OPTIMADE\") (\"accessService\", \"OPTiMaDe\") Source code in oteapi_optimade/strategies/resource.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 @dataclass class OPTIMADEResourceStrategy : \"\"\"OPTIMADE Resource Strategy. **Implements strategies**: - `(\"accessService\", \"optimade\")` - `(\"accessService\", \"OPTIMADE\")` - `(\"accessService\", \"OPTiMaDe\")` \"\"\" resource_config : OPTIMADEResourceConfig def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () def get ( # pylint: disable=too-many-branches,too-many-statements self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEResourceSession : \"\"\"Execute an OPTIMADE query to `accessUrl`. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `accessUrl`. Workflow: 1. Update configuration according to session. 2. Deconstruct `accessUrl` (done partly by `oteapi_optimade.models.custom_types.OPTIMADEUrl`). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEResourceSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEResourceSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEResourceSession () if session . optimade_config : self . resource_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_endpoint = self . resource_config . accessUrl . endpoint or \"structures\" optimade_query = ( self . resource_config . configuration . query_parameters or OPTIMADEQueryParameters () ) LOGGER . debug ( \"resource_config: %r \" , self . resource_config ) if self . resource_config . accessUrl . query : parsed_query = parse_qs ( self . resource_config . accessUrl . query ) for field , value in parsed_query . items (): # Only use the latest defined value for any parameter if field not in optimade_query . __fields_set__ : LOGGER . debug ( \"Setting %r from accessUrl (value= %r )\" , field , value [ - 1 ] ) setattr ( optimade_query , field , value [ - 1 ]) LOGGER . debug ( \"optimade_query after update: %r \" , optimade_query ) optimade_url = OPTIMADEUrl ( f \" { self . resource_config . accessUrl . base_url } \" f \" { '/' + self . resource_config . accessUrl . version if self . resource_config . accessUrl . version else '/v1' } \" # pylint: disable=line-too-long f \"/ { optimade_endpoint } ? { optimade_query . generate_query_string () } \" ) LOGGER . debug ( \"OPTIMADE URL to be requested: %s \" , optimade_url ) # Set cache access key to the full OPTIMADE URL. self . resource_config . configuration . datacache_config . accessKey = optimade_url # Perform query response = requests . get ( optimade_url , allow_redirects = True ) if optimade_query . response_format and optimade_query . response_format != \"json\" : raise NotImplementedError ( \"Can only handle JSON responses for now. Requested response format: \" f \" { optimade_query . response_format !r} \" ) cache = DataCache ( config = self . resource_config . configuration . datacache_config ) cache . add ( { \"status_code\" : response . status_code , \"ok\" : response . ok , \"json\" : response . json (), } ) parse_config = { \"downloadUrl\" : optimade_url , \"mediaType\" : ( f \"application/vnd. { self . resource_config . accessService } \" f \" { '+' + optimade_query . response_format if optimade_query . response_format else '' } \" # pylint: disable=line-too-long ), \"configuration\" : { \"datacache_config\" : self . resource_config . configuration . datacache_config , \"return_object\" : True , }, } session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) if \"optimade_response_object\" not in session : raise ValueError ( \"'optimade_response_object' was expected to be present in the session.\" ) optimade_response : \"OPTIMADEResponse\" = session . pop ( \"optimade_response_object\" ) if \"optimade_response\" in session and not session . get ( \"optimade_response\" ): del session [ \"optimade_response\" ] if isinstance ( optimade_response , ErrorResponse ): optimade_resources = optimade_response . errors session . optimade_resource_model = ( f \" { OptimadeError . __module__ } :OptimadeError\" ) elif isinstance ( optimade_response , ReferenceResponseMany ): optimade_resources = [ Reference ( entry ) . as_dict if isinstance ( entry , dict ) else Reference ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , ReferenceResponseOne ): optimade_resources = [ Reference ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Reference ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , StructureResponseMany ): optimade_resources = [ Structure ( entry ) . as_dict if isinstance ( entry , dict ) else Structure ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" elif isinstance ( optimade_response , StructureResponseOne ): optimade_resources = [ Structure ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Structure ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" else : LOGGER . debug ( \"Could not parse response as errors, references or structures. \" \"Response: \\n %r \" , optimade_response , ) raise OPTIMADEParseError ( \"Could not retrieve errors, references or structures from response \" f \"from { optimade_url } . It could be a valid OPTIMADE API response, \" \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \" \"invalid response completely.\" ) session . optimade_resources = [ model2dict ( resource ) for resource in optimade_resources ] if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session get ( session = None ) \u00b6 Execute an OPTIMADE query to accessUrl . This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in resource_config.configuration take precedence over the derived values from accessUrl . Workflow: 1. Update configuration according to session. 2. Deconstruct accessUrl (done partly by oteapi_optimade.models.custom_types.OPTIMADEUrl ). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary-like context. None Returns: Type Description OPTIMADEResourceSession An update model of key/value-pairs to be stored in the session-specific OPTIMADEResourceSession context from services. Source code in oteapi_optimade/strategies/resource.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def get ( # pylint: disable=too-many-branches,too-many-statements self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEResourceSession : \"\"\"Execute an OPTIMADE query to `accessUrl`. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `accessUrl`. Workflow: 1. Update configuration according to session. 2. Deconstruct `accessUrl` (done partly by `oteapi_optimade.models.custom_types.OPTIMADEUrl`). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEResourceSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEResourceSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEResourceSession () if session . optimade_config : self . resource_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_endpoint = self . resource_config . accessUrl . endpoint or \"structures\" optimade_query = ( self . resource_config . configuration . query_parameters or OPTIMADEQueryParameters () ) LOGGER . debug ( \"resource_config: %r \" , self . resource_config ) if self . resource_config . accessUrl . query : parsed_query = parse_qs ( self . resource_config . accessUrl . query ) for field , value in parsed_query . items (): # Only use the latest defined value for any parameter if field not in optimade_query . __fields_set__ : LOGGER . debug ( \"Setting %r from accessUrl (value= %r )\" , field , value [ - 1 ] ) setattr ( optimade_query , field , value [ - 1 ]) LOGGER . debug ( \"optimade_query after update: %r \" , optimade_query ) optimade_url = OPTIMADEUrl ( f \" { self . resource_config . accessUrl . base_url } \" f \" { '/' + self . resource_config . accessUrl . version if self . resource_config . accessUrl . version else '/v1' } \" # pylint: disable=line-too-long f \"/ { optimade_endpoint } ? { optimade_query . generate_query_string () } \" ) LOGGER . debug ( \"OPTIMADE URL to be requested: %s \" , optimade_url ) # Set cache access key to the full OPTIMADE URL. self . resource_config . configuration . datacache_config . accessKey = optimade_url # Perform query response = requests . get ( optimade_url , allow_redirects = True ) if optimade_query . response_format and optimade_query . response_format != \"json\" : raise NotImplementedError ( \"Can only handle JSON responses for now. Requested response format: \" f \" { optimade_query . response_format !r} \" ) cache = DataCache ( config = self . resource_config . configuration . datacache_config ) cache . add ( { \"status_code\" : response . status_code , \"ok\" : response . ok , \"json\" : response . json (), } ) parse_config = { \"downloadUrl\" : optimade_url , \"mediaType\" : ( f \"application/vnd. { self . resource_config . accessService } \" f \" { '+' + optimade_query . response_format if optimade_query . response_format else '' } \" # pylint: disable=line-too-long ), \"configuration\" : { \"datacache_config\" : self . resource_config . configuration . datacache_config , \"return_object\" : True , }, } session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) if \"optimade_response_object\" not in session : raise ValueError ( \"'optimade_response_object' was expected to be present in the session.\" ) optimade_response : \"OPTIMADEResponse\" = session . pop ( \"optimade_response_object\" ) if \"optimade_response\" in session and not session . get ( \"optimade_response\" ): del session [ \"optimade_response\" ] if isinstance ( optimade_response , ErrorResponse ): optimade_resources = optimade_response . errors session . optimade_resource_model = ( f \" { OptimadeError . __module__ } :OptimadeError\" ) elif isinstance ( optimade_response , ReferenceResponseMany ): optimade_resources = [ Reference ( entry ) . as_dict if isinstance ( entry , dict ) else Reference ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , ReferenceResponseOne ): optimade_resources = [ Reference ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Reference ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , StructureResponseMany ): optimade_resources = [ Structure ( entry ) . as_dict if isinstance ( entry , dict ) else Structure ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" elif isinstance ( optimade_response , StructureResponseOne ): optimade_resources = [ Structure ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Structure ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" else : LOGGER . debug ( \"Could not parse response as errors, references or structures. \" \"Response: \\n %r \" , optimade_response , ) raise OPTIMADEParseError ( \"Could not retrieve errors, references or structures from response \" f \"from { optimade_url } . It could be a valid OPTIMADE API response, \" \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \" \"invalid response completely.\" ) session . optimade_resources = [ model2dict ( resource ) for resource in optimade_resources ] if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session initialize ( session = None ) \u00b6 Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific SessionUpdate context from services. Source code in oteapi_optimade/strategies/resource.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate ()","title":"OTE-API OPTIMADE Strategies"},{"location":"all_strategies/#ote-api-optimade-strategies","text":"This page provides documentation for the oteapi_optimade.strategies submodule, where all the OTE-API OPTIMADE strategies are located. These strategies will be available when setting up a server in an environment with oteapi-optimade installed.","title":"OTE-API OPTIMADE Strategies"},{"location":"all_strategies/#oteapi_optimade.strategies.filter","text":"Demo filter strategy.","title":"filter"},{"location":"all_strategies/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy","text":"Filter Strategy. Implements strategies : (\"filterType\", \"OPTIMADE\") (\"filterType\", \"optimade\") (\"filterType\", \"OPTiMaDe\") Source code in oteapi_optimade/strategies/filter.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 @dataclass class OPTIMADEFilterStrategy : \"\"\"Filter Strategy. **Implements strategies**: - `(\"filterType\", \"OPTIMADE\")` - `(\"filterType\", \"optimade\")` - `(\"filterType\", \"OPTiMaDe\")` \"\"\" filter_config : OPTIMADEFilterConfig def initialize ( self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEFilterSession : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEFilterSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEFilterSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEFilterSession () if session . optimade_config : self . filter_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_config = self . filter_config . configuration . copy () if not optimade_config . query_parameters : optimade_config . query_parameters = OPTIMADEQueryParameters () if self . filter_config . query : LOGGER . debug ( \"Setting filter from query.\" ) optimade_config . query_parameters . filter = self . filter_config . query if self . filter_config . limit : LOGGER . debug ( \"Setting page_limit from limit.\" ) optimade_config . query_parameters . page_limit = self . filter_config . limit return session . copy ( update = { \"optimade_config\" : optimade_config . copy ( update = { \"query_parameters\" : model2dict ( optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) }, ) def get ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate ()","title":"OPTIMADEFilterStrategy"},{"location":"all_strategies/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the SessionUpdate session-specific context from services. Source code in oteapi_optimade/strategies/filter.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate ()","title":"get()"},{"location":"all_strategies/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.initialize","text":"Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary context. None Returns: Type Description OPTIMADEFilterSession An update model of key/value-pairs to be stored in the OPTIMADEFilterSession session-specific context from services. Source code in oteapi_optimade/strategies/filter.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def initialize ( self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEFilterSession : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEFilterSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEFilterSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEFilterSession () if session . optimade_config : self . filter_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_config = self . filter_config . configuration . copy () if not optimade_config . query_parameters : optimade_config . query_parameters = OPTIMADEQueryParameters () if self . filter_config . query : LOGGER . debug ( \"Setting filter from query.\" ) optimade_config . query_parameters . filter = self . filter_config . query if self . filter_config . limit : LOGGER . debug ( \"Setting page_limit from limit.\" ) optimade_config . query_parameters . page_limit = self . filter_config . limit return session . copy ( update = { \"optimade_config\" : optimade_config . copy ( update = { \"query_parameters\" : model2dict ( optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) }, )","title":"initialize()"},{"location":"all_strategies/#oteapi_optimade.strategies.parse","text":"Demo strategy class for text/json.","title":"parse"},{"location":"all_strategies/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy","text":"Parse strategy for JSON. Implements strategies : (\"mediaType\", \"application/vnd.optimade+json\") (\"mediaType\", \"application/vnd.OPTIMADE+json\") (\"mediaType\", \"application/vnd.OPTiMaDe+json\") (\"mediaType\", \"application/vnd.optimade+JSON\") (\"mediaType\", \"application/vnd.OPTIMADE+JSON\") (\"mediaType\", \"application/vnd.OPTiMaDe+JSON\") (\"mediaType\", \"application/vnd.optimade\") (\"mediaType\", \"application/vnd.OPTIMADE\") (\"mediaType\", \"application/vnd.OPTiMaDe\") Source code in oteapi_optimade/strategies/parse.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 @dataclass class OPTIMADEParseStrategy : \"\"\"Parse strategy for JSON. **Implements strategies**: - `(\"mediaType\", \"application/vnd.optimade+json\")` - `(\"mediaType\", \"application/vnd.OPTIMADE+json\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe+json\")` - `(\"mediaType\", \"application/vnd.optimade+JSON\")` - `(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")` - `(\"mediaType\", \"application/vnd.optimade\")` - `(\"mediaType\", \"application/vnd.OPTIMADE\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe\")` \"\"\" parse_config : OPTIMADEParseConfig def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () def get ( # pylint: disable=too-many-branches self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEParseSession : \"\"\"Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `downloadUrl`. Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEParseSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEParseSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEParseSession () if session . optimade_config : self . parse_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) cache = DataCache ( self . parse_config . configuration . datacache_config ) if self . parse_config . downloadUrl in cache : response : \"Dict[str, Any]\" = cache . get ( self . parse_config . downloadUrl ) elif ( self . parse_config . configuration . datacache_config . accessKey and self . parse_config . configuration . datacache_config . accessKey in cache ): response = cache . get ( self . parse_config . configuration . datacache_config . accessKey ) else : download_config = self . parse_config . copy () session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) response = { \"json\" : json . loads ( cache . get ( session . pop ( \"key\" )))} if ( not response . get ( \"ok\" , True ) or ( 200 > response . get ( \"status_code\" , 200 ) or response . get ( \"status_code\" , 200 ) >= 300 ) or \"errors\" in response . get ( \"json\" , {}) ): # Error response try : response_object = ErrorResponse ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Could not validate an error response. \\n ValidationError: \" \" %s \\n response= %r \" , exc , response , ) raise OPTIMADEParseError ( \"Could not validate an error response.\" ) from exc else : # Successful response response_model = self . parse_config . downloadUrl . response_model () if response_model : if not isinstance ( response_model , tuple ): response_model = ( response_model ,) for model_cls in response_model : try : response_object = model_cls ( ** response . get ( \"json\" , {})) except ValidationError : pass else : break else : LOGGER . error ( \"Could not validate for an expected response model. \\n URL= %r \\n \" \"response_models= %r \\n response= %s \" , self . parse_config . downloadUrl , response_model , response , ) raise OPTIMADEParseError ( \"Could not validate for an expected response model.\" ) else : # No \"endpoint\" or unknown try : response_object = Success ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Unknown or unparseable endpoint. \\n ValidatonError: %s \\n \" \"URL= %r \\n endpoint= %r \\n response_model= %r \\n response= %s \" , exc , self . parse_config . downloadUrl , self . parse_config . downloadUrl . endpoint , response_model , response , ) raise OPTIMADEParseError ( \"Unknown or unparseable endpoint.\" ) from exc if self . parse_config . configuration . return_object : session . optimade_response_object = response_object else : session . optimade_response = model2dict ( response_object ) if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session","title":"OPTIMADEParseStrategy"},{"location":"all_strategies/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.get","text":"Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in resource_config.configuration take precedence over the derived values from downloadUrl . Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary-like context. None Returns: Type Description OPTIMADEParseSession An update model of key/value-pairs to be stored in the session-specific OPTIMADEParseSession context from services. Source code in oteapi_optimade/strategies/parse.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def get ( # pylint: disable=too-many-branches self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEParseSession : \"\"\"Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `downloadUrl`. Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEParseSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEParseSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEParseSession () if session . optimade_config : self . parse_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) cache = DataCache ( self . parse_config . configuration . datacache_config ) if self . parse_config . downloadUrl in cache : response : \"Dict[str, Any]\" = cache . get ( self . parse_config . downloadUrl ) elif ( self . parse_config . configuration . datacache_config . accessKey and self . parse_config . configuration . datacache_config . accessKey in cache ): response = cache . get ( self . parse_config . configuration . datacache_config . accessKey ) else : download_config = self . parse_config . copy () session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) response = { \"json\" : json . loads ( cache . get ( session . pop ( \"key\" )))} if ( not response . get ( \"ok\" , True ) or ( 200 > response . get ( \"status_code\" , 200 ) or response . get ( \"status_code\" , 200 ) >= 300 ) or \"errors\" in response . get ( \"json\" , {}) ): # Error response try : response_object = ErrorResponse ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Could not validate an error response. \\n ValidationError: \" \" %s \\n response= %r \" , exc , response , ) raise OPTIMADEParseError ( \"Could not validate an error response.\" ) from exc else : # Successful response response_model = self . parse_config . downloadUrl . response_model () if response_model : if not isinstance ( response_model , tuple ): response_model = ( response_model ,) for model_cls in response_model : try : response_object = model_cls ( ** response . get ( \"json\" , {})) except ValidationError : pass else : break else : LOGGER . error ( \"Could not validate for an expected response model. \\n URL= %r \\n \" \"response_models= %r \\n response= %s \" , self . parse_config . downloadUrl , response_model , response , ) raise OPTIMADEParseError ( \"Could not validate for an expected response model.\" ) else : # No \"endpoint\" or unknown try : response_object = Success ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Unknown or unparseable endpoint. \\n ValidatonError: %s \\n \" \"URL= %r \\n endpoint= %r \\n response_model= %r \\n response= %s \" , exc , self . parse_config . downloadUrl , self . parse_config . downloadUrl . endpoint , response_model , response , ) raise OPTIMADEParseError ( \"Unknown or unparseable endpoint.\" ) from exc if self . parse_config . configuration . return_object : session . optimade_response_object = response_object else : session . optimade_response = model2dict ( response_object ) if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session","title":"get()"},{"location":"all_strategies/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.initialize","text":"Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific SessionUpdate context from services. Source code in oteapi_optimade/strategies/parse.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi_optimade.strategies.resource","text":"OPTIMADE resource strategy.","title":"resource"},{"location":"all_strategies/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy","text":"OPTIMADE Resource Strategy. Implements strategies : (\"accessService\", \"optimade\") (\"accessService\", \"OPTIMADE\") (\"accessService\", \"OPTiMaDe\") Source code in oteapi_optimade/strategies/resource.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 @dataclass class OPTIMADEResourceStrategy : \"\"\"OPTIMADE Resource Strategy. **Implements strategies**: - `(\"accessService\", \"optimade\")` - `(\"accessService\", \"OPTIMADE\")` - `(\"accessService\", \"OPTiMaDe\")` \"\"\" resource_config : OPTIMADEResourceConfig def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () def get ( # pylint: disable=too-many-branches,too-many-statements self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEResourceSession : \"\"\"Execute an OPTIMADE query to `accessUrl`. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `accessUrl`. Workflow: 1. Update configuration according to session. 2. Deconstruct `accessUrl` (done partly by `oteapi_optimade.models.custom_types.OPTIMADEUrl`). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEResourceSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEResourceSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEResourceSession () if session . optimade_config : self . resource_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_endpoint = self . resource_config . accessUrl . endpoint or \"structures\" optimade_query = ( self . resource_config . configuration . query_parameters or OPTIMADEQueryParameters () ) LOGGER . debug ( \"resource_config: %r \" , self . resource_config ) if self . resource_config . accessUrl . query : parsed_query = parse_qs ( self . resource_config . accessUrl . query ) for field , value in parsed_query . items (): # Only use the latest defined value for any parameter if field not in optimade_query . __fields_set__ : LOGGER . debug ( \"Setting %r from accessUrl (value= %r )\" , field , value [ - 1 ] ) setattr ( optimade_query , field , value [ - 1 ]) LOGGER . debug ( \"optimade_query after update: %r \" , optimade_query ) optimade_url = OPTIMADEUrl ( f \" { self . resource_config . accessUrl . base_url } \" f \" { '/' + self . resource_config . accessUrl . version if self . resource_config . accessUrl . version else '/v1' } \" # pylint: disable=line-too-long f \"/ { optimade_endpoint } ? { optimade_query . generate_query_string () } \" ) LOGGER . debug ( \"OPTIMADE URL to be requested: %s \" , optimade_url ) # Set cache access key to the full OPTIMADE URL. self . resource_config . configuration . datacache_config . accessKey = optimade_url # Perform query response = requests . get ( optimade_url , allow_redirects = True ) if optimade_query . response_format and optimade_query . response_format != \"json\" : raise NotImplementedError ( \"Can only handle JSON responses for now. Requested response format: \" f \" { optimade_query . response_format !r} \" ) cache = DataCache ( config = self . resource_config . configuration . datacache_config ) cache . add ( { \"status_code\" : response . status_code , \"ok\" : response . ok , \"json\" : response . json (), } ) parse_config = { \"downloadUrl\" : optimade_url , \"mediaType\" : ( f \"application/vnd. { self . resource_config . accessService } \" f \" { '+' + optimade_query . response_format if optimade_query . response_format else '' } \" # pylint: disable=line-too-long ), \"configuration\" : { \"datacache_config\" : self . resource_config . configuration . datacache_config , \"return_object\" : True , }, } session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) if \"optimade_response_object\" not in session : raise ValueError ( \"'optimade_response_object' was expected to be present in the session.\" ) optimade_response : \"OPTIMADEResponse\" = session . pop ( \"optimade_response_object\" ) if \"optimade_response\" in session and not session . get ( \"optimade_response\" ): del session [ \"optimade_response\" ] if isinstance ( optimade_response , ErrorResponse ): optimade_resources = optimade_response . errors session . optimade_resource_model = ( f \" { OptimadeError . __module__ } :OptimadeError\" ) elif isinstance ( optimade_response , ReferenceResponseMany ): optimade_resources = [ Reference ( entry ) . as_dict if isinstance ( entry , dict ) else Reference ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , ReferenceResponseOne ): optimade_resources = [ Reference ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Reference ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , StructureResponseMany ): optimade_resources = [ Structure ( entry ) . as_dict if isinstance ( entry , dict ) else Structure ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" elif isinstance ( optimade_response , StructureResponseOne ): optimade_resources = [ Structure ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Structure ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" else : LOGGER . debug ( \"Could not parse response as errors, references or structures. \" \"Response: \\n %r \" , optimade_response , ) raise OPTIMADEParseError ( \"Could not retrieve errors, references or structures from response \" f \"from { optimade_url } . It could be a valid OPTIMADE API response, \" \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \" \"invalid response completely.\" ) session . optimade_resources = [ model2dict ( resource ) for resource in optimade_resources ] if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session","title":"OPTIMADEResourceStrategy"},{"location":"all_strategies/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.get","text":"Execute an OPTIMADE query to accessUrl . This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in resource_config.configuration take precedence over the derived values from accessUrl . Workflow: 1. Update configuration according to session. 2. Deconstruct accessUrl (done partly by oteapi_optimade.models.custom_types.OPTIMADEUrl ). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary-like context. None Returns: Type Description OPTIMADEResourceSession An update model of key/value-pairs to be stored in the session-specific OPTIMADEResourceSession context from services. Source code in oteapi_optimade/strategies/resource.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def get ( # pylint: disable=too-many-branches,too-many-statements self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEResourceSession : \"\"\"Execute an OPTIMADE query to `accessUrl`. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `accessUrl`. Workflow: 1. Update configuration according to session. 2. Deconstruct `accessUrl` (done partly by `oteapi_optimade.models.custom_types.OPTIMADEUrl`). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEResourceSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEResourceSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEResourceSession () if session . optimade_config : self . resource_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_endpoint = self . resource_config . accessUrl . endpoint or \"structures\" optimade_query = ( self . resource_config . configuration . query_parameters or OPTIMADEQueryParameters () ) LOGGER . debug ( \"resource_config: %r \" , self . resource_config ) if self . resource_config . accessUrl . query : parsed_query = parse_qs ( self . resource_config . accessUrl . query ) for field , value in parsed_query . items (): # Only use the latest defined value for any parameter if field not in optimade_query . __fields_set__ : LOGGER . debug ( \"Setting %r from accessUrl (value= %r )\" , field , value [ - 1 ] ) setattr ( optimade_query , field , value [ - 1 ]) LOGGER . debug ( \"optimade_query after update: %r \" , optimade_query ) optimade_url = OPTIMADEUrl ( f \" { self . resource_config . accessUrl . base_url } \" f \" { '/' + self . resource_config . accessUrl . version if self . resource_config . accessUrl . version else '/v1' } \" # pylint: disable=line-too-long f \"/ { optimade_endpoint } ? { optimade_query . generate_query_string () } \" ) LOGGER . debug ( \"OPTIMADE URL to be requested: %s \" , optimade_url ) # Set cache access key to the full OPTIMADE URL. self . resource_config . configuration . datacache_config . accessKey = optimade_url # Perform query response = requests . get ( optimade_url , allow_redirects = True ) if optimade_query . response_format and optimade_query . response_format != \"json\" : raise NotImplementedError ( \"Can only handle JSON responses for now. Requested response format: \" f \" { optimade_query . response_format !r} \" ) cache = DataCache ( config = self . resource_config . configuration . datacache_config ) cache . add ( { \"status_code\" : response . status_code , \"ok\" : response . ok , \"json\" : response . json (), } ) parse_config = { \"downloadUrl\" : optimade_url , \"mediaType\" : ( f \"application/vnd. { self . resource_config . accessService } \" f \" { '+' + optimade_query . response_format if optimade_query . response_format else '' } \" # pylint: disable=line-too-long ), \"configuration\" : { \"datacache_config\" : self . resource_config . configuration . datacache_config , \"return_object\" : True , }, } session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) if \"optimade_response_object\" not in session : raise ValueError ( \"'optimade_response_object' was expected to be present in the session.\" ) optimade_response : \"OPTIMADEResponse\" = session . pop ( \"optimade_response_object\" ) if \"optimade_response\" in session and not session . get ( \"optimade_response\" ): del session [ \"optimade_response\" ] if isinstance ( optimade_response , ErrorResponse ): optimade_resources = optimade_response . errors session . optimade_resource_model = ( f \" { OptimadeError . __module__ } :OptimadeError\" ) elif isinstance ( optimade_response , ReferenceResponseMany ): optimade_resources = [ Reference ( entry ) . as_dict if isinstance ( entry , dict ) else Reference ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , ReferenceResponseOne ): optimade_resources = [ Reference ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Reference ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , StructureResponseMany ): optimade_resources = [ Structure ( entry ) . as_dict if isinstance ( entry , dict ) else Structure ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" elif isinstance ( optimade_response , StructureResponseOne ): optimade_resources = [ Structure ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Structure ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" else : LOGGER . debug ( \"Could not parse response as errors, references or structures. \" \"Response: \\n %r \" , optimade_response , ) raise OPTIMADEParseError ( \"Could not retrieve errors, references or structures from response \" f \"from { optimade_url } . It could be a valid OPTIMADE API response, \" \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \" \"invalid response completely.\" ) session . optimade_resources = [ model2dict ( resource ) for resource in optimade_resources ] if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session","title":"get()"},{"location":"all_strategies/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.initialize","text":"Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific SessionUpdate context from services. Source code in oteapi_optimade/strategies/resource.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/exceptions/","text":"exceptions \u00b6 OTE-API OPTIMADE-specific Python exceptions. BaseOteapiOptimadeException \u00b6 Bases: Exception Base OTE-API OPTIMADE exception. Source code in oteapi_optimade/exceptions.py 4 5 class BaseOteapiOptimadeException ( Exception ): \"\"\"Base OTE-API OPTIMADE exception.\"\"\" ConfigurationError \u00b6 Bases: BaseOteapiOptimadeException An error occurred when dealing with strategy configurations. Source code in oteapi_optimade/exceptions.py 8 9 class ConfigurationError ( BaseOteapiOptimadeException ): \"\"\"An error occurred when dealing with strategy configurations.\"\"\" OPTIMADEParseError \u00b6 Bases: BaseOteapiOptimadeException Could not use OPTIMADE Python tools to parse an OPTIMADE API response. Source code in oteapi_optimade/exceptions.py 20 21 class OPTIMADEParseError ( BaseOteapiOptimadeException ): \"\"\"Could not use OPTIMADE Python tools to parse an OPTIMADE API response.\"\"\" OPTIMADEResponseError \u00b6 Bases: RequestError An OPTIMADE error was returned from a URL request. Source code in oteapi_optimade/exceptions.py 16 17 class OPTIMADEResponseError ( RequestError ): \"\"\"An OPTIMADE error was returned from a URL request.\"\"\" RequestError \u00b6 Bases: BaseOteapiOptimadeException A general error occured when performing a URL request. Source code in oteapi_optimade/exceptions.py 12 13 class RequestError ( BaseOteapiOptimadeException ): \"\"\"A general error occured when performing a URL request.\"\"\"","title":"exceptions"},{"location":"api_reference/exceptions/#exceptions","text":"OTE-API OPTIMADE-specific Python exceptions.","title":"exceptions"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.BaseOteapiOptimadeException","text":"Bases: Exception Base OTE-API OPTIMADE exception. Source code in oteapi_optimade/exceptions.py 4 5 class BaseOteapiOptimadeException ( Exception ): \"\"\"Base OTE-API OPTIMADE exception.\"\"\"","title":"BaseOteapiOptimadeException"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.ConfigurationError","text":"Bases: BaseOteapiOptimadeException An error occurred when dealing with strategy configurations. Source code in oteapi_optimade/exceptions.py 8 9 class ConfigurationError ( BaseOteapiOptimadeException ): \"\"\"An error occurred when dealing with strategy configurations.\"\"\"","title":"ConfigurationError"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.OPTIMADEParseError","text":"Bases: BaseOteapiOptimadeException Could not use OPTIMADE Python tools to parse an OPTIMADE API response. Source code in oteapi_optimade/exceptions.py 20 21 class OPTIMADEParseError ( BaseOteapiOptimadeException ): \"\"\"Could not use OPTIMADE Python tools to parse an OPTIMADE API response.\"\"\"","title":"OPTIMADEParseError"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.OPTIMADEResponseError","text":"Bases: RequestError An OPTIMADE error was returned from a URL request. Source code in oteapi_optimade/exceptions.py 16 17 class OPTIMADEResponseError ( RequestError ): \"\"\"An OPTIMADE error was returned from a URL request.\"\"\"","title":"OPTIMADEResponseError"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.RequestError","text":"Bases: BaseOteapiOptimadeException A general error occured when performing a URL request. Source code in oteapi_optimade/exceptions.py 12 13 class RequestError ( BaseOteapiOptimadeException ): \"\"\"A general error occured when performing a URL request.\"\"\"","title":"RequestError"},{"location":"api_reference/utils/","text":"utils \u00b6 Utility functions to be used in OTEAPI OPTIMADE. model2dict ( model , ** dict_kwargs ) \u00b6 Convert a pydantic model to a Python dictionary. This works similarly to the dict() method for pydantic models, but ensures any and all nested pydantic models are also converted to dictionaries. Parameters: Name Type Description Default model 'Union[BaseModel, dict[str, Any]]' The pydantic model or Python dictionary to be converted fully to a Python dictionary, through and through. required **dict_kwargs Dict [ Any , Any ] Keyword arguments to be passed to dict() method calls for pydantic models. Note, this will be used for all dict() method calls. {} Returns: Type Description 'dict[str, Any]' A Python dictionary, where all nested values that were pydantic models are also 'dict[str, Any]' converted to Python dictionaries. Source code in oteapi_optimade/utils.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def model2dict ( model : \"Union[BaseModel, dict[str, Any]]\" , ** dict_kwargs : \"Any\" ) -> \"dict[str, Any]\" : \"\"\"Convert a pydantic model to a Python dictionary. This works similarly to the `dict()` method for pydantic models, but ensures any and all nested pydantic models are also converted to dictionaries. Parameters: model: The pydantic model or Python dictionary to be converted fully to a Python dictionary, through and through. **dict_kwargs (Dict[Any, Any]): Keyword arguments to be passed to `dict()` method calls for pydantic models. Note, this will be used for _all_ `dict()` method calls. Returns: A Python dictionary, where all nested values that were pydantic models are also converted to Python dictionaries. \"\"\" def _internal ( model_ : \"Any\" ) -> \"Any\" : \"\"\"Internal function to be used recursively.\"\"\" if isinstance ( model_ , dict ): return { key : _internal ( value ) for key , value in model_ . items ()} if isinstance ( model_ , Iterable ) and not isinstance ( model_ , ( bytes , str )): return type ( model_ )( _internal ( value ) for value in model_ ) # type: ignore[call-arg] # pylint: disable=line-too-long if isinstance ( model_ , BaseModel ): return _internal ( model_ . dict ( ** dict_kwargs )) return model_ if isinstance ( model , BaseModel ): res = model . dict ( ** dict_kwargs ) elif isinstance ( model , dict ): res = deepcopy ( model ) else : raise TypeError ( \"model must be either a pydantic model or a dict.\" ) return _internal ( res )","title":"utils"},{"location":"api_reference/utils/#utils","text":"Utility functions to be used in OTEAPI OPTIMADE.","title":"utils"},{"location":"api_reference/utils/#oteapi_optimade.utils.model2dict","text":"Convert a pydantic model to a Python dictionary. This works similarly to the dict() method for pydantic models, but ensures any and all nested pydantic models are also converted to dictionaries. Parameters: Name Type Description Default model 'Union[BaseModel, dict[str, Any]]' The pydantic model or Python dictionary to be converted fully to a Python dictionary, through and through. required **dict_kwargs Dict [ Any , Any ] Keyword arguments to be passed to dict() method calls for pydantic models. Note, this will be used for all dict() method calls. {} Returns: Type Description 'dict[str, Any]' A Python dictionary, where all nested values that were pydantic models are also 'dict[str, Any]' converted to Python dictionaries. Source code in oteapi_optimade/utils.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def model2dict ( model : \"Union[BaseModel, dict[str, Any]]\" , ** dict_kwargs : \"Any\" ) -> \"dict[str, Any]\" : \"\"\"Convert a pydantic model to a Python dictionary. This works similarly to the `dict()` method for pydantic models, but ensures any and all nested pydantic models are also converted to dictionaries. Parameters: model: The pydantic model or Python dictionary to be converted fully to a Python dictionary, through and through. **dict_kwargs (Dict[Any, Any]): Keyword arguments to be passed to `dict()` method calls for pydantic models. Note, this will be used for _all_ `dict()` method calls. Returns: A Python dictionary, where all nested values that were pydantic models are also converted to Python dictionaries. \"\"\" def _internal ( model_ : \"Any\" ) -> \"Any\" : \"\"\"Internal function to be used recursively.\"\"\" if isinstance ( model_ , dict ): return { key : _internal ( value ) for key , value in model_ . items ()} if isinstance ( model_ , Iterable ) and not isinstance ( model_ , ( bytes , str )): return type ( model_ )( _internal ( value ) for value in model_ ) # type: ignore[call-arg] # pylint: disable=line-too-long if isinstance ( model_ , BaseModel ): return _internal ( model_ . dict ( ** dict_kwargs )) return model_ if isinstance ( model , BaseModel ): res = model . dict ( ** dict_kwargs ) elif isinstance ( model , dict ): res = deepcopy ( model ) else : raise TypeError ( \"model must be either a pydantic model or a dict.\" ) return _internal ( res )","title":"model2dict()"},{"location":"api_reference/models/config/","text":"config \u00b6 General OPTIMADE configuration models. DEFAULT_CACHE_CONFIG_VALUES = { 'expireTime' : 60 * 60 * 24 , 'tag' : 'optimade' } module-attribute \u00b6 Set the expireTime and tag to default values for the data cache. OPTIMADEConfig \u00b6 Bases: AttrDict OPTIMADE configuration. Source code in oteapi_optimade/models/config.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class OPTIMADEConfig ( AttrDict ): \"\"\"OPTIMADE configuration.\"\"\" version : str = Field ( \"v1\" , description = \"The version part of the OPTIMADE versioned base URL.\" , regex = r \"^v[0-9]+(\\.[0-9]+){,2}$\" , ) endpoint : Literal [ \"references\" , \"structures\" ] = Field ( \"structures\" , description = \"Supported OPTIMADE entry resource endpoint.\" , ) query_parameters : Optional [ OPTIMADEQueryParameters ] = Field ( None , description = \"URL query parameters to be used in the OPTIMADE query.\" , ) datacache_config : DataCacheConfig = Field ( DataCacheConfig ( ** DEFAULT_CACHE_CONFIG_VALUES ), description = \"Configuration options for the local data cache.\" , ) return_object : bool = Field ( False , description = ( \"Whether or not to return a response object (using the pydantic model). \\n \" \" \\n Important: \\n This should _only_ be used if the strategy is called \" \"directly and not via an OTEAPI REST API service.\" ), ) @validator ( \"datacache_config\" ) def default_datacache_config ( cls , value : DataCacheConfig ) -> DataCacheConfig : \"\"\"Use default values for `DataCacheConfig` if not supplied.\"\"\" original_set_values = len ( value . __fields_set__ ) for field , default_value in DEFAULT_CACHE_CONFIG_VALUES . items (): if field in value . __fields_set__ : # Use the set value instead of the default continue setattr ( value , field , default_value ) if len ( value . __fields_set__ ) > original_set_values : # Re-validate model and return it return value . validate ( { field : field_value for field , field_value in value . dict () . items () if field in value . __fields_set__ } ) return value datacache_config : DataCacheConfig = Field ( DataCacheConfig ( None = DEFAULT_CACHE_CONFIG_VALUES ), description = 'Configuration options for the local data cache.' ) class-attribute \u00b6 endpoint : Literal [ 'references' , 'structures' ] = Field ( 'structures' , description = 'Supported OPTIMADE entry resource endpoint.' ) class-attribute \u00b6 query_parameters : Optional [ OPTIMADEQueryParameters ] = Field ( None , description = 'URL query parameters to be used in the OPTIMADE query.' ) class-attribute \u00b6 return_object : bool = Field ( False , description = 'Whether or not to return a response object (using the pydantic model). \\n\\n Important: \\n This should _only_ be used if the strategy is called directly and not via an OTEAPI REST API service.' ) class-attribute \u00b6 version : str = Field ( 'v1' , description = 'The version part of the OPTIMADE versioned base URL.' , regex = '^v[0-9]+( \\\\ .[0-9]+){,2}$' ) class-attribute \u00b6 default_datacache_config ( value ) \u00b6 Use default values for DataCacheConfig if not supplied. Source code in oteapi_optimade/models/config.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @validator ( \"datacache_config\" ) def default_datacache_config ( cls , value : DataCacheConfig ) -> DataCacheConfig : \"\"\"Use default values for `DataCacheConfig` if not supplied.\"\"\" original_set_values = len ( value . __fields_set__ ) for field , default_value in DEFAULT_CACHE_CONFIG_VALUES . items (): if field in value . __fields_set__ : # Use the set value instead of the default continue setattr ( value , field , default_value ) if len ( value . __fields_set__ ) > original_set_values : # Re-validate model and return it return value . validate ( { field : field_value for field , field_value in value . dict () . items () if field in value . __fields_set__ } ) return value","title":"config"},{"location":"api_reference/models/config/#config","text":"General OPTIMADE configuration models.","title":"config"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.DEFAULT_CACHE_CONFIG_VALUES","text":"Set the expireTime and tag to default values for the data cache.","title":"DEFAULT_CACHE_CONFIG_VALUES"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig","text":"Bases: AttrDict OPTIMADE configuration. Source code in oteapi_optimade/models/config.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class OPTIMADEConfig ( AttrDict ): \"\"\"OPTIMADE configuration.\"\"\" version : str = Field ( \"v1\" , description = \"The version part of the OPTIMADE versioned base URL.\" , regex = r \"^v[0-9]+(\\.[0-9]+){,2}$\" , ) endpoint : Literal [ \"references\" , \"structures\" ] = Field ( \"structures\" , description = \"Supported OPTIMADE entry resource endpoint.\" , ) query_parameters : Optional [ OPTIMADEQueryParameters ] = Field ( None , description = \"URL query parameters to be used in the OPTIMADE query.\" , ) datacache_config : DataCacheConfig = Field ( DataCacheConfig ( ** DEFAULT_CACHE_CONFIG_VALUES ), description = \"Configuration options for the local data cache.\" , ) return_object : bool = Field ( False , description = ( \"Whether or not to return a response object (using the pydantic model). \\n \" \" \\n Important: \\n This should _only_ be used if the strategy is called \" \"directly and not via an OTEAPI REST API service.\" ), ) @validator ( \"datacache_config\" ) def default_datacache_config ( cls , value : DataCacheConfig ) -> DataCacheConfig : \"\"\"Use default values for `DataCacheConfig` if not supplied.\"\"\" original_set_values = len ( value . __fields_set__ ) for field , default_value in DEFAULT_CACHE_CONFIG_VALUES . items (): if field in value . __fields_set__ : # Use the set value instead of the default continue setattr ( value , field , default_value ) if len ( value . __fields_set__ ) > original_set_values : # Re-validate model and return it return value . validate ( { field : field_value for field , field_value in value . dict () . items () if field in value . __fields_set__ } ) return value","title":"OPTIMADEConfig"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.datacache_config","text":"","title":"datacache_config"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.endpoint","text":"","title":"endpoint"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.query_parameters","text":"","title":"query_parameters"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.return_object","text":"","title":"return_object"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.version","text":"","title":"version"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.default_datacache_config","text":"Use default values for DataCacheConfig if not supplied. Source code in oteapi_optimade/models/config.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @validator ( \"datacache_config\" ) def default_datacache_config ( cls , value : DataCacheConfig ) -> DataCacheConfig : \"\"\"Use default values for `DataCacheConfig` if not supplied.\"\"\" original_set_values = len ( value . __fields_set__ ) for field , default_value in DEFAULT_CACHE_CONFIG_VALUES . items (): if field in value . __fields_set__ : # Use the set value instead of the default continue setattr ( value , field , default_value ) if len ( value . __fields_set__ ) > original_set_values : # Re-validate model and return it return value . validate ( { field : field_value for field , field_value in value . dict () . items () if field in value . __fields_set__ } ) return value","title":"default_datacache_config()"},{"location":"api_reference/models/custom_types/","text":"custom_types \u00b6 Custom \"pydantic\" types used in OTEAPI-OPTIMADE. LOGGER = logging . getLogger ( 'oteapi_optimade.models' ) module-attribute \u00b6 _OPTIMADE_BASE_URL_REGEX = None module-attribute \u00b6 _OPTIMADE_ENDPOINT_REGEX = None module-attribute \u00b6 OPTIMADEParts \u00b6 Bases: TypedDict Similar to pydantic.networks.Parts . Source code in oteapi_optimade/models/custom_types.py 31 32 33 34 35 36 37 class OPTIMADEParts ( TypedDict , total = False ): \"\"\"Similar to `pydantic.networks.Parts`.\"\"\" base_url : str version : Optional [ str ] endpoint : Optional [ str ] query : Optional [ str ] base_url : str = None class-attribute \u00b6 endpoint : Optional [ str ] = None class-attribute \u00b6 query : Optional [ str ] = None class-attribute \u00b6 version : Optional [ str ] = None class-attribute \u00b6 OPTIMADEUrl \u00b6 Bases: str A deconstructed OPTIMADE URL. An OPTIMADE URL is made up in the following way /[ /] ? Where parts in square brackets ( [] ) are optional. Source code in oteapi_optimade/models/custom_types.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 class OPTIMADEUrl ( str ): \"\"\"A deconstructed OPTIMADE URL. An OPTIMADE URL is made up in the following way: <BASE URL>/[<VERSION>/]<ENDPOINT>?<QUERY PARAMETERS> Where parts in square brackets (`[]`) are optional. \"\"\" strip_whitespace = True min_length = 1 # https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers # pylint: disable=line-too-long max_length = 2083 allowed_schemes = { \"http\" , \"https\" } tld_required = False user_required = False __slots__ = ( \"base_url\" , \"version\" , \"endpoint\" , \"query\" , \"scheme\" , \"tld\" , \"host_type\" , ) @no_type_check def __new__ ( cls , url : \"Optional[str]\" = None , ** kwargs ) -> object : return str . __new__ ( cls , cls . build ( ** kwargs ) if url is None else url , # pylint: disable=missing-kwoa ) def __init__ ( self , url : str , * , base_url : \"Optional[str]\" = None , version : \"Optional[str]\" = None , endpoint : \"Optional[str]\" = None , query : \"Optional[str]\" = None , scheme : \"Optional[str]\" = None , tld : \"Optional[str]\" = None , host_type : str = \"domain\" , ) -> None : str . __init__ ( url ) self . base_url = base_url self . version = version self . endpoint = endpoint self . query = query self . scheme = scheme self . tld = tld self . host_type = host_type @classmethod def build ( cls , * , base_url : \"str\" , version : \"Optional[str]\" = None , endpoint : \"Optional[str]\" = None , query : \"Optional[str]\" = None , ** _kwargs : str , ) -> str : \"\"\"Build complete URL from URL parts.\"\"\" url = base_url . rstrip ( \"/\" ) if version : url += f \"/ { version } \" if endpoint : url += f \"/ { endpoint } \" if query : url += f \"? { query } \" return url @classmethod def __modify_schema__ ( cls , field_schema : \"Dict[str, Any]\" ) -> None : update_not_none ( field_schema , minLength = cls . min_length , maxLength = cls . max_length , format = \"uri\" , ) @classmethod def __get_validators__ ( cls ) -> \"CallableGenerator\" : yield cls . validate @staticmethod def urlquote_qs ( url : str ) -> str : \"\"\"Use `urllib.parse.quote` for query part of URL.\"\"\" parsed_url = urlparse ( url ) quoted_query = urlquote ( parsed_url . query , safe = \"=&,\" ) parsed_url_list = list ( parsed_url ) parsed_url_list [ - 2 ] = quoted_query return urlunparse ( parsed_url_list ) @classmethod def validate ( cls , value : \"Any\" , field : \"ModelField\" , config : \"BaseConfig\" ) -> \"OPTIMADEUrl\" : \"\"\"Pydantic validation of an OPTIMADE URL.\"\"\" if value . __class__ == cls : return value value : str = str_validator ( value ) if cls . strip_whitespace : value = value . strip () url : str = cast ( str , constr_length_validator ( value , field , config )) url = cls . urlquote_qs ( url ) url_match = url_regex () . match ( url ) if url_match is None : raise ValueError ( f \"Cannot match URL ( { url !r} ) as a valid URL.\" ) original_parts = cast ( \"Parts\" , url_match . groupdict ()) parts = cls . apply_default_parts ( original_parts ) host , tld , host_type , rebuild = cls . validate_host ( parts ) optimade_parts = cls . build_optimade_parts ( parts , host ) optimade_parts = cls . validate_parts ( parts , optimade_parts ) if url_match . end () != len ( url ): raise errors . UrlExtraError ( extra = url [ url_match . end () :]) return cls ( None if rebuild else url , base_url = optimade_parts [ \"base_url\" ], version = optimade_parts [ \"version\" ], endpoint = optimade_parts [ \"endpoint\" ], query = optimade_parts [ \"query\" ], scheme = parts [ \"scheme\" ], tld = tld , host_type = host_type , ) @classmethod def validate_host ( cls , parts : \"Parts\" ) -> \"Tuple[str, Optional[str], str, bool]\" : \"\"\"Validate host-part of the URL.\"\"\" host : \"Optional[str]\" = None tld : \"Optional[str]\" = None rebuild : bool = False for host_type in ( \"domain\" , \"ipv4\" , \"ipv6\" ): host = parts [ host_type ] # type: ignore[literal-required] if host : break else : raise errors . UrlHostError () if host_type == \"domain\" : is_international = False domain = ascii_domain_regex () . fullmatch ( host ) if domain is None : domain = int_domain_regex () . fullmatch ( host ) if domain is None : raise errors . UrlHostError () is_international = True tld = domain . group ( \"tld\" ) if tld is None and not is_international : domain = int_domain_regex () . fullmatch ( host ) if domain is None : raise ValueError ( \"domain cannot be None\" ) tld = domain . group ( \"tld\" ) is_international = True if tld is not None : tld = tld [ 1 :] elif cls . tld_required : raise errors . UrlHostTldError () if is_international : host_type = \"int_domain\" rebuild = True host = host . encode ( \"idna\" ) . decode ( \"ascii\" ) if tld is not None : tld = tld . encode ( \"idna\" ) . decode ( \"ascii\" ) return host , tld , host_type , rebuild @staticmethod def get_default_parts ( parts : \"Parts\" ) -> \"Parts\" : \"\"\"Dictionary of default URL-part values.\"\"\" return { \"port\" : \"80\" if parts [ \"scheme\" ] == \"http\" else \"443\" } @classmethod def apply_default_parts ( cls , parts : \"Parts\" ) -> \"Parts\" : \"\"\"Apply default URL-part values if no value is given.\"\"\" for key , value in cls . get_default_parts ( parts ) . items (): if not parts [ key ]: # type: ignore[literal-required] parts [ key ] = value # type: ignore[literal-required] return parts @classmethod def build_optimade_parts ( cls , parts : \"Parts\" , host : str ) -> \"OPTIMADEParts\" : \"\"\"Convert URL parts to equivalent OPTIMADE URL parts.\"\"\" base_url = f \" { parts [ 'scheme' ] } ://\" if parts [ \"user\" ]: base_url += parts [ \"user\" ] if parts [ \"password\" ]: base_url += f \": { parts [ 'password' ] } \" if parts [ \"user\" ] or parts [ \"password\" ]: base_url += \"@\" base_url += host # Hide port if it's a standard HTTP (80) or HTTPS (443) port. if parts [ \"port\" ] and parts [ \"port\" ] not in ( \"80\" , \"443\" ): base_url += f \": { parts [ 'port' ] } \" if parts [ \"path\" ]: base_url += parts [ \"path\" ] base_url_match = optimade_base_url_regex () . fullmatch ( base_url ) LOGGER . debug ( \"OPTIMADE base URL regex match groups: %s \" , base_url_match . groupdict () if base_url_match else base_url_match , ) if base_url_match is None : raise ValueError ( \"Could not match given string with OPTIMADE base URL regex.\" ) endpoint_match = optimade_endpoint_regex () . findall ( base_url_match . group ( \"path\" ) if base_url_match . group ( \"path\" ) else \"\" ) LOGGER . debug ( \"OPTIMADE endpoint regex matches: %s \" , endpoint_match ) for path_version , path_endpoint in endpoint_match : if path_endpoint : break else : LOGGER . debug ( \"Could not match given string with OPTIMADE endpoint regex.\" ) path_version , path_endpoint = \"\" , \"\" base_url = base_url_match . group ( \"base_url\" ) if path_version : base_url = base_url [: - ( len ( path_version ) + len ( path_endpoint ) + 2 )] elif path_endpoint : base_url = base_url [: - ( len ( path_endpoint ) + 1 )] optimade_parts = { \"base_url\" : base_url . rstrip ( \"/\" ), \"version\" : path_version or None , \"endpoint\" : path_endpoint or None , \"query\" : parts [ \"query\" ], } return cast ( \"OPTIMADEParts\" , optimade_parts ) @classmethod def validate_parts ( cls , parts : \"Parts\" , optimade_parts : \"OPTIMADEParts\" ) -> \"OPTIMADEParts\" : \"\"\" A method used to validate parts of an URL. Could be overridden to set default values for parts if missing \"\"\" scheme = parts [ \"scheme\" ] if scheme is None : raise errors . UrlSchemeError () if cls . allowed_schemes and scheme . lower () not in cls . allowed_schemes : raise errors . UrlSchemePermittedError ( set ( cls . allowed_schemes )) port = parts [ \"port\" ] if port is not None and int ( port ) > 65_535 : raise errors . UrlPortError () user = parts [ \"user\" ] if cls . user_required and user is None : raise errors . UrlUserInfoError () base_url = optimade_parts [ \"base_url\" ] if base_url is None : raise errors . UrlError () return optimade_parts def __repr__ ( self ) -> str : extra = \", \" . join ( f \" { n } = { getattr ( self , n ) !r} \" for n in self . __slots__ if getattr ( self , n ) is not None ) return f \" { self . __class__ . __name__ } ( { super () . __repr__ () } , { extra } )\" def response_model ( self ) -> \"Union[Tuple[Success, ...], Success, None]\" : \"\"\"Return the endpoint's corresponding response model (from OPT).\"\"\" if not self . endpoint or self . endpoint == \"versions\" : return None return { \"info\" : ( InfoResponse , EntryInfoResponse ), \"links\" : LinksResponse , \"structures\" : ( StructureResponseMany , StructureResponseOne ), \"references\" : ( ReferenceResponseMany , ReferenceResponseOne ), \"calculations\" : ( EntryResponseMany , EntryResponseOne ), } . get ( self . endpoint , Success ) __slots__ = ( 'base_url' , 'version' , 'endpoint' , 'query' , 'scheme' , 'tld' , 'host_type' ) class-attribute \u00b6 allowed_schemes = { 'http' , 'https' } class-attribute \u00b6 base_url = base_url instance-attribute \u00b6 endpoint = endpoint instance-attribute \u00b6 host_type = host_type instance-attribute \u00b6 max_length = 2083 class-attribute \u00b6 min_length = 1 class-attribute \u00b6 query = query instance-attribute \u00b6 scheme = scheme instance-attribute \u00b6 strip_whitespace = True class-attribute \u00b6 tld = tld instance-attribute \u00b6 tld_required = False class-attribute \u00b6 user_required = False class-attribute \u00b6 version = version instance-attribute \u00b6 __get_validators__ () classmethod \u00b6 Source code in oteapi_optimade/models/custom_types.py 170 171 172 @classmethod def __get_validators__ ( cls ) -> \"CallableGenerator\" : yield cls . validate __init__ ( url , * , base_url = None , version = None , endpoint = None , query = None , scheme = None , tld = None , host_type = 'domain' ) \u00b6 Source code in oteapi_optimade/models/custom_types.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def __init__ ( self , url : str , * , base_url : \"Optional[str]\" = None , version : \"Optional[str]\" = None , endpoint : \"Optional[str]\" = None , query : \"Optional[str]\" = None , scheme : \"Optional[str]\" = None , tld : \"Optional[str]\" = None , host_type : str = \"domain\" , ) -> None : str . __init__ ( url ) self . base_url = base_url self . version = version self . endpoint = endpoint self . query = query self . scheme = scheme self . tld = tld self . host_type = host_type __modify_schema__ ( field_schema ) classmethod \u00b6 Source code in oteapi_optimade/models/custom_types.py 161 162 163 164 165 166 167 168 @classmethod def __modify_schema__ ( cls , field_schema : \"Dict[str, Any]\" ) -> None : update_not_none ( field_schema , minLength = cls . min_length , maxLength = cls . max_length , format = \"uri\" , ) __new__ ( url = None , ** kwargs ) \u00b6 Source code in oteapi_optimade/models/custom_types.py 113 114 115 116 117 118 @no_type_check def __new__ ( cls , url : \"Optional[str]\" = None , ** kwargs ) -> object : return str . __new__ ( cls , cls . build ( ** kwargs ) if url is None else url , # pylint: disable=missing-kwoa ) __repr__ () \u00b6 Source code in oteapi_optimade/models/custom_types.py 359 360 361 362 363 364 365 def __repr__ ( self ) -> str : extra = \", \" . join ( f \" { n } = { getattr ( self , n ) !r} \" for n in self . __slots__ if getattr ( self , n ) is not None ) return f \" { self . __class__ . __name__ } ( { super () . __repr__ () } , { extra } )\" apply_default_parts ( parts ) classmethod \u00b6 Apply default URL-part values if no value is given. Source code in oteapi_optimade/models/custom_types.py 270 271 272 273 274 275 276 @classmethod def apply_default_parts ( cls , parts : \"Parts\" ) -> \"Parts\" : \"\"\"Apply default URL-part values if no value is given.\"\"\" for key , value in cls . get_default_parts ( parts ) . items (): if not parts [ key ]: # type: ignore[literal-required] parts [ key ] = value # type: ignore[literal-required] return parts build ( * , base_url , version = None , endpoint = None , query = None , ** _kwargs ) classmethod \u00b6 Build complete URL from URL parts. Source code in oteapi_optimade/models/custom_types.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 @classmethod def build ( cls , * , base_url : \"str\" , version : \"Optional[str]\" = None , endpoint : \"Optional[str]\" = None , query : \"Optional[str]\" = None , ** _kwargs : str , ) -> str : \"\"\"Build complete URL from URL parts.\"\"\" url = base_url . rstrip ( \"/\" ) if version : url += f \"/ { version } \" if endpoint : url += f \"/ { endpoint } \" if query : url += f \"? { query } \" return url build_optimade_parts ( parts , host ) classmethod \u00b6 Convert URL parts to equivalent OPTIMADE URL parts. Source code in oteapi_optimade/models/custom_types.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 @classmethod def build_optimade_parts ( cls , parts : \"Parts\" , host : str ) -> \"OPTIMADEParts\" : \"\"\"Convert URL parts to equivalent OPTIMADE URL parts.\"\"\" base_url = f \" { parts [ 'scheme' ] } ://\" if parts [ \"user\" ]: base_url += parts [ \"user\" ] if parts [ \"password\" ]: base_url += f \": { parts [ 'password' ] } \" if parts [ \"user\" ] or parts [ \"password\" ]: base_url += \"@\" base_url += host # Hide port if it's a standard HTTP (80) or HTTPS (443) port. if parts [ \"port\" ] and parts [ \"port\" ] not in ( \"80\" , \"443\" ): base_url += f \": { parts [ 'port' ] } \" if parts [ \"path\" ]: base_url += parts [ \"path\" ] base_url_match = optimade_base_url_regex () . fullmatch ( base_url ) LOGGER . debug ( \"OPTIMADE base URL regex match groups: %s \" , base_url_match . groupdict () if base_url_match else base_url_match , ) if base_url_match is None : raise ValueError ( \"Could not match given string with OPTIMADE base URL regex.\" ) endpoint_match = optimade_endpoint_regex () . findall ( base_url_match . group ( \"path\" ) if base_url_match . group ( \"path\" ) else \"\" ) LOGGER . debug ( \"OPTIMADE endpoint regex matches: %s \" , endpoint_match ) for path_version , path_endpoint in endpoint_match : if path_endpoint : break else : LOGGER . debug ( \"Could not match given string with OPTIMADE endpoint regex.\" ) path_version , path_endpoint = \"\" , \"\" base_url = base_url_match . group ( \"base_url\" ) if path_version : base_url = base_url [: - ( len ( path_version ) + len ( path_endpoint ) + 2 )] elif path_endpoint : base_url = base_url [: - ( len ( path_endpoint ) + 1 )] optimade_parts = { \"base_url\" : base_url . rstrip ( \"/\" ), \"version\" : path_version or None , \"endpoint\" : path_endpoint or None , \"query\" : parts [ \"query\" ], } return cast ( \"OPTIMADEParts\" , optimade_parts ) get_default_parts ( parts ) staticmethod \u00b6 Dictionary of default URL-part values. Source code in oteapi_optimade/models/custom_types.py 265 266 267 268 @staticmethod def get_default_parts ( parts : \"Parts\" ) -> \"Parts\" : \"\"\"Dictionary of default URL-part values.\"\"\" return { \"port\" : \"80\" if parts [ \"scheme\" ] == \"http\" else \"443\" } response_model () \u00b6 Return the endpoint's corresponding response model (from OPT). Source code in oteapi_optimade/models/custom_types.py 367 368 369 370 371 372 373 374 375 376 377 def response_model ( self ) -> \"Union[Tuple[Success, ...], Success, None]\" : \"\"\"Return the endpoint's corresponding response model (from OPT).\"\"\" if not self . endpoint or self . endpoint == \"versions\" : return None return { \"info\" : ( InfoResponse , EntryInfoResponse ), \"links\" : LinksResponse , \"structures\" : ( StructureResponseMany , StructureResponseOne ), \"references\" : ( ReferenceResponseMany , ReferenceResponseOne ), \"calculations\" : ( EntryResponseMany , EntryResponseOne ), } . get ( self . endpoint , Success ) urlquote_qs ( url ) staticmethod \u00b6 Use urllib.parse.quote for query part of URL. Source code in oteapi_optimade/models/custom_types.py 174 175 176 177 178 179 180 181 @staticmethod def urlquote_qs ( url : str ) -> str : \"\"\"Use `urllib.parse.quote` for query part of URL.\"\"\" parsed_url = urlparse ( url ) quoted_query = urlquote ( parsed_url . query , safe = \"=&,\" ) parsed_url_list = list ( parsed_url ) parsed_url_list [ - 2 ] = quoted_query return urlunparse ( parsed_url_list ) validate ( value , field , config ) classmethod \u00b6 Pydantic validation of an OPTIMADE URL. Source code in oteapi_optimade/models/custom_types.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 @classmethod def validate ( cls , value : \"Any\" , field : \"ModelField\" , config : \"BaseConfig\" ) -> \"OPTIMADEUrl\" : \"\"\"Pydantic validation of an OPTIMADE URL.\"\"\" if value . __class__ == cls : return value value : str = str_validator ( value ) if cls . strip_whitespace : value = value . strip () url : str = cast ( str , constr_length_validator ( value , field , config )) url = cls . urlquote_qs ( url ) url_match = url_regex () . match ( url ) if url_match is None : raise ValueError ( f \"Cannot match URL ( { url !r} ) as a valid URL.\" ) original_parts = cast ( \"Parts\" , url_match . groupdict ()) parts = cls . apply_default_parts ( original_parts ) host , tld , host_type , rebuild = cls . validate_host ( parts ) optimade_parts = cls . build_optimade_parts ( parts , host ) optimade_parts = cls . validate_parts ( parts , optimade_parts ) if url_match . end () != len ( url ): raise errors . UrlExtraError ( extra = url [ url_match . end () :]) return cls ( None if rebuild else url , base_url = optimade_parts [ \"base_url\" ], version = optimade_parts [ \"version\" ], endpoint = optimade_parts [ \"endpoint\" ], query = optimade_parts [ \"query\" ], scheme = parts [ \"scheme\" ], tld = tld , host_type = host_type , ) validate_host ( parts ) classmethod \u00b6 Validate host-part of the URL. Source code in oteapi_optimade/models/custom_types.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 @classmethod def validate_host ( cls , parts : \"Parts\" ) -> \"Tuple[str, Optional[str], str, bool]\" : \"\"\"Validate host-part of the URL.\"\"\" host : \"Optional[str]\" = None tld : \"Optional[str]\" = None rebuild : bool = False for host_type in ( \"domain\" , \"ipv4\" , \"ipv6\" ): host = parts [ host_type ] # type: ignore[literal-required] if host : break else : raise errors . UrlHostError () if host_type == \"domain\" : is_international = False domain = ascii_domain_regex () . fullmatch ( host ) if domain is None : domain = int_domain_regex () . fullmatch ( host ) if domain is None : raise errors . UrlHostError () is_international = True tld = domain . group ( \"tld\" ) if tld is None and not is_international : domain = int_domain_regex () . fullmatch ( host ) if domain is None : raise ValueError ( \"domain cannot be None\" ) tld = domain . group ( \"tld\" ) is_international = True if tld is not None : tld = tld [ 1 :] elif cls . tld_required : raise errors . UrlHostTldError () if is_international : host_type = \"int_domain\" rebuild = True host = host . encode ( \"idna\" ) . decode ( \"ascii\" ) if tld is not None : tld = tld . encode ( \"idna\" ) . decode ( \"ascii\" ) return host , tld , host_type , rebuild validate_parts ( parts , optimade_parts ) classmethod \u00b6 A method used to validate parts of an URL. Could be overridden to set default values for parts if missing Source code in oteapi_optimade/models/custom_types.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 @classmethod def validate_parts ( cls , parts : \"Parts\" , optimade_parts : \"OPTIMADEParts\" ) -> \"OPTIMADEParts\" : \"\"\" A method used to validate parts of an URL. Could be overridden to set default values for parts if missing \"\"\" scheme = parts [ \"scheme\" ] if scheme is None : raise errors . UrlSchemeError () if cls . allowed_schemes and scheme . lower () not in cls . allowed_schemes : raise errors . UrlSchemePermittedError ( set ( cls . allowed_schemes )) port = parts [ \"port\" ] if port is not None and int ( port ) > 65_535 : raise errors . UrlPortError () user = parts [ \"user\" ] if cls . user_required and user is None : raise errors . UrlUserInfoError () base_url = optimade_parts [ \"base_url\" ] if base_url is None : raise errors . UrlError () return optimade_parts optimade_base_url_regex () \u00b6 A regular expression for an OPTIMADE base URL. Source code in oteapi_optimade/models/custom_types.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def optimade_base_url_regex () -> \"Pattern[str]\" : \"\"\"A regular expression for an OPTIMADE base URL.\"\"\" global _OPTIMADE_BASE_URL_REGEX # pylint: disable=global-statement if _OPTIMADE_BASE_URL_REGEX is None : _OPTIMADE_BASE_URL_REGEX = re . compile ( r \"^(?P<base_url>\" # scheme https://tools.ietf.org/html/rfc3986#appendix-A r \"(?:[a-z][a-z0-9+\\-.]+://)?\" r \"(?:[^\\s:/]*(?::[^\\s/]*)?@)?\" # user info r \"(?:\" r \"(?:\\d{1,3}\\.) {3} \\d{1,3}(?=$|[/:#?])|\" # ipv4 r \"\\[[A-F0-9]*:[A-F0-9:]+\\](?=$|[/:#?])|\" # ipv6 r \"[^\\s/:?#]+\" # domain, validation occurs later r \")?\" r \"(?::\\d+)?\" # port r \"(?P<path>/[^\\s?#]*)?\" # path r \")\" , re . IGNORECASE , ) return _OPTIMADE_BASE_URL_REGEX optimade_endpoint_regex () \u00b6 A regular expression for an OPTIMADE base URL. Source code in oteapi_optimade/models/custom_types.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def optimade_endpoint_regex () -> \"Pattern[str]\" : \"\"\"A regular expression for an OPTIMADE base URL.\"\"\" global _OPTIMADE_ENDPOINT_REGEX # pylint: disable=global-statement if _OPTIMADE_ENDPOINT_REGEX is None : _OPTIMADE_ENDPOINT_REGEX = re . compile ( # version r \"(?:/(?P<version>v[0-9]+(?:\\.[0-9+]){0,2})\" r \"(?=/info|/links|/version|/structures|/references|/calculations\" r \"|/extensions))?\" # endpoint r \"(?:/(?P<endpoint>(?:info|links|versions|structures|references\" r \"|calculations|extensions)(?:/[^\\s?#]*)?))?$\" ) return _OPTIMADE_ENDPOINT_REGEX","title":"custom_types"},{"location":"api_reference/models/custom_types/#custom_types","text":"Custom \"pydantic\" types used in OTEAPI-OPTIMADE.","title":"custom_types"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.LOGGER","text":"","title":"LOGGER"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types._OPTIMADE_BASE_URL_REGEX","text":"","title":"_OPTIMADE_BASE_URL_REGEX"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types._OPTIMADE_ENDPOINT_REGEX","text":"","title":"_OPTIMADE_ENDPOINT_REGEX"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEParts","text":"Bases: TypedDict Similar to pydantic.networks.Parts . Source code in oteapi_optimade/models/custom_types.py 31 32 33 34 35 36 37 class OPTIMADEParts ( TypedDict , total = False ): \"\"\"Similar to `pydantic.networks.Parts`.\"\"\" base_url : str version : Optional [ str ] endpoint : Optional [ str ] query : Optional [ str ]","title":"OPTIMADEParts"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEParts.base_url","text":"","title":"base_url"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEParts.endpoint","text":"","title":"endpoint"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEParts.query","text":"","title":"query"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEParts.version","text":"","title":"version"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl","text":"Bases: str A deconstructed OPTIMADE URL. An OPTIMADE URL is made up in the following way /[ /] ? Where parts in square brackets ( [] ) are optional. Source code in oteapi_optimade/models/custom_types.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 class OPTIMADEUrl ( str ): \"\"\"A deconstructed OPTIMADE URL. An OPTIMADE URL is made up in the following way: <BASE URL>/[<VERSION>/]<ENDPOINT>?<QUERY PARAMETERS> Where parts in square brackets (`[]`) are optional. \"\"\" strip_whitespace = True min_length = 1 # https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers # pylint: disable=line-too-long max_length = 2083 allowed_schemes = { \"http\" , \"https\" } tld_required = False user_required = False __slots__ = ( \"base_url\" , \"version\" , \"endpoint\" , \"query\" , \"scheme\" , \"tld\" , \"host_type\" , ) @no_type_check def __new__ ( cls , url : \"Optional[str]\" = None , ** kwargs ) -> object : return str . __new__ ( cls , cls . build ( ** kwargs ) if url is None else url , # pylint: disable=missing-kwoa ) def __init__ ( self , url : str , * , base_url : \"Optional[str]\" = None , version : \"Optional[str]\" = None , endpoint : \"Optional[str]\" = None , query : \"Optional[str]\" = None , scheme : \"Optional[str]\" = None , tld : \"Optional[str]\" = None , host_type : str = \"domain\" , ) -> None : str . __init__ ( url ) self . base_url = base_url self . version = version self . endpoint = endpoint self . query = query self . scheme = scheme self . tld = tld self . host_type = host_type @classmethod def build ( cls , * , base_url : \"str\" , version : \"Optional[str]\" = None , endpoint : \"Optional[str]\" = None , query : \"Optional[str]\" = None , ** _kwargs : str , ) -> str : \"\"\"Build complete URL from URL parts.\"\"\" url = base_url . rstrip ( \"/\" ) if version : url += f \"/ { version } \" if endpoint : url += f \"/ { endpoint } \" if query : url += f \"? { query } \" return url @classmethod def __modify_schema__ ( cls , field_schema : \"Dict[str, Any]\" ) -> None : update_not_none ( field_schema , minLength = cls . min_length , maxLength = cls . max_length , format = \"uri\" , ) @classmethod def __get_validators__ ( cls ) -> \"CallableGenerator\" : yield cls . validate @staticmethod def urlquote_qs ( url : str ) -> str : \"\"\"Use `urllib.parse.quote` for query part of URL.\"\"\" parsed_url = urlparse ( url ) quoted_query = urlquote ( parsed_url . query , safe = \"=&,\" ) parsed_url_list = list ( parsed_url ) parsed_url_list [ - 2 ] = quoted_query return urlunparse ( parsed_url_list ) @classmethod def validate ( cls , value : \"Any\" , field : \"ModelField\" , config : \"BaseConfig\" ) -> \"OPTIMADEUrl\" : \"\"\"Pydantic validation of an OPTIMADE URL.\"\"\" if value . __class__ == cls : return value value : str = str_validator ( value ) if cls . strip_whitespace : value = value . strip () url : str = cast ( str , constr_length_validator ( value , field , config )) url = cls . urlquote_qs ( url ) url_match = url_regex () . match ( url ) if url_match is None : raise ValueError ( f \"Cannot match URL ( { url !r} ) as a valid URL.\" ) original_parts = cast ( \"Parts\" , url_match . groupdict ()) parts = cls . apply_default_parts ( original_parts ) host , tld , host_type , rebuild = cls . validate_host ( parts ) optimade_parts = cls . build_optimade_parts ( parts , host ) optimade_parts = cls . validate_parts ( parts , optimade_parts ) if url_match . end () != len ( url ): raise errors . UrlExtraError ( extra = url [ url_match . end () :]) return cls ( None if rebuild else url , base_url = optimade_parts [ \"base_url\" ], version = optimade_parts [ \"version\" ], endpoint = optimade_parts [ \"endpoint\" ], query = optimade_parts [ \"query\" ], scheme = parts [ \"scheme\" ], tld = tld , host_type = host_type , ) @classmethod def validate_host ( cls , parts : \"Parts\" ) -> \"Tuple[str, Optional[str], str, bool]\" : \"\"\"Validate host-part of the URL.\"\"\" host : \"Optional[str]\" = None tld : \"Optional[str]\" = None rebuild : bool = False for host_type in ( \"domain\" , \"ipv4\" , \"ipv6\" ): host = parts [ host_type ] # type: ignore[literal-required] if host : break else : raise errors . UrlHostError () if host_type == \"domain\" : is_international = False domain = ascii_domain_regex () . fullmatch ( host ) if domain is None : domain = int_domain_regex () . fullmatch ( host ) if domain is None : raise errors . UrlHostError () is_international = True tld = domain . group ( \"tld\" ) if tld is None and not is_international : domain = int_domain_regex () . fullmatch ( host ) if domain is None : raise ValueError ( \"domain cannot be None\" ) tld = domain . group ( \"tld\" ) is_international = True if tld is not None : tld = tld [ 1 :] elif cls . tld_required : raise errors . UrlHostTldError () if is_international : host_type = \"int_domain\" rebuild = True host = host . encode ( \"idna\" ) . decode ( \"ascii\" ) if tld is not None : tld = tld . encode ( \"idna\" ) . decode ( \"ascii\" ) return host , tld , host_type , rebuild @staticmethod def get_default_parts ( parts : \"Parts\" ) -> \"Parts\" : \"\"\"Dictionary of default URL-part values.\"\"\" return { \"port\" : \"80\" if parts [ \"scheme\" ] == \"http\" else \"443\" } @classmethod def apply_default_parts ( cls , parts : \"Parts\" ) -> \"Parts\" : \"\"\"Apply default URL-part values if no value is given.\"\"\" for key , value in cls . get_default_parts ( parts ) . items (): if not parts [ key ]: # type: ignore[literal-required] parts [ key ] = value # type: ignore[literal-required] return parts @classmethod def build_optimade_parts ( cls , parts : \"Parts\" , host : str ) -> \"OPTIMADEParts\" : \"\"\"Convert URL parts to equivalent OPTIMADE URL parts.\"\"\" base_url = f \" { parts [ 'scheme' ] } ://\" if parts [ \"user\" ]: base_url += parts [ \"user\" ] if parts [ \"password\" ]: base_url += f \": { parts [ 'password' ] } \" if parts [ \"user\" ] or parts [ \"password\" ]: base_url += \"@\" base_url += host # Hide port if it's a standard HTTP (80) or HTTPS (443) port. if parts [ \"port\" ] and parts [ \"port\" ] not in ( \"80\" , \"443\" ): base_url += f \": { parts [ 'port' ] } \" if parts [ \"path\" ]: base_url += parts [ \"path\" ] base_url_match = optimade_base_url_regex () . fullmatch ( base_url ) LOGGER . debug ( \"OPTIMADE base URL regex match groups: %s \" , base_url_match . groupdict () if base_url_match else base_url_match , ) if base_url_match is None : raise ValueError ( \"Could not match given string with OPTIMADE base URL regex.\" ) endpoint_match = optimade_endpoint_regex () . findall ( base_url_match . group ( \"path\" ) if base_url_match . group ( \"path\" ) else \"\" ) LOGGER . debug ( \"OPTIMADE endpoint regex matches: %s \" , endpoint_match ) for path_version , path_endpoint in endpoint_match : if path_endpoint : break else : LOGGER . debug ( \"Could not match given string with OPTIMADE endpoint regex.\" ) path_version , path_endpoint = \"\" , \"\" base_url = base_url_match . group ( \"base_url\" ) if path_version : base_url = base_url [: - ( len ( path_version ) + len ( path_endpoint ) + 2 )] elif path_endpoint : base_url = base_url [: - ( len ( path_endpoint ) + 1 )] optimade_parts = { \"base_url\" : base_url . rstrip ( \"/\" ), \"version\" : path_version or None , \"endpoint\" : path_endpoint or None , \"query\" : parts [ \"query\" ], } return cast ( \"OPTIMADEParts\" , optimade_parts ) @classmethod def validate_parts ( cls , parts : \"Parts\" , optimade_parts : \"OPTIMADEParts\" ) -> \"OPTIMADEParts\" : \"\"\" A method used to validate parts of an URL. Could be overridden to set default values for parts if missing \"\"\" scheme = parts [ \"scheme\" ] if scheme is None : raise errors . UrlSchemeError () if cls . allowed_schemes and scheme . lower () not in cls . allowed_schemes : raise errors . UrlSchemePermittedError ( set ( cls . allowed_schemes )) port = parts [ \"port\" ] if port is not None and int ( port ) > 65_535 : raise errors . UrlPortError () user = parts [ \"user\" ] if cls . user_required and user is None : raise errors . UrlUserInfoError () base_url = optimade_parts [ \"base_url\" ] if base_url is None : raise errors . UrlError () return optimade_parts def __repr__ ( self ) -> str : extra = \", \" . join ( f \" { n } = { getattr ( self , n ) !r} \" for n in self . __slots__ if getattr ( self , n ) is not None ) return f \" { self . __class__ . __name__ } ( { super () . __repr__ () } , { extra } )\" def response_model ( self ) -> \"Union[Tuple[Success, ...], Success, None]\" : \"\"\"Return the endpoint's corresponding response model (from OPT).\"\"\" if not self . endpoint or self . endpoint == \"versions\" : return None return { \"info\" : ( InfoResponse , EntryInfoResponse ), \"links\" : LinksResponse , \"structures\" : ( StructureResponseMany , StructureResponseOne ), \"references\" : ( ReferenceResponseMany , ReferenceResponseOne ), \"calculations\" : ( EntryResponseMany , EntryResponseOne ), } . get ( self . endpoint , Success )","title":"OPTIMADEUrl"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.__slots__","text":"","title":"__slots__"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.allowed_schemes","text":"","title":"allowed_schemes"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.base_url","text":"","title":"base_url"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.endpoint","text":"","title":"endpoint"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.host_type","text":"","title":"host_type"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.max_length","text":"","title":"max_length"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.min_length","text":"","title":"min_length"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.query","text":"","title":"query"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.scheme","text":"","title":"scheme"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.strip_whitespace","text":"","title":"strip_whitespace"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.tld","text":"","title":"tld"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.tld_required","text":"","title":"tld_required"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.user_required","text":"","title":"user_required"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.version","text":"","title":"version"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.__get_validators__","text":"Source code in oteapi_optimade/models/custom_types.py 170 171 172 @classmethod def __get_validators__ ( cls ) -> \"CallableGenerator\" : yield cls . validate","title":"__get_validators__()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.__init__","text":"Source code in oteapi_optimade/models/custom_types.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def __init__ ( self , url : str , * , base_url : \"Optional[str]\" = None , version : \"Optional[str]\" = None , endpoint : \"Optional[str]\" = None , query : \"Optional[str]\" = None , scheme : \"Optional[str]\" = None , tld : \"Optional[str]\" = None , host_type : str = \"domain\" , ) -> None : str . __init__ ( url ) self . base_url = base_url self . version = version self . endpoint = endpoint self . query = query self . scheme = scheme self . tld = tld self . host_type = host_type","title":"__init__()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.__modify_schema__","text":"Source code in oteapi_optimade/models/custom_types.py 161 162 163 164 165 166 167 168 @classmethod def __modify_schema__ ( cls , field_schema : \"Dict[str, Any]\" ) -> None : update_not_none ( field_schema , minLength = cls . min_length , maxLength = cls . max_length , format = \"uri\" , )","title":"__modify_schema__()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.__new__","text":"Source code in oteapi_optimade/models/custom_types.py 113 114 115 116 117 118 @no_type_check def __new__ ( cls , url : \"Optional[str]\" = None , ** kwargs ) -> object : return str . __new__ ( cls , cls . build ( ** kwargs ) if url is None else url , # pylint: disable=missing-kwoa )","title":"__new__()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.__repr__","text":"Source code in oteapi_optimade/models/custom_types.py 359 360 361 362 363 364 365 def __repr__ ( self ) -> str : extra = \", \" . join ( f \" { n } = { getattr ( self , n ) !r} \" for n in self . __slots__ if getattr ( self , n ) is not None ) return f \" { self . __class__ . __name__ } ( { super () . __repr__ () } , { extra } )\"","title":"__repr__()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.apply_default_parts","text":"Apply default URL-part values if no value is given. Source code in oteapi_optimade/models/custom_types.py 270 271 272 273 274 275 276 @classmethod def apply_default_parts ( cls , parts : \"Parts\" ) -> \"Parts\" : \"\"\"Apply default URL-part values if no value is given.\"\"\" for key , value in cls . get_default_parts ( parts ) . items (): if not parts [ key ]: # type: ignore[literal-required] parts [ key ] = value # type: ignore[literal-required] return parts","title":"apply_default_parts()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.build","text":"Build complete URL from URL parts. Source code in oteapi_optimade/models/custom_types.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 @classmethod def build ( cls , * , base_url : \"str\" , version : \"Optional[str]\" = None , endpoint : \"Optional[str]\" = None , query : \"Optional[str]\" = None , ** _kwargs : str , ) -> str : \"\"\"Build complete URL from URL parts.\"\"\" url = base_url . rstrip ( \"/\" ) if version : url += f \"/ { version } \" if endpoint : url += f \"/ { endpoint } \" if query : url += f \"? { query } \" return url","title":"build()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.build_optimade_parts","text":"Convert URL parts to equivalent OPTIMADE URL parts. Source code in oteapi_optimade/models/custom_types.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 @classmethod def build_optimade_parts ( cls , parts : \"Parts\" , host : str ) -> \"OPTIMADEParts\" : \"\"\"Convert URL parts to equivalent OPTIMADE URL parts.\"\"\" base_url = f \" { parts [ 'scheme' ] } ://\" if parts [ \"user\" ]: base_url += parts [ \"user\" ] if parts [ \"password\" ]: base_url += f \": { parts [ 'password' ] } \" if parts [ \"user\" ] or parts [ \"password\" ]: base_url += \"@\" base_url += host # Hide port if it's a standard HTTP (80) or HTTPS (443) port. if parts [ \"port\" ] and parts [ \"port\" ] not in ( \"80\" , \"443\" ): base_url += f \": { parts [ 'port' ] } \" if parts [ \"path\" ]: base_url += parts [ \"path\" ] base_url_match = optimade_base_url_regex () . fullmatch ( base_url ) LOGGER . debug ( \"OPTIMADE base URL regex match groups: %s \" , base_url_match . groupdict () if base_url_match else base_url_match , ) if base_url_match is None : raise ValueError ( \"Could not match given string with OPTIMADE base URL regex.\" ) endpoint_match = optimade_endpoint_regex () . findall ( base_url_match . group ( \"path\" ) if base_url_match . group ( \"path\" ) else \"\" ) LOGGER . debug ( \"OPTIMADE endpoint regex matches: %s \" , endpoint_match ) for path_version , path_endpoint in endpoint_match : if path_endpoint : break else : LOGGER . debug ( \"Could not match given string with OPTIMADE endpoint regex.\" ) path_version , path_endpoint = \"\" , \"\" base_url = base_url_match . group ( \"base_url\" ) if path_version : base_url = base_url [: - ( len ( path_version ) + len ( path_endpoint ) + 2 )] elif path_endpoint : base_url = base_url [: - ( len ( path_endpoint ) + 1 )] optimade_parts = { \"base_url\" : base_url . rstrip ( \"/\" ), \"version\" : path_version or None , \"endpoint\" : path_endpoint or None , \"query\" : parts [ \"query\" ], } return cast ( \"OPTIMADEParts\" , optimade_parts )","title":"build_optimade_parts()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.get_default_parts","text":"Dictionary of default URL-part values. Source code in oteapi_optimade/models/custom_types.py 265 266 267 268 @staticmethod def get_default_parts ( parts : \"Parts\" ) -> \"Parts\" : \"\"\"Dictionary of default URL-part values.\"\"\" return { \"port\" : \"80\" if parts [ \"scheme\" ] == \"http\" else \"443\" }","title":"get_default_parts()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.response_model","text":"Return the endpoint's corresponding response model (from OPT). Source code in oteapi_optimade/models/custom_types.py 367 368 369 370 371 372 373 374 375 376 377 def response_model ( self ) -> \"Union[Tuple[Success, ...], Success, None]\" : \"\"\"Return the endpoint's corresponding response model (from OPT).\"\"\" if not self . endpoint or self . endpoint == \"versions\" : return None return { \"info\" : ( InfoResponse , EntryInfoResponse ), \"links\" : LinksResponse , \"structures\" : ( StructureResponseMany , StructureResponseOne ), \"references\" : ( ReferenceResponseMany , ReferenceResponseOne ), \"calculations\" : ( EntryResponseMany , EntryResponseOne ), } . get ( self . endpoint , Success )","title":"response_model()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.urlquote_qs","text":"Use urllib.parse.quote for query part of URL. Source code in oteapi_optimade/models/custom_types.py 174 175 176 177 178 179 180 181 @staticmethod def urlquote_qs ( url : str ) -> str : \"\"\"Use `urllib.parse.quote` for query part of URL.\"\"\" parsed_url = urlparse ( url ) quoted_query = urlquote ( parsed_url . query , safe = \"=&,\" ) parsed_url_list = list ( parsed_url ) parsed_url_list [ - 2 ] = quoted_query return urlunparse ( parsed_url_list )","title":"urlquote_qs()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.validate","text":"Pydantic validation of an OPTIMADE URL. Source code in oteapi_optimade/models/custom_types.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 @classmethod def validate ( cls , value : \"Any\" , field : \"ModelField\" , config : \"BaseConfig\" ) -> \"OPTIMADEUrl\" : \"\"\"Pydantic validation of an OPTIMADE URL.\"\"\" if value . __class__ == cls : return value value : str = str_validator ( value ) if cls . strip_whitespace : value = value . strip () url : str = cast ( str , constr_length_validator ( value , field , config )) url = cls . urlquote_qs ( url ) url_match = url_regex () . match ( url ) if url_match is None : raise ValueError ( f \"Cannot match URL ( { url !r} ) as a valid URL.\" ) original_parts = cast ( \"Parts\" , url_match . groupdict ()) parts = cls . apply_default_parts ( original_parts ) host , tld , host_type , rebuild = cls . validate_host ( parts ) optimade_parts = cls . build_optimade_parts ( parts , host ) optimade_parts = cls . validate_parts ( parts , optimade_parts ) if url_match . end () != len ( url ): raise errors . UrlExtraError ( extra = url [ url_match . end () :]) return cls ( None if rebuild else url , base_url = optimade_parts [ \"base_url\" ], version = optimade_parts [ \"version\" ], endpoint = optimade_parts [ \"endpoint\" ], query = optimade_parts [ \"query\" ], scheme = parts [ \"scheme\" ], tld = tld , host_type = host_type , )","title":"validate()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.validate_host","text":"Validate host-part of the URL. Source code in oteapi_optimade/models/custom_types.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 @classmethod def validate_host ( cls , parts : \"Parts\" ) -> \"Tuple[str, Optional[str], str, bool]\" : \"\"\"Validate host-part of the URL.\"\"\" host : \"Optional[str]\" = None tld : \"Optional[str]\" = None rebuild : bool = False for host_type in ( \"domain\" , \"ipv4\" , \"ipv6\" ): host = parts [ host_type ] # type: ignore[literal-required] if host : break else : raise errors . UrlHostError () if host_type == \"domain\" : is_international = False domain = ascii_domain_regex () . fullmatch ( host ) if domain is None : domain = int_domain_regex () . fullmatch ( host ) if domain is None : raise errors . UrlHostError () is_international = True tld = domain . group ( \"tld\" ) if tld is None and not is_international : domain = int_domain_regex () . fullmatch ( host ) if domain is None : raise ValueError ( \"domain cannot be None\" ) tld = domain . group ( \"tld\" ) is_international = True if tld is not None : tld = tld [ 1 :] elif cls . tld_required : raise errors . UrlHostTldError () if is_international : host_type = \"int_domain\" rebuild = True host = host . encode ( \"idna\" ) . decode ( \"ascii\" ) if tld is not None : tld = tld . encode ( \"idna\" ) . decode ( \"ascii\" ) return host , tld , host_type , rebuild","title":"validate_host()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.validate_parts","text":"A method used to validate parts of an URL. Could be overridden to set default values for parts if missing Source code in oteapi_optimade/models/custom_types.py 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 @classmethod def validate_parts ( cls , parts : \"Parts\" , optimade_parts : \"OPTIMADEParts\" ) -> \"OPTIMADEParts\" : \"\"\" A method used to validate parts of an URL. Could be overridden to set default values for parts if missing \"\"\" scheme = parts [ \"scheme\" ] if scheme is None : raise errors . UrlSchemeError () if cls . allowed_schemes and scheme . lower () not in cls . allowed_schemes : raise errors . UrlSchemePermittedError ( set ( cls . allowed_schemes )) port = parts [ \"port\" ] if port is not None and int ( port ) > 65_535 : raise errors . UrlPortError () user = parts [ \"user\" ] if cls . user_required and user is None : raise errors . UrlUserInfoError () base_url = optimade_parts [ \"base_url\" ] if base_url is None : raise errors . UrlError () return optimade_parts","title":"validate_parts()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.optimade_base_url_regex","text":"A regular expression for an OPTIMADE base URL. Source code in oteapi_optimade/models/custom_types.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def optimade_base_url_regex () -> \"Pattern[str]\" : \"\"\"A regular expression for an OPTIMADE base URL.\"\"\" global _OPTIMADE_BASE_URL_REGEX # pylint: disable=global-statement if _OPTIMADE_BASE_URL_REGEX is None : _OPTIMADE_BASE_URL_REGEX = re . compile ( r \"^(?P<base_url>\" # scheme https://tools.ietf.org/html/rfc3986#appendix-A r \"(?:[a-z][a-z0-9+\\-.]+://)?\" r \"(?:[^\\s:/]*(?::[^\\s/]*)?@)?\" # user info r \"(?:\" r \"(?:\\d{1,3}\\.) {3} \\d{1,3}(?=$|[/:#?])|\" # ipv4 r \"\\[[A-F0-9]*:[A-F0-9:]+\\](?=$|[/:#?])|\" # ipv6 r \"[^\\s/:?#]+\" # domain, validation occurs later r \")?\" r \"(?::\\d+)?\" # port r \"(?P<path>/[^\\s?#]*)?\" # path r \")\" , re . IGNORECASE , ) return _OPTIMADE_BASE_URL_REGEX","title":"optimade_base_url_regex()"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.optimade_endpoint_regex","text":"A regular expression for an OPTIMADE base URL. Source code in oteapi_optimade/models/custom_types.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def optimade_endpoint_regex () -> \"Pattern[str]\" : \"\"\"A regular expression for an OPTIMADE base URL.\"\"\" global _OPTIMADE_ENDPOINT_REGEX # pylint: disable=global-statement if _OPTIMADE_ENDPOINT_REGEX is None : _OPTIMADE_ENDPOINT_REGEX = re . compile ( # version r \"(?:/(?P<version>v[0-9]+(?:\\.[0-9+]){0,2})\" r \"(?=/info|/links|/version|/structures|/references|/calculations\" r \"|/extensions))?\" # endpoint r \"(?:/(?P<endpoint>(?:info|links|versions|structures|references\" r \"|calculations|extensions)(?:/[^\\s?#]*)?))?$\" ) return _OPTIMADE_ENDPOINT_REGEX","title":"optimade_endpoint_regex()"},{"location":"api_reference/models/query/","text":"query \u00b6 Data models related to OPTIMADE queries. QUERY_PARAMETERS = EntryListingQueryParams () module-attribute \u00b6 Entry listing URL query parameters from the optimade package ( EntryListingQueryParams ). OPTIMADEQueryParameters \u00b6 Bases: BaseModel Common OPTIMADE entry listing endpoint query parameters. Source code in oteapi_optimade/models/query.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class OPTIMADEQueryParameters ( BaseModel , validate_assignment = True ): \"\"\"Common OPTIMADE entry listing endpoint query parameters.\"\"\" filter : Optional [ str ] = Field ( QUERY_PARAMETERS . filter . default , description = QUERY_PARAMETERS . filter . description , ) response_format : Optional [ str ] = Field ( QUERY_PARAMETERS . response_format . default , description = QUERY_PARAMETERS . response_format . description , ) email_address : Optional [ EmailStr ] = Field ( QUERY_PARAMETERS . email_address . default , description = QUERY_PARAMETERS . email_address . description , ) response_fields : Optional [ str ] = Field ( QUERY_PARAMETERS . response_fields . default , description = QUERY_PARAMETERS . response_fields . description , regex = QUERY_PARAMETERS . response_fields . regex , ) sort : Optional [ str ] = Field ( QUERY_PARAMETERS . sort . default , description = QUERY_PARAMETERS . sort . description , regex = QUERY_PARAMETERS . sort . regex , ) page_limit : Optional [ int ] = Field ( QUERY_PARAMETERS . page_limit . default , description = QUERY_PARAMETERS . page_limit . description , ge = QUERY_PARAMETERS . page_limit . ge , ) page_offset : Optional [ int ] = Field ( QUERY_PARAMETERS . page_offset . default , description = QUERY_PARAMETERS . page_offset . description , ge = QUERY_PARAMETERS . page_offset . ge , ) page_number : Optional [ int ] = Field ( QUERY_PARAMETERS . page_number . default , description = QUERY_PARAMETERS . page_number . description , ge = QUERY_PARAMETERS . page_number . ge , ) page_cursor : Optional [ int ] = Field ( QUERY_PARAMETERS . page_cursor . default , description = QUERY_PARAMETERS . page_cursor . description , ge = QUERY_PARAMETERS . page_cursor . ge , ) page_above : Optional [ int ] = Field ( QUERY_PARAMETERS . page_above . default , description = QUERY_PARAMETERS . page_above . description , ge = QUERY_PARAMETERS . page_above . ge , ) page_below : Optional [ int ] = Field ( QUERY_PARAMETERS . page_below . default , description = QUERY_PARAMETERS . page_below . description , ge = QUERY_PARAMETERS . page_below . ge , ) include : Optional [ str ] = Field ( QUERY_PARAMETERS . include . default , description = QUERY_PARAMETERS . include . description , ) # api_hint is not yet initialized in `EntryListingQueryParams`. # These values are copied verbatim from `optimade==0.16.10`. api_hint : Optional [ str ] = Field ( \"\" , description = ( \"If the client provides the parameter, the value SHOULD have the format \" \"`vMAJOR` or `vMAJOR.MINOR`, where MAJOR is a major version and MINOR is a\" \" minor version of the API. For example, if a client appends \" \"`api_hint=v1.0` to the query string, the hint provided is for major \" \"version 1 and minor version 0.\" ), regex = r \"(v[0-9]+(\\.[0-9]+)?)?\" , ) def generate_query_string ( self ) -> str : \"\"\"Generate a valid URL query string based on the set fields.\"\"\" res = {} for field , value in self . dict () . items (): if ( value or field in self . __fields_set__ # pylint: disable=unsupported-membership-test ): res [ field ] = unquote ( value ) if isinstance ( value , str ) else value return urlencode ( res , quote_via = quote ) api_hint : Optional [ str ] = Field ( '' , description = 'If the client provides the parameter, the value SHOULD have the format `vMAJOR` or `vMAJOR.MINOR`, where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends `api_hint=v1.0` to the query string, the hint provided is for major version 1 and minor version 0.' , regex = '(v[0-9]+( \\\\ .[0-9]+)?)?' ) class-attribute \u00b6 email_address : Optional [ EmailStr ] = Field ( QUERY_PARAMETERS . email_address . default , description = QUERY_PARAMETERS . email_address . description ) class-attribute \u00b6 filter : Optional [ str ] = Field ( QUERY_PARAMETERS . filter . default , description = QUERY_PARAMETERS . filter . description ) class-attribute \u00b6 include : Optional [ str ] = Field ( QUERY_PARAMETERS . include . default , description = QUERY_PARAMETERS . include . description ) class-attribute \u00b6 page_above : Optional [ int ] = Field ( QUERY_PARAMETERS . page_above . default , description = QUERY_PARAMETERS . page_above . description , ge = QUERY_PARAMETERS . page_above . ge ) class-attribute \u00b6 page_below : Optional [ int ] = Field ( QUERY_PARAMETERS . page_below . default , description = QUERY_PARAMETERS . page_below . description , ge = QUERY_PARAMETERS . page_below . ge ) class-attribute \u00b6 page_cursor : Optional [ int ] = Field ( QUERY_PARAMETERS . page_cursor . default , description = QUERY_PARAMETERS . page_cursor . description , ge = QUERY_PARAMETERS . page_cursor . ge ) class-attribute \u00b6 page_limit : Optional [ int ] = Field ( QUERY_PARAMETERS . page_limit . default , description = QUERY_PARAMETERS . page_limit . description , ge = QUERY_PARAMETERS . page_limit . ge ) class-attribute \u00b6 page_number : Optional [ int ] = Field ( QUERY_PARAMETERS . page_number . default , description = QUERY_PARAMETERS . page_number . description , ge = QUERY_PARAMETERS . page_number . ge ) class-attribute \u00b6 page_offset : Optional [ int ] = Field ( QUERY_PARAMETERS . page_offset . default , description = QUERY_PARAMETERS . page_offset . description , ge = QUERY_PARAMETERS . page_offset . ge ) class-attribute \u00b6 response_fields : Optional [ str ] = Field ( QUERY_PARAMETERS . response_fields . default , description = QUERY_PARAMETERS . response_fields . description , regex = QUERY_PARAMETERS . response_fields . regex ) class-attribute \u00b6 response_format : Optional [ str ] = Field ( QUERY_PARAMETERS . response_format . default , description = QUERY_PARAMETERS . response_format . description ) class-attribute \u00b6 sort : Optional [ str ] = Field ( QUERY_PARAMETERS . sort . default , description = QUERY_PARAMETERS . sort . description , regex = QUERY_PARAMETERS . sort . regex ) class-attribute \u00b6 generate_query_string () \u00b6 Generate a valid URL query string based on the set fields. Source code in oteapi_optimade/models/query.py 86 87 88 89 90 91 92 93 94 95 96 def generate_query_string ( self ) -> str : \"\"\"Generate a valid URL query string based on the set fields.\"\"\" res = {} for field , value in self . dict () . items (): if ( value or field in self . __fields_set__ # pylint: disable=unsupported-membership-test ): res [ field ] = unquote ( value ) if isinstance ( value , str ) else value return urlencode ( res , quote_via = quote )","title":"query"},{"location":"api_reference/models/query/#query","text":"Data models related to OPTIMADE queries.","title":"query"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.QUERY_PARAMETERS","text":"Entry listing URL query parameters from the optimade package ( EntryListingQueryParams ).","title":"QUERY_PARAMETERS"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters","text":"Bases: BaseModel Common OPTIMADE entry listing endpoint query parameters. Source code in oteapi_optimade/models/query.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class OPTIMADEQueryParameters ( BaseModel , validate_assignment = True ): \"\"\"Common OPTIMADE entry listing endpoint query parameters.\"\"\" filter : Optional [ str ] = Field ( QUERY_PARAMETERS . filter . default , description = QUERY_PARAMETERS . filter . description , ) response_format : Optional [ str ] = Field ( QUERY_PARAMETERS . response_format . default , description = QUERY_PARAMETERS . response_format . description , ) email_address : Optional [ EmailStr ] = Field ( QUERY_PARAMETERS . email_address . default , description = QUERY_PARAMETERS . email_address . description , ) response_fields : Optional [ str ] = Field ( QUERY_PARAMETERS . response_fields . default , description = QUERY_PARAMETERS . response_fields . description , regex = QUERY_PARAMETERS . response_fields . regex , ) sort : Optional [ str ] = Field ( QUERY_PARAMETERS . sort . default , description = QUERY_PARAMETERS . sort . description , regex = QUERY_PARAMETERS . sort . regex , ) page_limit : Optional [ int ] = Field ( QUERY_PARAMETERS . page_limit . default , description = QUERY_PARAMETERS . page_limit . description , ge = QUERY_PARAMETERS . page_limit . ge , ) page_offset : Optional [ int ] = Field ( QUERY_PARAMETERS . page_offset . default , description = QUERY_PARAMETERS . page_offset . description , ge = QUERY_PARAMETERS . page_offset . ge , ) page_number : Optional [ int ] = Field ( QUERY_PARAMETERS . page_number . default , description = QUERY_PARAMETERS . page_number . description , ge = QUERY_PARAMETERS . page_number . ge , ) page_cursor : Optional [ int ] = Field ( QUERY_PARAMETERS . page_cursor . default , description = QUERY_PARAMETERS . page_cursor . description , ge = QUERY_PARAMETERS . page_cursor . ge , ) page_above : Optional [ int ] = Field ( QUERY_PARAMETERS . page_above . default , description = QUERY_PARAMETERS . page_above . description , ge = QUERY_PARAMETERS . page_above . ge , ) page_below : Optional [ int ] = Field ( QUERY_PARAMETERS . page_below . default , description = QUERY_PARAMETERS . page_below . description , ge = QUERY_PARAMETERS . page_below . ge , ) include : Optional [ str ] = Field ( QUERY_PARAMETERS . include . default , description = QUERY_PARAMETERS . include . description , ) # api_hint is not yet initialized in `EntryListingQueryParams`. # These values are copied verbatim from `optimade==0.16.10`. api_hint : Optional [ str ] = Field ( \"\" , description = ( \"If the client provides the parameter, the value SHOULD have the format \" \"`vMAJOR` or `vMAJOR.MINOR`, where MAJOR is a major version and MINOR is a\" \" minor version of the API. For example, if a client appends \" \"`api_hint=v1.0` to the query string, the hint provided is for major \" \"version 1 and minor version 0.\" ), regex = r \"(v[0-9]+(\\.[0-9]+)?)?\" , ) def generate_query_string ( self ) -> str : \"\"\"Generate a valid URL query string based on the set fields.\"\"\" res = {} for field , value in self . dict () . items (): if ( value or field in self . __fields_set__ # pylint: disable=unsupported-membership-test ): res [ field ] = unquote ( value ) if isinstance ( value , str ) else value return urlencode ( res , quote_via = quote )","title":"OPTIMADEQueryParameters"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.api_hint","text":"","title":"api_hint"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.email_address","text":"","title":"email_address"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.filter","text":"","title":"filter"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.include","text":"","title":"include"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_above","text":"","title":"page_above"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_below","text":"","title":"page_below"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_cursor","text":"","title":"page_cursor"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_limit","text":"","title":"page_limit"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_number","text":"","title":"page_number"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_offset","text":"","title":"page_offset"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.response_fields","text":"","title":"response_fields"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.response_format","text":"","title":"response_format"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.sort","text":"","title":"sort"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.generate_query_string","text":"Generate a valid URL query string based on the set fields. Source code in oteapi_optimade/models/query.py 86 87 88 89 90 91 92 93 94 95 96 def generate_query_string ( self ) -> str : \"\"\"Generate a valid URL query string based on the set fields.\"\"\" res = {} for field , value in self . dict () . items (): if ( value or field in self . __fields_set__ # pylint: disable=unsupported-membership-test ): res [ field ] = unquote ( value ) if isinstance ( value , str ) else value return urlencode ( res , quote_via = quote )","title":"generate_query_string()"},{"location":"api_reference/models/strategies/filter/","text":"filter \u00b6 Models specific to the filter strategy. OPTIMADEFilterConfig \u00b6 Bases: FilterConfig OPTIMADE-specific filter strategy config. Note The condition parameter is not taken into account. Source code in oteapi_optimade/models/strategies/filter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class OPTIMADEFilterConfig ( FilterConfig ): \"\"\"OPTIMADE-specific filter strategy config. Note: The `condition` parameter is not taken into account. \"\"\" filterType : Literal [ \"optimade\" , \"OPTIMADE\" , \"OPTiMaDe\" ] = Field ( ... , description = \"The registered strategy name for OPTIMADEFilterStrategy.\" , ) query : Optional [ str ] = Field ( None , description = ( \"The `filter` OPTIMADE query parameter value. This parameter value can \" \"also be provided through the [`configuration.query_parameters.filter`]\" \"[oteapi_optimade.models.query.OPTIMADEQueryParameters.filter] parameter. \" \"Note, this value takes precedence over [`configuration`][oteapi_optimade.\" \"models.strategies.filter.OPTIMADEFilterConfig.configuration] values.\" ), ) limit : Optional [ int ] = Field ( None , description = ( \"The `page_limit` OPTIMADE query parameter value. This parameter value can\" \" also be provided through the [`configuration.query_parameters.\" \"page_limit`][oteapi_optimade.models.query.OPTIMADEQueryParameters.\" \"page_limit] parameter. Note, this value takes precedence over \" \"[`configuration`][oteapi_optimade.models.strategies.filter.\" \"OPTIMADEFilterConfig.configuration] values.\" ), ) configuration : OPTIMADEConfig = Field ( OPTIMADEConfig (), description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), ) OPTIMADEFilterSession \u00b6 Bases: SessionUpdate OPTIMADE session for the filter strategy. Source code in oteapi_optimade/models/strategies/filter.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class OPTIMADEFilterSession ( SessionUpdate ): \"\"\"OPTIMADE session for the filter strategy.\"\"\" optimade_config : Optional [ OPTIMADEConfig ] = Field ( None , description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), ) optimade_response_object : Optional [ Response ] = Field ( None , description = \"An OPTIMADE Python tools (OPT) pydantic response object.\" , ) optimade_response : Optional [ Dict [ str , Any ]] = Field ( None , description = \"An OPTIMADE response as a Python dictionary.\" , ) class Config : \"\"\"Pydantic configuration for `OPTIMADEFilterSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True Config \u00b6 Pydantic configuration for OPTIMADEFilterSession . Source code in oteapi_optimade/models/strategies/filter.py 73 74 75 76 77 class Config : \"\"\"Pydantic configuration for `OPTIMADEFilterSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"filter"},{"location":"api_reference/models/strategies/filter/#filter","text":"Models specific to the filter strategy.","title":"filter"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterConfig","text":"Bases: FilterConfig OPTIMADE-specific filter strategy config. Note The condition parameter is not taken into account. Source code in oteapi_optimade/models/strategies/filter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class OPTIMADEFilterConfig ( FilterConfig ): \"\"\"OPTIMADE-specific filter strategy config. Note: The `condition` parameter is not taken into account. \"\"\" filterType : Literal [ \"optimade\" , \"OPTIMADE\" , \"OPTiMaDe\" ] = Field ( ... , description = \"The registered strategy name for OPTIMADEFilterStrategy.\" , ) query : Optional [ str ] = Field ( None , description = ( \"The `filter` OPTIMADE query parameter value. This parameter value can \" \"also be provided through the [`configuration.query_parameters.filter`]\" \"[oteapi_optimade.models.query.OPTIMADEQueryParameters.filter] parameter. \" \"Note, this value takes precedence over [`configuration`][oteapi_optimade.\" \"models.strategies.filter.OPTIMADEFilterConfig.configuration] values.\" ), ) limit : Optional [ int ] = Field ( None , description = ( \"The `page_limit` OPTIMADE query parameter value. This parameter value can\" \" also be provided through the [`configuration.query_parameters.\" \"page_limit`][oteapi_optimade.models.query.OPTIMADEQueryParameters.\" \"page_limit] parameter. Note, this value takes precedence over \" \"[`configuration`][oteapi_optimade.models.strategies.filter.\" \"OPTIMADEFilterConfig.configuration] values.\" ), ) configuration : OPTIMADEConfig = Field ( OPTIMADEConfig (), description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), )","title":"OPTIMADEFilterConfig"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession","text":"Bases: SessionUpdate OPTIMADE session for the filter strategy. Source code in oteapi_optimade/models/strategies/filter.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class OPTIMADEFilterSession ( SessionUpdate ): \"\"\"OPTIMADE session for the filter strategy.\"\"\" optimade_config : Optional [ OPTIMADEConfig ] = Field ( None , description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), ) optimade_response_object : Optional [ Response ] = Field ( None , description = \"An OPTIMADE Python tools (OPT) pydantic response object.\" , ) optimade_response : Optional [ Dict [ str , Any ]] = Field ( None , description = \"An OPTIMADE response as a Python dictionary.\" , ) class Config : \"\"\"Pydantic configuration for `OPTIMADEFilterSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"OPTIMADEFilterSession"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession.Config","text":"Pydantic configuration for OPTIMADEFilterSession . Source code in oteapi_optimade/models/strategies/filter.py 73 74 75 76 77 class Config : \"\"\"Pydantic configuration for `OPTIMADEFilterSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"Config"},{"location":"api_reference/models/strategies/parse/","text":"parse \u00b6 Models specific to the parse strategy. OPTIMADEParseConfig \u00b6 Bases: ResourceConfig OPTIMADE-specific parse strategy config. Source code in oteapi_optimade/models/strategies/parse.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class OPTIMADEParseConfig ( ResourceConfig ): \"\"\"OPTIMADE-specific parse strategy config.\"\"\" downloadUrl : OPTIMADEUrl = Field ( ... , description = \"Either a base OPTIMADE URL or a full OPTIMADE URL.\" , ) mediaType : Literal [ \"application/vnd.optimade+json\" , \"application/vnd.OPTIMADE+json\" , \"application/vnd.OPTiMaDe+json\" , \"application/vnd.optimade+JSON\" , \"application/vnd.OPTIMADE+JSON\" , \"application/vnd.OPTiMaDe+JSON\" , \"application/vnd.optimade\" , \"application/vnd.OPTIMADE\" , \"application/vnd.OPTiMaDe\" , ] = Field ( ... , description = \"The registered strategy name for OPTIMADEParseStrategy.\" , ) configuration : OPTIMADEConfig = Field ( OPTIMADEConfig (), description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), ) OPTIMADEParseSession \u00b6 Bases: SessionUpdate OPTIMADE session for the parse strategy. Source code in oteapi_optimade/models/strategies/parse.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class OPTIMADEParseSession ( SessionUpdate ): \"\"\"OPTIMADE session for the parse strategy.\"\"\" optimade_config : Optional [ OPTIMADEConfig ] = Field ( None , description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), ) optimade_response_object : Optional [ Response ] = Field ( None , description = \"An OPTIMADE Python tools (OPT) pydantic response object.\" , ) optimade_response : Optional [ Dict [ str , Any ]] = Field ( None , description = \"An OPTIMADE response as a Python dictionary.\" , ) class Config : \"\"\"Pydantic configuration for `OPTIMADEParseSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True Config \u00b6 Pydantic configuration for OPTIMADEParseSession . Source code in oteapi_optimade/models/strategies/parse.py 62 63 64 65 66 class Config : \"\"\"Pydantic configuration for `OPTIMADEParseSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"parse"},{"location":"api_reference/models/strategies/parse/#parse","text":"Models specific to the parse strategy.","title":"parse"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseConfig","text":"Bases: ResourceConfig OPTIMADE-specific parse strategy config. Source code in oteapi_optimade/models/strategies/parse.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class OPTIMADEParseConfig ( ResourceConfig ): \"\"\"OPTIMADE-specific parse strategy config.\"\"\" downloadUrl : OPTIMADEUrl = Field ( ... , description = \"Either a base OPTIMADE URL or a full OPTIMADE URL.\" , ) mediaType : Literal [ \"application/vnd.optimade+json\" , \"application/vnd.OPTIMADE+json\" , \"application/vnd.OPTiMaDe+json\" , \"application/vnd.optimade+JSON\" , \"application/vnd.OPTIMADE+JSON\" , \"application/vnd.OPTiMaDe+JSON\" , \"application/vnd.optimade\" , \"application/vnd.OPTIMADE\" , \"application/vnd.OPTiMaDe\" , ] = Field ( ... , description = \"The registered strategy name for OPTIMADEParseStrategy.\" , ) configuration : OPTIMADEConfig = Field ( OPTIMADEConfig (), description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), )","title":"OPTIMADEParseConfig"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession","text":"Bases: SessionUpdate OPTIMADE session for the parse strategy. Source code in oteapi_optimade/models/strategies/parse.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class OPTIMADEParseSession ( SessionUpdate ): \"\"\"OPTIMADE session for the parse strategy.\"\"\" optimade_config : Optional [ OPTIMADEConfig ] = Field ( None , description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), ) optimade_response_object : Optional [ Response ] = Field ( None , description = \"An OPTIMADE Python tools (OPT) pydantic response object.\" , ) optimade_response : Optional [ Dict [ str , Any ]] = Field ( None , description = \"An OPTIMADE response as a Python dictionary.\" , ) class Config : \"\"\"Pydantic configuration for `OPTIMADEParseSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"OPTIMADEParseSession"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession.Config","text":"Pydantic configuration for OPTIMADEParseSession . Source code in oteapi_optimade/models/strategies/parse.py 62 63 64 65 66 class Config : \"\"\"Pydantic configuration for `OPTIMADEParseSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"Config"},{"location":"api_reference/models/strategies/resource/","text":"resource \u00b6 Models specific to the resource strategy. OPTIMADEResourceConfig \u00b6 Bases: ResourceConfig OPTIMADE-specific resource strategy config. Source code in oteapi_optimade/models/strategies/resource.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class OPTIMADEResourceConfig ( ResourceConfig ): \"\"\"OPTIMADE-specific resource strategy config.\"\"\" accessUrl : OPTIMADEUrl = Field ( ... , description = \"Either a base OPTIMADE URL or a full OPTIMADE URL.\" , ) accessService : Literal [ \"optimade\" , \"OPTIMADE\" , \"OPTiMaDe\" ] = Field ( ... , description = \"The registered strategy name for OPTIMADEResourceStrategy.\" , ) configuration : OPTIMADEConfig = Field ( OPTIMADEConfig (), description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), ) OPTIMADEResourceSession \u00b6 Bases: SessionUpdate OPTIMADE session for the resource strategy. Source code in oteapi_optimade/models/strategies/resource.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class OPTIMADEResourceSession ( SessionUpdate ): \"\"\"OPTIMADE session for the resource strategy.\"\"\" optimade_config : Optional [ OPTIMADEConfig ] = Field ( None , description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), ) optimade_resources : List [ Dict [ str , Any ]] = Field ( [], description = ( \"List of OPTIMADE resources (structures, references, errors, ...) returned\" \" from the OPTIMADE request.\" ), ) optimade_resource_model : str = Field ( \"\" , description = ( \"Importable path to the resource model to be used to parse the OPTIMADE \" \"resources in `optimade_resource`. The importable path should be a fully \" \"importable path to a module separated by a colon (`:`) to then define the \" \"resource model class name. This means one can then do: \\n\\n ```python \\n \" \"from PACKAGE.MODULE import RESOURCE_CLS \\n ``` \\n From the value \" \"`PACKAGE.MODULE:RESOURCE_CLS`\" ), regex = ( r \"^([a-zA-Z][a-zA-Z0-9_]*(\\.[a-zA-Z][a-zA-Z0-9_]*)*\" # package.module r \":[a-zA-Z][a-zA-Z0-9_]*)?$\" # class ), ) class Config : \"\"\"Pydantic configuration for `OPTIMADEResourceSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True Config \u00b6 Pydantic configuration for OPTIMADEResourceSession . Source code in oteapi_optimade/models/strategies/resource.py 65 66 67 68 69 class Config : \"\"\"Pydantic configuration for `OPTIMADEResourceSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"resource"},{"location":"api_reference/models/strategies/resource/#resource","text":"Models specific to the resource strategy.","title":"resource"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceConfig","text":"Bases: ResourceConfig OPTIMADE-specific resource strategy config. Source code in oteapi_optimade/models/strategies/resource.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class OPTIMADEResourceConfig ( ResourceConfig ): \"\"\"OPTIMADE-specific resource strategy config.\"\"\" accessUrl : OPTIMADEUrl = Field ( ... , description = \"Either a base OPTIMADE URL or a full OPTIMADE URL.\" , ) accessService : Literal [ \"optimade\" , \"OPTIMADE\" , \"OPTiMaDe\" ] = Field ( ... , description = \"The registered strategy name for OPTIMADEResourceStrategy.\" , ) configuration : OPTIMADEConfig = Field ( OPTIMADEConfig (), description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), )","title":"OPTIMADEResourceConfig"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession","text":"Bases: SessionUpdate OPTIMADE session for the resource strategy. Source code in oteapi_optimade/models/strategies/resource.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class OPTIMADEResourceSession ( SessionUpdate ): \"\"\"OPTIMADE session for the resource strategy.\"\"\" optimade_config : Optional [ OPTIMADEConfig ] = Field ( None , description = ( \"OPTIMADE configuration. Contains relevant information necessary to \" \"perform OPTIMADE queries.\" ), ) optimade_resources : List [ Dict [ str , Any ]] = Field ( [], description = ( \"List of OPTIMADE resources (structures, references, errors, ...) returned\" \" from the OPTIMADE request.\" ), ) optimade_resource_model : str = Field ( \"\" , description = ( \"Importable path to the resource model to be used to parse the OPTIMADE \" \"resources in `optimade_resource`. The importable path should be a fully \" \"importable path to a module separated by a colon (`:`) to then define the \" \"resource model class name. This means one can then do: \\n\\n ```python \\n \" \"from PACKAGE.MODULE import RESOURCE_CLS \\n ``` \\n From the value \" \"`PACKAGE.MODULE:RESOURCE_CLS`\" ), regex = ( r \"^([a-zA-Z][a-zA-Z0-9_]*(\\.[a-zA-Z][a-zA-Z0-9_]*)*\" # package.module r \":[a-zA-Z][a-zA-Z0-9_]*)?$\" # class ), ) class Config : \"\"\"Pydantic configuration for `OPTIMADEResourceSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"OPTIMADEResourceSession"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession.Config","text":"Pydantic configuration for OPTIMADEResourceSession . Source code in oteapi_optimade/models/strategies/resource.py 65 66 67 68 69 class Config : \"\"\"Pydantic configuration for `OPTIMADEResourceSession`.\"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"Config"},{"location":"api_reference/strategies/filter/","text":"filter \u00b6 Demo filter strategy. OPTIMADEFilterStrategy \u00b6 Filter Strategy. Implements strategies : (\"filterType\", \"OPTIMADE\") (\"filterType\", \"optimade\") (\"filterType\", \"OPTiMaDe\") Source code in oteapi_optimade/strategies/filter.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 @dataclass class OPTIMADEFilterStrategy : \"\"\"Filter Strategy. **Implements strategies**: - `(\"filterType\", \"OPTIMADE\")` - `(\"filterType\", \"optimade\")` - `(\"filterType\", \"OPTiMaDe\")` \"\"\" filter_config : OPTIMADEFilterConfig def initialize ( self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEFilterSession : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEFilterSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEFilterSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEFilterSession () if session . optimade_config : self . filter_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_config = self . filter_config . configuration . copy () if not optimade_config . query_parameters : optimade_config . query_parameters = OPTIMADEQueryParameters () if self . filter_config . query : LOGGER . debug ( \"Setting filter from query.\" ) optimade_config . query_parameters . filter = self . filter_config . query if self . filter_config . limit : LOGGER . debug ( \"Setting page_limit from limit.\" ) optimade_config . query_parameters . page_limit = self . filter_config . limit return session . copy ( update = { \"optimade_config\" : optimade_config . copy ( update = { \"query_parameters\" : model2dict ( optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) }, ) def get ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () get ( session = None ) \u00b6 Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the SessionUpdate session-specific context from services. Source code in oteapi_optimade/strategies/filter.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () initialize ( session = None ) \u00b6 Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary context. None Returns: Type Description OPTIMADEFilterSession An update model of key/value-pairs to be stored in the OPTIMADEFilterSession session-specific context from services. Source code in oteapi_optimade/strategies/filter.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def initialize ( self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEFilterSession : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEFilterSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEFilterSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEFilterSession () if session . optimade_config : self . filter_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_config = self . filter_config . configuration . copy () if not optimade_config . query_parameters : optimade_config . query_parameters = OPTIMADEQueryParameters () if self . filter_config . query : LOGGER . debug ( \"Setting filter from query.\" ) optimade_config . query_parameters . filter = self . filter_config . query if self . filter_config . limit : LOGGER . debug ( \"Setting page_limit from limit.\" ) optimade_config . query_parameters . page_limit = self . filter_config . limit return session . copy ( update = { \"optimade_config\" : optimade_config . copy ( update = { \"query_parameters\" : model2dict ( optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) }, )","title":"filter"},{"location":"api_reference/strategies/filter/#filter","text":"Demo filter strategy.","title":"filter"},{"location":"api_reference/strategies/filter/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy","text":"Filter Strategy. Implements strategies : (\"filterType\", \"OPTIMADE\") (\"filterType\", \"optimade\") (\"filterType\", \"OPTiMaDe\") Source code in oteapi_optimade/strategies/filter.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 @dataclass class OPTIMADEFilterStrategy : \"\"\"Filter Strategy. **Implements strategies**: - `(\"filterType\", \"OPTIMADE\")` - `(\"filterType\", \"optimade\")` - `(\"filterType\", \"OPTiMaDe\")` \"\"\" filter_config : OPTIMADEFilterConfig def initialize ( self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEFilterSession : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEFilterSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEFilterSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEFilterSession () if session . optimade_config : self . filter_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_config = self . filter_config . configuration . copy () if not optimade_config . query_parameters : optimade_config . query_parameters = OPTIMADEQueryParameters () if self . filter_config . query : LOGGER . debug ( \"Setting filter from query.\" ) optimade_config . query_parameters . filter = self . filter_config . query if self . filter_config . limit : LOGGER . debug ( \"Setting page_limit from limit.\" ) optimade_config . query_parameters . page_limit = self . filter_config . limit return session . copy ( update = { \"optimade_config\" : optimade_config . copy ( update = { \"query_parameters\" : model2dict ( optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) }, ) def get ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate ()","title":"OPTIMADEFilterStrategy"},{"location":"api_reference/strategies/filter/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.get","text":"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the SessionUpdate session-specific context from services. Source code in oteapi_optimade/strategies/filter.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute the strategy. This method will be called through the strategy-specific endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate ()","title":"get()"},{"location":"api_reference/strategies/filter/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.initialize","text":"Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary context. None Returns: Type Description OPTIMADEFilterSession An update model of key/value-pairs to be stored in the OPTIMADEFilterSession session-specific context from services. Source code in oteapi_optimade/strategies/filter.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def initialize ( self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEFilterSession : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy. Workflow: 1. Compile received information. 2. Update session with compiled information. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEFilterSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEFilterSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEFilterSession () if session . optimade_config : self . filter_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_config = self . filter_config . configuration . copy () if not optimade_config . query_parameters : optimade_config . query_parameters = OPTIMADEQueryParameters () if self . filter_config . query : LOGGER . debug ( \"Setting filter from query.\" ) optimade_config . query_parameters . filter = self . filter_config . query if self . filter_config . limit : LOGGER . debug ( \"Setting page_limit from limit.\" ) optimade_config . query_parameters . page_limit = self . filter_config . limit return session . copy ( update = { \"optimade_config\" : optimade_config . copy ( update = { \"query_parameters\" : model2dict ( optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) }, )","title":"initialize()"},{"location":"api_reference/strategies/parse/","text":"parse \u00b6 Demo strategy class for text/json. OPTIMADEParseStrategy \u00b6 Parse strategy for JSON. Implements strategies : (\"mediaType\", \"application/vnd.optimade+json\") (\"mediaType\", \"application/vnd.OPTIMADE+json\") (\"mediaType\", \"application/vnd.OPTiMaDe+json\") (\"mediaType\", \"application/vnd.optimade+JSON\") (\"mediaType\", \"application/vnd.OPTIMADE+JSON\") (\"mediaType\", \"application/vnd.OPTiMaDe+JSON\") (\"mediaType\", \"application/vnd.optimade\") (\"mediaType\", \"application/vnd.OPTIMADE\") (\"mediaType\", \"application/vnd.OPTiMaDe\") Source code in oteapi_optimade/strategies/parse.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 @dataclass class OPTIMADEParseStrategy : \"\"\"Parse strategy for JSON. **Implements strategies**: - `(\"mediaType\", \"application/vnd.optimade+json\")` - `(\"mediaType\", \"application/vnd.OPTIMADE+json\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe+json\")` - `(\"mediaType\", \"application/vnd.optimade+JSON\")` - `(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")` - `(\"mediaType\", \"application/vnd.optimade\")` - `(\"mediaType\", \"application/vnd.OPTIMADE\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe\")` \"\"\" parse_config : OPTIMADEParseConfig def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () def get ( # pylint: disable=too-many-branches self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEParseSession : \"\"\"Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `downloadUrl`. Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEParseSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEParseSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEParseSession () if session . optimade_config : self . parse_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) cache = DataCache ( self . parse_config . configuration . datacache_config ) if self . parse_config . downloadUrl in cache : response : \"Dict[str, Any]\" = cache . get ( self . parse_config . downloadUrl ) elif ( self . parse_config . configuration . datacache_config . accessKey and self . parse_config . configuration . datacache_config . accessKey in cache ): response = cache . get ( self . parse_config . configuration . datacache_config . accessKey ) else : download_config = self . parse_config . copy () session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) response = { \"json\" : json . loads ( cache . get ( session . pop ( \"key\" )))} if ( not response . get ( \"ok\" , True ) or ( 200 > response . get ( \"status_code\" , 200 ) or response . get ( \"status_code\" , 200 ) >= 300 ) or \"errors\" in response . get ( \"json\" , {}) ): # Error response try : response_object = ErrorResponse ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Could not validate an error response. \\n ValidationError: \" \" %s \\n response= %r \" , exc , response , ) raise OPTIMADEParseError ( \"Could not validate an error response.\" ) from exc else : # Successful response response_model = self . parse_config . downloadUrl . response_model () if response_model : if not isinstance ( response_model , tuple ): response_model = ( response_model ,) for model_cls in response_model : try : response_object = model_cls ( ** response . get ( \"json\" , {})) except ValidationError : pass else : break else : LOGGER . error ( \"Could not validate for an expected response model. \\n URL= %r \\n \" \"response_models= %r \\n response= %s \" , self . parse_config . downloadUrl , response_model , response , ) raise OPTIMADEParseError ( \"Could not validate for an expected response model.\" ) else : # No \"endpoint\" or unknown try : response_object = Success ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Unknown or unparseable endpoint. \\n ValidatonError: %s \\n \" \"URL= %r \\n endpoint= %r \\n response_model= %r \\n response= %s \" , exc , self . parse_config . downloadUrl , self . parse_config . downloadUrl . endpoint , response_model , response , ) raise OPTIMADEParseError ( \"Unknown or unparseable endpoint.\" ) from exc if self . parse_config . configuration . return_object : session . optimade_response_object = response_object else : session . optimade_response = model2dict ( response_object ) if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session get ( session = None ) \u00b6 Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in resource_config.configuration take precedence over the derived values from downloadUrl . Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary-like context. None Returns: Type Description OPTIMADEParseSession An update model of key/value-pairs to be stored in the session-specific OPTIMADEParseSession context from services. Source code in oteapi_optimade/strategies/parse.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def get ( # pylint: disable=too-many-branches self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEParseSession : \"\"\"Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `downloadUrl`. Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEParseSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEParseSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEParseSession () if session . optimade_config : self . parse_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) cache = DataCache ( self . parse_config . configuration . datacache_config ) if self . parse_config . downloadUrl in cache : response : \"Dict[str, Any]\" = cache . get ( self . parse_config . downloadUrl ) elif ( self . parse_config . configuration . datacache_config . accessKey and self . parse_config . configuration . datacache_config . accessKey in cache ): response = cache . get ( self . parse_config . configuration . datacache_config . accessKey ) else : download_config = self . parse_config . copy () session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) response = { \"json\" : json . loads ( cache . get ( session . pop ( \"key\" )))} if ( not response . get ( \"ok\" , True ) or ( 200 > response . get ( \"status_code\" , 200 ) or response . get ( \"status_code\" , 200 ) >= 300 ) or \"errors\" in response . get ( \"json\" , {}) ): # Error response try : response_object = ErrorResponse ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Could not validate an error response. \\n ValidationError: \" \" %s \\n response= %r \" , exc , response , ) raise OPTIMADEParseError ( \"Could not validate an error response.\" ) from exc else : # Successful response response_model = self . parse_config . downloadUrl . response_model () if response_model : if not isinstance ( response_model , tuple ): response_model = ( response_model ,) for model_cls in response_model : try : response_object = model_cls ( ** response . get ( \"json\" , {})) except ValidationError : pass else : break else : LOGGER . error ( \"Could not validate for an expected response model. \\n URL= %r \\n \" \"response_models= %r \\n response= %s \" , self . parse_config . downloadUrl , response_model , response , ) raise OPTIMADEParseError ( \"Could not validate for an expected response model.\" ) else : # No \"endpoint\" or unknown try : response_object = Success ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Unknown or unparseable endpoint. \\n ValidatonError: %s \\n \" \"URL= %r \\n endpoint= %r \\n response_model= %r \\n response= %s \" , exc , self . parse_config . downloadUrl , self . parse_config . downloadUrl . endpoint , response_model , response , ) raise OPTIMADEParseError ( \"Unknown or unparseable endpoint.\" ) from exc if self . parse_config . configuration . return_object : session . optimade_response_object = response_object else : session . optimade_response = model2dict ( response_object ) if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session initialize ( session = None ) \u00b6 Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific SessionUpdate context from services. Source code in oteapi_optimade/strategies/parse.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate ()","title":"parse"},{"location":"api_reference/strategies/parse/#parse","text":"Demo strategy class for text/json.","title":"parse"},{"location":"api_reference/strategies/parse/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy","text":"Parse strategy for JSON. Implements strategies : (\"mediaType\", \"application/vnd.optimade+json\") (\"mediaType\", \"application/vnd.OPTIMADE+json\") (\"mediaType\", \"application/vnd.OPTiMaDe+json\") (\"mediaType\", \"application/vnd.optimade+JSON\") (\"mediaType\", \"application/vnd.OPTIMADE+JSON\") (\"mediaType\", \"application/vnd.OPTiMaDe+JSON\") (\"mediaType\", \"application/vnd.optimade\") (\"mediaType\", \"application/vnd.OPTIMADE\") (\"mediaType\", \"application/vnd.OPTiMaDe\") Source code in oteapi_optimade/strategies/parse.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 @dataclass class OPTIMADEParseStrategy : \"\"\"Parse strategy for JSON. **Implements strategies**: - `(\"mediaType\", \"application/vnd.optimade+json\")` - `(\"mediaType\", \"application/vnd.OPTIMADE+json\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe+json\")` - `(\"mediaType\", \"application/vnd.optimade+JSON\")` - `(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")` - `(\"mediaType\", \"application/vnd.optimade\")` - `(\"mediaType\", \"application/vnd.OPTIMADE\")` - `(\"mediaType\", \"application/vnd.OPTiMaDe\")` \"\"\" parse_config : OPTIMADEParseConfig def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () def get ( # pylint: disable=too-many-branches self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEParseSession : \"\"\"Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `downloadUrl`. Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEParseSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEParseSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEParseSession () if session . optimade_config : self . parse_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) cache = DataCache ( self . parse_config . configuration . datacache_config ) if self . parse_config . downloadUrl in cache : response : \"Dict[str, Any]\" = cache . get ( self . parse_config . downloadUrl ) elif ( self . parse_config . configuration . datacache_config . accessKey and self . parse_config . configuration . datacache_config . accessKey in cache ): response = cache . get ( self . parse_config . configuration . datacache_config . accessKey ) else : download_config = self . parse_config . copy () session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) response = { \"json\" : json . loads ( cache . get ( session . pop ( \"key\" )))} if ( not response . get ( \"ok\" , True ) or ( 200 > response . get ( \"status_code\" , 200 ) or response . get ( \"status_code\" , 200 ) >= 300 ) or \"errors\" in response . get ( \"json\" , {}) ): # Error response try : response_object = ErrorResponse ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Could not validate an error response. \\n ValidationError: \" \" %s \\n response= %r \" , exc , response , ) raise OPTIMADEParseError ( \"Could not validate an error response.\" ) from exc else : # Successful response response_model = self . parse_config . downloadUrl . response_model () if response_model : if not isinstance ( response_model , tuple ): response_model = ( response_model ,) for model_cls in response_model : try : response_object = model_cls ( ** response . get ( \"json\" , {})) except ValidationError : pass else : break else : LOGGER . error ( \"Could not validate for an expected response model. \\n URL= %r \\n \" \"response_models= %r \\n response= %s \" , self . parse_config . downloadUrl , response_model , response , ) raise OPTIMADEParseError ( \"Could not validate for an expected response model.\" ) else : # No \"endpoint\" or unknown try : response_object = Success ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Unknown or unparseable endpoint. \\n ValidatonError: %s \\n \" \"URL= %r \\n endpoint= %r \\n response_model= %r \\n response= %s \" , exc , self . parse_config . downloadUrl , self . parse_config . downloadUrl . endpoint , response_model , response , ) raise OPTIMADEParseError ( \"Unknown or unparseable endpoint.\" ) from exc if self . parse_config . configuration . return_object : session . optimade_response_object = response_object else : session . optimade_response = model2dict ( response_object ) if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session","title":"OPTIMADEParseStrategy"},{"location":"api_reference/strategies/parse/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.get","text":"Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in resource_config.configuration take precedence over the derived values from downloadUrl . Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary-like context. None Returns: Type Description OPTIMADEParseSession An update model of key/value-pairs to be stored in the session-specific OPTIMADEParseSession context from services. Source code in oteapi_optimade/strategies/parse.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def get ( # pylint: disable=too-many-branches self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEParseSession : \"\"\"Request and parse an OPTIMADE response using OPT. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `downloadUrl`. Workflow: 1. Request OPTIMADE response. 2. Parse as an OPTIMADE Python tools (OPT) pydantic response model. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEParseSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEParseSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEParseSession () if session . optimade_config : self . parse_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) cache = DataCache ( self . parse_config . configuration . datacache_config ) if self . parse_config . downloadUrl in cache : response : \"Dict[str, Any]\" = cache . get ( self . parse_config . downloadUrl ) elif ( self . parse_config . configuration . datacache_config . accessKey and self . parse_config . configuration . datacache_config . accessKey in cache ): response = cache . get ( self . parse_config . configuration . datacache_config . accessKey ) else : download_config = self . parse_config . copy () session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . DOWNLOAD , download_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) response = { \"json\" : json . loads ( cache . get ( session . pop ( \"key\" )))} if ( not response . get ( \"ok\" , True ) or ( 200 > response . get ( \"status_code\" , 200 ) or response . get ( \"status_code\" , 200 ) >= 300 ) or \"errors\" in response . get ( \"json\" , {}) ): # Error response try : response_object = ErrorResponse ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Could not validate an error response. \\n ValidationError: \" \" %s \\n response= %r \" , exc , response , ) raise OPTIMADEParseError ( \"Could not validate an error response.\" ) from exc else : # Successful response response_model = self . parse_config . downloadUrl . response_model () if response_model : if not isinstance ( response_model , tuple ): response_model = ( response_model ,) for model_cls in response_model : try : response_object = model_cls ( ** response . get ( \"json\" , {})) except ValidationError : pass else : break else : LOGGER . error ( \"Could not validate for an expected response model. \\n URL= %r \\n \" \"response_models= %r \\n response= %s \" , self . parse_config . downloadUrl , response_model , response , ) raise OPTIMADEParseError ( \"Could not validate for an expected response model.\" ) else : # No \"endpoint\" or unknown try : response_object = Success ( ** response . get ( \"json\" , {})) except ValidationError as exc : LOGGER . error ( \"Unknown or unparseable endpoint. \\n ValidatonError: %s \\n \" \"URL= %r \\n endpoint= %r \\n response_model= %r \\n response= %s \" , exc , self . parse_config . downloadUrl , self . parse_config . downloadUrl . endpoint , response_model , response , ) raise OPTIMADEParseError ( \"Unknown or unparseable endpoint.\" ) from exc if self . parse_config . configuration . return_object : session . optimade_response_object = response_object else : session . optimade_response = model2dict ( response_object ) if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session","title":"get()"},{"location":"api_reference/strategies/parse/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.initialize","text":"Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific SessionUpdate context from services. Source code in oteapi_optimade/strategies/parse.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/resource/","text":"resource \u00b6 OPTIMADE resource strategy. OPTIMADEResourceStrategy \u00b6 OPTIMADE Resource Strategy. Implements strategies : (\"accessService\", \"optimade\") (\"accessService\", \"OPTIMADE\") (\"accessService\", \"OPTiMaDe\") Source code in oteapi_optimade/strategies/resource.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 @dataclass class OPTIMADEResourceStrategy : \"\"\"OPTIMADE Resource Strategy. **Implements strategies**: - `(\"accessService\", \"optimade\")` - `(\"accessService\", \"OPTIMADE\")` - `(\"accessService\", \"OPTiMaDe\")` \"\"\" resource_config : OPTIMADEResourceConfig def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () def get ( # pylint: disable=too-many-branches,too-many-statements self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEResourceSession : \"\"\"Execute an OPTIMADE query to `accessUrl`. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `accessUrl`. Workflow: 1. Update configuration according to session. 2. Deconstruct `accessUrl` (done partly by `oteapi_optimade.models.custom_types.OPTIMADEUrl`). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEResourceSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEResourceSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEResourceSession () if session . optimade_config : self . resource_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_endpoint = self . resource_config . accessUrl . endpoint or \"structures\" optimade_query = ( self . resource_config . configuration . query_parameters or OPTIMADEQueryParameters () ) LOGGER . debug ( \"resource_config: %r \" , self . resource_config ) if self . resource_config . accessUrl . query : parsed_query = parse_qs ( self . resource_config . accessUrl . query ) for field , value in parsed_query . items (): # Only use the latest defined value for any parameter if field not in optimade_query . __fields_set__ : LOGGER . debug ( \"Setting %r from accessUrl (value= %r )\" , field , value [ - 1 ] ) setattr ( optimade_query , field , value [ - 1 ]) LOGGER . debug ( \"optimade_query after update: %r \" , optimade_query ) optimade_url = OPTIMADEUrl ( f \" { self . resource_config . accessUrl . base_url } \" f \" { '/' + self . resource_config . accessUrl . version if self . resource_config . accessUrl . version else '/v1' } \" # pylint: disable=line-too-long f \"/ { optimade_endpoint } ? { optimade_query . generate_query_string () } \" ) LOGGER . debug ( \"OPTIMADE URL to be requested: %s \" , optimade_url ) # Set cache access key to the full OPTIMADE URL. self . resource_config . configuration . datacache_config . accessKey = optimade_url # Perform query response = requests . get ( optimade_url , allow_redirects = True ) if optimade_query . response_format and optimade_query . response_format != \"json\" : raise NotImplementedError ( \"Can only handle JSON responses for now. Requested response format: \" f \" { optimade_query . response_format !r} \" ) cache = DataCache ( config = self . resource_config . configuration . datacache_config ) cache . add ( { \"status_code\" : response . status_code , \"ok\" : response . ok , \"json\" : response . json (), } ) parse_config = { \"downloadUrl\" : optimade_url , \"mediaType\" : ( f \"application/vnd. { self . resource_config . accessService } \" f \" { '+' + optimade_query . response_format if optimade_query . response_format else '' } \" # pylint: disable=line-too-long ), \"configuration\" : { \"datacache_config\" : self . resource_config . configuration . datacache_config , \"return_object\" : True , }, } session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) if \"optimade_response_object\" not in session : raise ValueError ( \"'optimade_response_object' was expected to be present in the session.\" ) optimade_response : \"OPTIMADEResponse\" = session . pop ( \"optimade_response_object\" ) if \"optimade_response\" in session and not session . get ( \"optimade_response\" ): del session [ \"optimade_response\" ] if isinstance ( optimade_response , ErrorResponse ): optimade_resources = optimade_response . errors session . optimade_resource_model = ( f \" { OptimadeError . __module__ } :OptimadeError\" ) elif isinstance ( optimade_response , ReferenceResponseMany ): optimade_resources = [ Reference ( entry ) . as_dict if isinstance ( entry , dict ) else Reference ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , ReferenceResponseOne ): optimade_resources = [ Reference ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Reference ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , StructureResponseMany ): optimade_resources = [ Structure ( entry ) . as_dict if isinstance ( entry , dict ) else Structure ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" elif isinstance ( optimade_response , StructureResponseOne ): optimade_resources = [ Structure ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Structure ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" else : LOGGER . debug ( \"Could not parse response as errors, references or structures. \" \"Response: \\n %r \" , optimade_response , ) raise OPTIMADEParseError ( \"Could not retrieve errors, references or structures from response \" f \"from { optimade_url } . It could be a valid OPTIMADE API response, \" \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \" \"invalid response completely.\" ) session . optimade_resources = [ model2dict ( resource ) for resource in optimade_resources ] if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session get ( session = None ) \u00b6 Execute an OPTIMADE query to accessUrl . This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in resource_config.configuration take precedence over the derived values from accessUrl . Workflow: 1. Update configuration according to session. 2. Deconstruct accessUrl (done partly by oteapi_optimade.models.custom_types.OPTIMADEUrl ). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary-like context. None Returns: Type Description OPTIMADEResourceSession An update model of key/value-pairs to be stored in the session-specific OPTIMADEResourceSession context from services. Source code in oteapi_optimade/strategies/resource.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def get ( # pylint: disable=too-many-branches,too-many-statements self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEResourceSession : \"\"\"Execute an OPTIMADE query to `accessUrl`. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `accessUrl`. Workflow: 1. Update configuration according to session. 2. Deconstruct `accessUrl` (done partly by `oteapi_optimade.models.custom_types.OPTIMADEUrl`). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEResourceSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEResourceSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEResourceSession () if session . optimade_config : self . resource_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_endpoint = self . resource_config . accessUrl . endpoint or \"structures\" optimade_query = ( self . resource_config . configuration . query_parameters or OPTIMADEQueryParameters () ) LOGGER . debug ( \"resource_config: %r \" , self . resource_config ) if self . resource_config . accessUrl . query : parsed_query = parse_qs ( self . resource_config . accessUrl . query ) for field , value in parsed_query . items (): # Only use the latest defined value for any parameter if field not in optimade_query . __fields_set__ : LOGGER . debug ( \"Setting %r from accessUrl (value= %r )\" , field , value [ - 1 ] ) setattr ( optimade_query , field , value [ - 1 ]) LOGGER . debug ( \"optimade_query after update: %r \" , optimade_query ) optimade_url = OPTIMADEUrl ( f \" { self . resource_config . accessUrl . base_url } \" f \" { '/' + self . resource_config . accessUrl . version if self . resource_config . accessUrl . version else '/v1' } \" # pylint: disable=line-too-long f \"/ { optimade_endpoint } ? { optimade_query . generate_query_string () } \" ) LOGGER . debug ( \"OPTIMADE URL to be requested: %s \" , optimade_url ) # Set cache access key to the full OPTIMADE URL. self . resource_config . configuration . datacache_config . accessKey = optimade_url # Perform query response = requests . get ( optimade_url , allow_redirects = True ) if optimade_query . response_format and optimade_query . response_format != \"json\" : raise NotImplementedError ( \"Can only handle JSON responses for now. Requested response format: \" f \" { optimade_query . response_format !r} \" ) cache = DataCache ( config = self . resource_config . configuration . datacache_config ) cache . add ( { \"status_code\" : response . status_code , \"ok\" : response . ok , \"json\" : response . json (), } ) parse_config = { \"downloadUrl\" : optimade_url , \"mediaType\" : ( f \"application/vnd. { self . resource_config . accessService } \" f \" { '+' + optimade_query . response_format if optimade_query . response_format else '' } \" # pylint: disable=line-too-long ), \"configuration\" : { \"datacache_config\" : self . resource_config . configuration . datacache_config , \"return_object\" : True , }, } session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) if \"optimade_response_object\" not in session : raise ValueError ( \"'optimade_response_object' was expected to be present in the session.\" ) optimade_response : \"OPTIMADEResponse\" = session . pop ( \"optimade_response_object\" ) if \"optimade_response\" in session and not session . get ( \"optimade_response\" ): del session [ \"optimade_response\" ] if isinstance ( optimade_response , ErrorResponse ): optimade_resources = optimade_response . errors session . optimade_resource_model = ( f \" { OptimadeError . __module__ } :OptimadeError\" ) elif isinstance ( optimade_response , ReferenceResponseMany ): optimade_resources = [ Reference ( entry ) . as_dict if isinstance ( entry , dict ) else Reference ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , ReferenceResponseOne ): optimade_resources = [ Reference ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Reference ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , StructureResponseMany ): optimade_resources = [ Structure ( entry ) . as_dict if isinstance ( entry , dict ) else Structure ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" elif isinstance ( optimade_response , StructureResponseOne ): optimade_resources = [ Structure ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Structure ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" else : LOGGER . debug ( \"Could not parse response as errors, references or structures. \" \"Response: \\n %r \" , optimade_response , ) raise OPTIMADEParseError ( \"Could not retrieve errors, references or structures from response \" f \"from { optimade_url } . It could be a valid OPTIMADE API response, \" \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \" \"invalid response completely.\" ) session . optimade_resources = [ model2dict ( resource ) for resource in optimade_resources ] if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session initialize ( session = None ) \u00b6 Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific SessionUpdate context from services. Source code in oteapi_optimade/strategies/resource.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate ()","title":"resource"},{"location":"api_reference/strategies/resource/#resource","text":"OPTIMADE resource strategy.","title":"resource"},{"location":"api_reference/strategies/resource/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy","text":"OPTIMADE Resource Strategy. Implements strategies : (\"accessService\", \"optimade\") (\"accessService\", \"OPTIMADE\") (\"accessService\", \"OPTiMaDe\") Source code in oteapi_optimade/strategies/resource.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 @dataclass class OPTIMADEResourceStrategy : \"\"\"OPTIMADE Resource Strategy. **Implements strategies**: - `(\"accessService\", \"optimade\")` - `(\"accessService\", \"OPTIMADE\")` - `(\"accessService\", \"OPTiMaDe\")` \"\"\" resource_config : OPTIMADEResourceConfig def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate () def get ( # pylint: disable=too-many-branches,too-many-statements self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEResourceSession : \"\"\"Execute an OPTIMADE query to `accessUrl`. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `accessUrl`. Workflow: 1. Update configuration according to session. 2. Deconstruct `accessUrl` (done partly by `oteapi_optimade.models.custom_types.OPTIMADEUrl`). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEResourceSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEResourceSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEResourceSession () if session . optimade_config : self . resource_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_endpoint = self . resource_config . accessUrl . endpoint or \"structures\" optimade_query = ( self . resource_config . configuration . query_parameters or OPTIMADEQueryParameters () ) LOGGER . debug ( \"resource_config: %r \" , self . resource_config ) if self . resource_config . accessUrl . query : parsed_query = parse_qs ( self . resource_config . accessUrl . query ) for field , value in parsed_query . items (): # Only use the latest defined value for any parameter if field not in optimade_query . __fields_set__ : LOGGER . debug ( \"Setting %r from accessUrl (value= %r )\" , field , value [ - 1 ] ) setattr ( optimade_query , field , value [ - 1 ]) LOGGER . debug ( \"optimade_query after update: %r \" , optimade_query ) optimade_url = OPTIMADEUrl ( f \" { self . resource_config . accessUrl . base_url } \" f \" { '/' + self . resource_config . accessUrl . version if self . resource_config . accessUrl . version else '/v1' } \" # pylint: disable=line-too-long f \"/ { optimade_endpoint } ? { optimade_query . generate_query_string () } \" ) LOGGER . debug ( \"OPTIMADE URL to be requested: %s \" , optimade_url ) # Set cache access key to the full OPTIMADE URL. self . resource_config . configuration . datacache_config . accessKey = optimade_url # Perform query response = requests . get ( optimade_url , allow_redirects = True ) if optimade_query . response_format and optimade_query . response_format != \"json\" : raise NotImplementedError ( \"Can only handle JSON responses for now. Requested response format: \" f \" { optimade_query . response_format !r} \" ) cache = DataCache ( config = self . resource_config . configuration . datacache_config ) cache . add ( { \"status_code\" : response . status_code , \"ok\" : response . ok , \"json\" : response . json (), } ) parse_config = { \"downloadUrl\" : optimade_url , \"mediaType\" : ( f \"application/vnd. { self . resource_config . accessService } \" f \" { '+' + optimade_query . response_format if optimade_query . response_format else '' } \" # pylint: disable=line-too-long ), \"configuration\" : { \"datacache_config\" : self . resource_config . configuration . datacache_config , \"return_object\" : True , }, } session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) if \"optimade_response_object\" not in session : raise ValueError ( \"'optimade_response_object' was expected to be present in the session.\" ) optimade_response : \"OPTIMADEResponse\" = session . pop ( \"optimade_response_object\" ) if \"optimade_response\" in session and not session . get ( \"optimade_response\" ): del session [ \"optimade_response\" ] if isinstance ( optimade_response , ErrorResponse ): optimade_resources = optimade_response . errors session . optimade_resource_model = ( f \" { OptimadeError . __module__ } :OptimadeError\" ) elif isinstance ( optimade_response , ReferenceResponseMany ): optimade_resources = [ Reference ( entry ) . as_dict if isinstance ( entry , dict ) else Reference ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , ReferenceResponseOne ): optimade_resources = [ Reference ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Reference ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , StructureResponseMany ): optimade_resources = [ Structure ( entry ) . as_dict if isinstance ( entry , dict ) else Structure ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" elif isinstance ( optimade_response , StructureResponseOne ): optimade_resources = [ Structure ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Structure ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" else : LOGGER . debug ( \"Could not parse response as errors, references or structures. \" \"Response: \\n %r \" , optimade_response , ) raise OPTIMADEParseError ( \"Could not retrieve errors, references or structures from response \" f \"from { optimade_url } . It could be a valid OPTIMADE API response, \" \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \" \"invalid response completely.\" ) session . optimade_resources = [ model2dict ( resource ) for resource in optimade_resources ] if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session","title":"OPTIMADEResourceStrategy"},{"location":"api_reference/strategies/resource/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.get","text":"Execute an OPTIMADE query to accessUrl . This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in resource_config.configuration take precedence over the derived values from accessUrl . Workflow: 1. Update configuration according to session. 2. Deconstruct accessUrl (done partly by oteapi_optimade.models.custom_types.OPTIMADEUrl ). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: Name Type Description Default session 'Optional[Union[SessionUpdate, Dict[str, Any]]]' A session-specific dictionary-like context. None Returns: Type Description OPTIMADEResourceSession An update model of key/value-pairs to be stored in the session-specific OPTIMADEResourceSession context from services. Source code in oteapi_optimade/strategies/resource.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def get ( # pylint: disable=too-many-branches,too-many-statements self , session : \"Optional[Union[SessionUpdate, Dict[str, Any]]]\" = None ) -> OPTIMADEResourceSession : \"\"\"Execute an OPTIMADE query to `accessUrl`. This method will be called through the strategy-specific endpoint of the OTE-API Services. Configuration values provided in `resource_config.configuration` take precedence over the derived values from `accessUrl`. Workflow: 1. Update configuration according to session. 2. Deconstruct `accessUrl` (done partly by `oteapi_optimade.models.custom_types.OPTIMADEUrl`). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache. Parameters: session: A session-specific dictionary-like context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" if session and isinstance ( session , dict ): session = OPTIMADEResourceSession ( ** session ) elif session and isinstance ( session , SessionUpdate ): session = OPTIMADEResourceSession ( ** model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) else : session = OPTIMADEResourceSession () if session . optimade_config : self . resource_config . configuration . update ( model2dict ( session . optimade_config , exclude_defaults = True , exclude_unset = True ) ) optimade_endpoint = self . resource_config . accessUrl . endpoint or \"structures\" optimade_query = ( self . resource_config . configuration . query_parameters or OPTIMADEQueryParameters () ) LOGGER . debug ( \"resource_config: %r \" , self . resource_config ) if self . resource_config . accessUrl . query : parsed_query = parse_qs ( self . resource_config . accessUrl . query ) for field , value in parsed_query . items (): # Only use the latest defined value for any parameter if field not in optimade_query . __fields_set__ : LOGGER . debug ( \"Setting %r from accessUrl (value= %r )\" , field , value [ - 1 ] ) setattr ( optimade_query , field , value [ - 1 ]) LOGGER . debug ( \"optimade_query after update: %r \" , optimade_query ) optimade_url = OPTIMADEUrl ( f \" { self . resource_config . accessUrl . base_url } \" f \" { '/' + self . resource_config . accessUrl . version if self . resource_config . accessUrl . version else '/v1' } \" # pylint: disable=line-too-long f \"/ { optimade_endpoint } ? { optimade_query . generate_query_string () } \" ) LOGGER . debug ( \"OPTIMADE URL to be requested: %s \" , optimade_url ) # Set cache access key to the full OPTIMADE URL. self . resource_config . configuration . datacache_config . accessKey = optimade_url # Perform query response = requests . get ( optimade_url , allow_redirects = True ) if optimade_query . response_format and optimade_query . response_format != \"json\" : raise NotImplementedError ( \"Can only handle JSON responses for now. Requested response format: \" f \" { optimade_query . response_format !r} \" ) cache = DataCache ( config = self . resource_config . configuration . datacache_config ) cache . add ( { \"status_code\" : response . status_code , \"ok\" : response . ok , \"json\" : response . json (), } ) parse_config = { \"downloadUrl\" : optimade_url , \"mediaType\" : ( f \"application/vnd. { self . resource_config . accessService } \" f \" { '+' + optimade_query . response_format if optimade_query . response_format else '' } \" # pylint: disable=line-too-long ), \"configuration\" : { \"datacache_config\" : self . resource_config . configuration . datacache_config , \"return_object\" : True , }, } session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . initialize ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) session . update ( create_strategy ( StrategyType . PARSE , parse_config ) . get ( model2dict ( session , exclude_defaults = True , exclude_unset = True ) ) ) if \"optimade_response_object\" not in session : raise ValueError ( \"'optimade_response_object' was expected to be present in the session.\" ) optimade_response : \"OPTIMADEResponse\" = session . pop ( \"optimade_response_object\" ) if \"optimade_response\" in session and not session . get ( \"optimade_response\" ): del session [ \"optimade_response\" ] if isinstance ( optimade_response , ErrorResponse ): optimade_resources = optimade_response . errors session . optimade_resource_model = ( f \" { OptimadeError . __module__ } :OptimadeError\" ) elif isinstance ( optimade_response , ReferenceResponseMany ): optimade_resources = [ Reference ( entry ) . as_dict if isinstance ( entry , dict ) else Reference ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , ReferenceResponseOne ): optimade_resources = [ Reference ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Reference ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Reference . __module__ } :Reference\" elif isinstance ( optimade_response , StructureResponseMany ): optimade_resources = [ Structure ( entry ) . as_dict if isinstance ( entry , dict ) else Structure ( entry . dict ()) . as_dict for entry in optimade_response . data ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" elif isinstance ( optimade_response , StructureResponseOne ): optimade_resources = [ Structure ( optimade_response . data ) . as_dict if isinstance ( optimade_response . data , dict ) else Structure ( optimade_response . data . dict ()) . as_dict ] session . optimade_resource_model = f \" { Structure . __module__ } :Structure\" else : LOGGER . debug ( \"Could not parse response as errors, references or structures. \" \"Response: \\n %r \" , optimade_response , ) raise OPTIMADEParseError ( \"Could not retrieve errors, references or structures from response \" f \"from { optimade_url } . It could be a valid OPTIMADE API response, \" \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \" \"invalid response completely.\" ) session . optimade_resources = [ model2dict ( resource ) for resource in optimade_resources ] if session . optimade_config and session . optimade_config . query_parameters : session = session . copy ( update = { \"optimade_config\" : session . optimade_config . copy ( update = { \"query_parameters\" : model2dict ( session . optimade_config . query_parameters , exclude_defaults = True , exclude_unset = True , ) } ) } ) return session","title":"get()"},{"location":"api_reference/strategies/resource/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.initialize","text":"Initialize strategy. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific SessionUpdate context from services. Source code in oteapi_optimade/strategies/resource.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def initialize ( # pylint: disable=no-self-use,unused-argument self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" return SessionUpdate ()","title":"initialize()"}]}