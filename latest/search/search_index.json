{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OTE-API OPTIMADE","text":"<p>An OTE-API Plugin with OTE strategies.</p> <p>Further reading:</p> <ul> <li>OTE-API Core Documentation</li> <li>OTE-API Services Documentation</li> </ul>"},{"location":"#license-and-copyright","title":"License and copyright","text":"<p>OTE-API OPTIMADE is released under the MIT license with copyright \u00a9 SINTEF.</p>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>OTE-API OPTIMADE has been created via the cookiecutter template for OTE-API plugins.</p> <p>OTE-API OPTIMADE has been supported by the following projects:</p> <ul> <li> <p>OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136.</p> </li> <li> <p>VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903.</p> </li> <li> <p>OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.</p> </li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#unreleased-changes-2024-01-04","title":"Unreleased changes (2024-01-04)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>Pin to specific <code>oteapi</code> docker image version for testing #187</li> </ul> <p>Merged pull requests:</p> <ul> <li>Pin oteapi docker image to pre-pydantic v2 #188 (CasperWA)</li> <li>Upgrade ruff rules and more #183 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v042-2023-10-26","title":"v0.4.2 (2023-10-26)","text":"<p>Full Changelog</p>"},{"location":"CHANGELOG/#v041-2023-10-26","title":"v0.4.1 (2023-10-26)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>Invalid use of logging #174</li> <li>OPTIMADE plugin produces empty instances of http://onto-ns.com/meta/1.0/OPTIMADEStructureSpecies  #162</li> </ul> <p>Merged pull requests:</p> <ul> <li>Properly create assemblies and species #172 (CasperWA)</li> <li>Proper use of logging #171 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v040-2023-10-23","title":"v0.4.0 (2023-10-23)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Add example(s) #124</li> </ul> <p>Fixed bugs:</p> <ul> <li>Wrong OPTIMADEStructureAttributes datamodel #164</li> <li>Pipeline figure not being shown in docs #144</li> <li>Updated DLite installation pathway #136</li> <li><code>Segmentation fault</code> from dlite in CI #115</li> <li>init file missing in the new <code>dlite</code> module #113</li> </ul> <p>Closed issues:</p> <ul> <li>Make the JSON-serialisation of entities human readable #160</li> <li>Use ruff instead of pylint (and isort) #156</li> </ul> <p>Merged pull requests:</p> <ul> <li>Write \u00c5ngstr\u00f6m such that it is understandable by Pint in datamodel #170 (jesper-friis)</li> <li>Update data models #169 (CasperWA)</li> <li>Move from pylint (&amp; isort) to ruff #157 (CasperWA)</li> <li>Use relative link, which works only in production #145 (CasperWA)</li> <li>Avoid DLite v0.4.0 #139 (CasperWA)</li> <li>DLite notebook example #127 (CasperWA)</li> <li>Add example to documentation #125 (CasperWA)</li> <li>Add __init__ file to dlite submodule #122 (CasperWA)</li> <li>Avoid psycopg2-binary v2.9.6 #117 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v030-2023-03-30","title":"v0.3.0 (2023-03-30)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Use <code>SINTEF/ci-cd</code> CI - Tests workflow #71</li> <li>Implement support for DLite #31</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fix CI/CD workflows for external usage #84</li> <li>Update to <code>SINTEF/ci-cd</code> instead of <code>CasperWA/ci-cd</code> #72</li> </ul> <p>Closed issues:</p> <ul> <li>Use SINTEF/ci-cd v2 #104</li> <li>Reinstate pre-commit hooks for docs #68</li> </ul> <p>Merged pull requests:</p> <ul> <li>Support DLite #109 (CasperWA)</li> <li>Update to SINTEF/ci-cd v2 #105 (CasperWA)</li> <li>Update input keywords for SINTEF/ci-cd workflows #85 (CasperWA)</li> <li>Use CasperWA/ci-cd pre-commit hooks #69 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v022-2022-07-06","title":"v0.2.2 (2022-07-06)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Update to use all workflows from CasperWA/gh-actions #63 (CasperWA)</li> </ul> <p>Fixed bugs:</p> <ul> <li>New workflow is removing API reference in documentation #64</li> </ul> <p>Closed issues:</p> <ul> <li>Update to new repository name for callable workflows #66</li> </ul> <p>Merged pull requests:</p> <ul> <li>Use new repo name for callable workflows repo #67 (CasperWA)</li> <li>Properly create API reference and clean up #65 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v021-2022-07-01","title":"v0.2.1 (2022-07-01)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>Set <code>test: false</code> for publish workflow #61</li> </ul> <p>Merged pull requests:</p> <ul> <li>Don't run publish workflow as a test #62 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v021-alpha1-2022-07-01","title":"v0.2.1-alpha.1 (2022-07-01)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Auto-merge generated PR from new workflow #49</li> <li>Properly update dependencies #46</li> <li>Use CasperWA/gh-actions workflows #60 (CasperWA)</li> </ul> <p>Fixed bugs:</p> <ul> <li>New workflow failing #48</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #53 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #52 (TEAM4-0)</li> <li>Auto-merge new CD workflow-generated PR #50 (CasperWA)</li> <li>New CD workflow to update dependencies in pyproject.toml #47 (CasperWA)</li> <li>[Auto-generated] Update dependencies #44 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v020-2022-05-18","title":"v0.2.0 (2022-05-18)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Implement OPTIMADE filter strategy #4</li> </ul> <p>Fixed bugs:</p> <ul> <li>CI docker connection issues #34</li> </ul> <p>Closed issues:</p> <ul> <li>Use the <code>optimade</code> container image in CI #41</li> <li>Extend acknowledgements in README #38</li> </ul> <p>Merged pull requests:</p> <ul> <li>Use the optimade container image in CI #42 (CasperWA)</li> <li>[Auto-generated] Update dependencies #40 (TEAM4-0)</li> <li>Add VIPCOAT and OpenModel to README ack #39 (CasperWA)</li> <li>Fix real backend CI job #37 (CasperWA)</li> <li>[Auto-generated] Update dependencies #36 (TEAM4-0)</li> <li>Add a Filter strategy #33 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v010-2022-03-29","title":"v0.1.0 (2022-03-29)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Correctly handle trailing slashes (<code>/</code>) #28</li> </ul> <p>Merged pull requests:</p> <ul> <li>Trailing slash in base URL #29 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v002-2022-03-29","title":"v0.0.2 (2022-03-29)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Implement OPTIMADE parse strategy #5</li> <li>Implement OPTIMADE resource strategy #3</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fix CI connection refusal for pytest-real-backend job #26</li> <li>CD workflow failing - flit not building #23</li> <li>Black issue with click #21</li> <li>CD workflow failing #18</li> <li>GH GraphQL type issue in auto-merge workflow #6</li> <li>Fix CI #1</li> </ul> <p>Closed issues:</p> <ul> <li>CI test with end-to-end #17</li> </ul> <p>Merged pull requests:</p> <ul> <li>Fix pytest-real-backend CI job #27 (CasperWA)</li> <li>Test release workflow #25 (CasperWA)</li> <li>Build package prior to polluting git tree #24 (CasperWA)</li> <li>Update pre-commit hooks #22 (CasperWA)</li> <li>Fix failing release workflow #20 (CasperWA)</li> <li>Setup CI end-to-end test #19 (CasperWA)</li> <li>[Auto-generated] Update dependencies #15 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #13 (TEAM4-0)</li> <li>Implement an OPTIMADE Resource strategy #12 (CasperWA)</li> <li>[Auto-generated] Update dependencies #11 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #10 (TEAM4-0)</li> <li>Use <code>ID!</code> type instead of <code>String!</code> #7 (CasperWA)</li> <li>Fix CI and use flit #2 (CasperWA)</li> </ul> <p>* This Changelog was automatically generated by github_changelog_generator</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2022 SINTEF</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"all_strategies/","title":"OTE-API OPTIMADE Strategies","text":"<p>This page provides documentation for the <code>oteapi_optimade.strategies</code> submodule, where all the OTE-API OPTIMADE strategies are located.</p> <p>These strategies will be available when setting up a server in an environment with oteapi-optimade installed.</p>"},{"location":"all_strategies/#oteapi_optimade.strategies.filter","title":"<code>filter</code>","text":"<p>Demo filter strategy.</p>"},{"location":"all_strategies/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy","title":"<code> OPTIMADEFilterStrategy        </code>  <code>dataclass</code>","text":"<p>Filter Strategy.</p> <p>Implements strategies:</p> <ul> <li><code>(\"filterType\", \"OPTIMADE\")</code></li> <li><code>(\"filterType\", \"optimade\")</code></li> <li><code>(\"filterType\", \"OPTiMaDe\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>@dataclass\nclass OPTIMADEFilterStrategy:\n    \"\"\"Filter Strategy.\n\n    **Implements strategies**:\n\n    - `(\"filterType\", \"OPTIMADE\")`\n    - `(\"filterType\", \"optimade\")`\n    - `(\"filterType\", \"OPTiMaDe\")`\n\n    \"\"\"\n\n    filter_config: OPTIMADEFilterConfig\n\n    def initialize(\n        self, session: SessionUpdate | dict[str, Any] | None = None\n    ) -&gt; OPTIMADEFilterSession:\n        \"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Configuration values, specifically URL query parameters, can be provided to the\n        OPTIMADE resource strategy through this filter strategy.\n\n        Workflow:\n\n        1. Compile received information.\n        2. Update session with compiled information.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEFilterSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEFilterSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEFilterSession()\n\n        if session.optimade_config:\n            self.filter_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        optimade_config = self.filter_config.configuration.copy()\n\n        if not optimade_config.query_parameters:\n            optimade_config.query_parameters = OPTIMADEQueryParameters()\n\n        if self.filter_config.query:\n            LOGGER.debug(\"Setting filter from query.\")\n            optimade_config.query_parameters.filter = self.filter_config.query\n\n        if self.filter_config.limit:\n            LOGGER.debug(\"Setting page_limit from limit.\")\n            optimade_config.query_parameters.page_limit = self.filter_config.limit\n\n        return session.copy(  # type: ignore[no-any-return]\n            update={\n                \"optimade_config\": optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            },\n        )\n\n    def get(\n        self,\n        session: dict[str, Any] | None = None,  # noqa: ARG002\n    ) -&gt; SessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n        return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict[str, Any] | None</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>def get(\n    self,\n    session: dict[str, Any] | None = None,  # noqa: ARG002\n) -&gt; SessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy.</p> <p>Workflow:</p> <ol> <li>Compile received information.</li> <li>Update session with compiled information.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>SessionUpdate | dict[str, Any] | None</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEFilterSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>def initialize(\n    self, session: SessionUpdate | dict[str, Any] | None = None\n) -&gt; OPTIMADEFilterSession:\n    \"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Configuration values, specifically URL query parameters, can be provided to the\n    OPTIMADE resource strategy through this filter strategy.\n\n    Workflow:\n\n    1. Compile received information.\n    2. Update session with compiled information.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEFilterSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEFilterSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEFilterSession()\n\n    if session.optimade_config:\n        self.filter_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    optimade_config = self.filter_config.configuration.copy()\n\n    if not optimade_config.query_parameters:\n        optimade_config.query_parameters = OPTIMADEQueryParameters()\n\n    if self.filter_config.query:\n        LOGGER.debug(\"Setting filter from query.\")\n        optimade_config.query_parameters.filter = self.filter_config.query\n\n    if self.filter_config.limit:\n        LOGGER.debug(\"Setting page_limit from limit.\")\n        optimade_config.query_parameters.page_limit = self.filter_config.limit\n\n    return session.copy(  # type: ignore[no-any-return]\n        update={\n            \"optimade_config\": optimade_config.copy(\n                update={\n                    \"query_parameters\": model2dict(\n                        optimade_config.query_parameters,\n                        exclude_defaults=True,\n                        exclude_unset=True,\n                    )\n                }\n            )\n        },\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.parse","title":"<code>parse</code>","text":"<p>Demo strategy class for text/json.</p>"},{"location":"all_strategies/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy","title":"<code> OPTIMADEParseStrategy        </code>  <code>dataclass</code>","text":"<p>Parse strategy for JSON.</p> <p>Implements strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.optimade+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.optimade+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.optimade\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>@dataclass\nclass OPTIMADEParseStrategy:\n    \"\"\"Parse strategy for JSON.\n\n    **Implements strategies**:\n\n    - `(\"mediaType\", \"application/vnd.optimade+json\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE+json\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe+json\")`\n    - `(\"mediaType\", \"application/vnd.optimade+JSON\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")`\n    - `(\"mediaType\", \"application/vnd.optimade\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe\")`\n\n    \"\"\"\n\n    parse_config: OPTIMADEParseConfig\n\n    def initialize(\n        self,\n        session: dict[str, Any] | None = None,  # noqa: ARG002\n    ) -&gt; SessionUpdate:\n        \"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        return SessionUpdate()\n\n    def get(\n        self, session: SessionUpdate | dict[str, Any] | None = None\n    ) -&gt; OPTIMADEParseSession:\n        \"\"\"Request and parse an OPTIMADE response using OPT.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Configuration values provided in `resource_config.configuration` take\n        precedence over the derived values from `downloadUrl`.\n\n        Workflow:\n\n        1. Request OPTIMADE response.\n        2. Parse as an OPTIMADE Python tools (OPT) pydantic response model.\n\n        Parameters:\n            session: A session-specific dictionary-like context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEParseSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEParseSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEParseSession()\n\n        if session.optimade_config:\n            self.parse_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        if self.parse_config.downloadUrl in cache:\n            response: dict[str, Any] = cache.get(self.parse_config.downloadUrl)\n        elif (\n            self.parse_config.configuration.datacache_config.accessKey\n            and self.parse_config.configuration.datacache_config.accessKey in cache\n        ):\n            response = cache.get(\n                self.parse_config.configuration.datacache_config.accessKey\n            )\n        else:\n            download_config = self.parse_config.copy()\n            session.update(\n                create_strategy(StrategyType.DOWNLOAD, download_config).initialize(\n                    model2dict(session, exclude_defaults=True, exclude_unset=True)\n                )\n            )\n            session.update(\n                create_strategy(StrategyType.DOWNLOAD, download_config).get(\n                    model2dict(session, exclude_defaults=True, exclude_unset=True)\n                )\n            )\n\n            response = {\"json\": json.loads(cache.get(session.pop(\"key\")))}\n\n        if (\n            not response.get(\"ok\", True)\n            or (\n                response.get(\"status_code\", 200) &lt; 200\n                or response.get(\"status_code\", 200) &gt;= 300\n            )\n            or \"errors\" in response.get(\"json\", {})\n        ):\n            # Error response\n            try:\n                response_object = ErrorResponse(**response.get(\"json\", {}))\n            except ValidationError as exc:\n                error_message = \"Could not validate an error response.\"\n                LOGGER.error(\n                    \"%s\\nValidationError: \" \"%s\\nresponse=%r\",\n                    error_message,\n                    exc,\n                    response,\n                )\n                raise OPTIMADEParseError(error_message) from exc\n        else:\n            # Successful response\n            response_model = self.parse_config.downloadUrl.response_model()\n            if response_model:\n                if not isinstance(response_model, tuple):\n                    response_model = (response_model,)\n                for model_cls in response_model:\n                    try:\n                        response_object = model_cls(**response.get(\"json\", {}))\n                    except ValidationError:\n                        pass\n                    else:\n                        break\n                else:\n                    error_message = \"Could not validate for an expected response model.\"\n                    LOGGER.error(\n                        \"%s\\nURL=%r\\n\" \"response_models=%r\\nresponse=%s\",\n                        error_message,\n                        self.parse_config.downloadUrl,\n                        response_model,\n                        response,\n                    )\n                    raise OPTIMADEParseError(error_message)\n            else:\n                # No \"endpoint\" or unknown\n                try:\n                    response_object = Success(**response.get(\"json\", {}))\n                except ValidationError as exc:\n                    error_message = \"Unknown or unparseable endpoint.\"\n                    LOGGER.error(\n                        \"%s\\nValidatonError: %s\\n\"\n                        \"URL=%r\\nendpoint=%r\\nresponse_model=%r\\nresponse=%s\",\n                        error_message,\n                        exc,\n                        self.parse_config.downloadUrl,\n                        self.parse_config.downloadUrl.endpoint,\n                        response_model,\n                        response,\n                    )\n                    raise OPTIMADEParseError(error_message) from exc\n\n        if self.parse_config.configuration.return_object:\n            session.optimade_response_object = response_object\n        else:\n            session.optimade_response = model2dict(response_object)\n\n        if session.optimade_config and session.optimade_config.query_parameters:\n            session = session.copy(\n                update={\n                    \"optimade_config\": session.optimade_config.copy(\n                        update={\n                            \"query_parameters\": model2dict(\n                                session.optimade_config.query_parameters,\n                                exclude_defaults=True,\n                                exclude_unset=True,\n                            )\n                        }\n                    )\n                }\n            )\n\n        if TYPE_CHECKING:  # pragma: no cover\n            assert isinstance(session, OPTIMADEParseSession)  # nosec\n\n        return session\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Request and parse an OPTIMADE response using OPT.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Configuration values provided in <code>resource_config.configuration</code> take precedence over the derived values from <code>downloadUrl</code>.</p> <p>Workflow:</p> <ol> <li>Request OPTIMADE response.</li> <li>Parse as an OPTIMADE Python tools (OPT) pydantic response model.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>SessionUpdate | dict[str, Any] | None</code> <p>A session-specific dictionary-like context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEParseSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>def get(\n    self, session: SessionUpdate | dict[str, Any] | None = None\n) -&gt; OPTIMADEParseSession:\n    \"\"\"Request and parse an OPTIMADE response using OPT.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Configuration values provided in `resource_config.configuration` take\n    precedence over the derived values from `downloadUrl`.\n\n    Workflow:\n\n    1. Request OPTIMADE response.\n    2. Parse as an OPTIMADE Python tools (OPT) pydantic response model.\n\n    Parameters:\n        session: A session-specific dictionary-like context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEParseSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEParseSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEParseSession()\n\n    if session.optimade_config:\n        self.parse_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    if self.parse_config.downloadUrl in cache:\n        response: dict[str, Any] = cache.get(self.parse_config.downloadUrl)\n    elif (\n        self.parse_config.configuration.datacache_config.accessKey\n        and self.parse_config.configuration.datacache_config.accessKey in cache\n    ):\n        response = cache.get(\n            self.parse_config.configuration.datacache_config.accessKey\n        )\n    else:\n        download_config = self.parse_config.copy()\n        session.update(\n            create_strategy(StrategyType.DOWNLOAD, download_config).initialize(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n        session.update(\n            create_strategy(StrategyType.DOWNLOAD, download_config).get(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n\n        response = {\"json\": json.loads(cache.get(session.pop(\"key\")))}\n\n    if (\n        not response.get(\"ok\", True)\n        or (\n            response.get(\"status_code\", 200) &lt; 200\n            or response.get(\"status_code\", 200) &gt;= 300\n        )\n        or \"errors\" in response.get(\"json\", {})\n    ):\n        # Error response\n        try:\n            response_object = ErrorResponse(**response.get(\"json\", {}))\n        except ValidationError as exc:\n            error_message = \"Could not validate an error response.\"\n            LOGGER.error(\n                \"%s\\nValidationError: \" \"%s\\nresponse=%r\",\n                error_message,\n                exc,\n                response,\n            )\n            raise OPTIMADEParseError(error_message) from exc\n    else:\n        # Successful response\n        response_model = self.parse_config.downloadUrl.response_model()\n        if response_model:\n            if not isinstance(response_model, tuple):\n                response_model = (response_model,)\n            for model_cls in response_model:\n                try:\n                    response_object = model_cls(**response.get(\"json\", {}))\n                except ValidationError:\n                    pass\n                else:\n                    break\n            else:\n                error_message = \"Could not validate for an expected response model.\"\n                LOGGER.error(\n                    \"%s\\nURL=%r\\n\" \"response_models=%r\\nresponse=%s\",\n                    error_message,\n                    self.parse_config.downloadUrl,\n                    response_model,\n                    response,\n                )\n                raise OPTIMADEParseError(error_message)\n        else:\n            # No \"endpoint\" or unknown\n            try:\n                response_object = Success(**response.get(\"json\", {}))\n            except ValidationError as exc:\n                error_message = \"Unknown or unparseable endpoint.\"\n                LOGGER.error(\n                    \"%s\\nValidatonError: %s\\n\"\n                    \"URL=%r\\nendpoint=%r\\nresponse_model=%r\\nresponse=%s\",\n                    error_message,\n                    exc,\n                    self.parse_config.downloadUrl,\n                    self.parse_config.downloadUrl.endpoint,\n                    response_model,\n                    response,\n                )\n                raise OPTIMADEParseError(error_message) from exc\n\n    if self.parse_config.configuration.return_object:\n        session.optimade_response_object = response_object\n    else:\n        session.optimade_response = model2dict(response_object)\n\n    if session.optimade_config and session.optimade_config.query_parameters:\n        session = session.copy(\n            update={\n                \"optimade_config\": session.optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            session.optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            }\n        )\n\n    if TYPE_CHECKING:  # pragma: no cover\n        assert isinstance(session, OPTIMADEParseSession)  # nosec\n\n    return session\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict[str, Any] | None</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>def initialize(\n    self,\n    session: dict[str, Any] | None = None,  # noqa: ARG002\n) -&gt; SessionUpdate:\n    \"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.resource","title":"<code>resource</code>","text":"<p>OPTIMADE resource strategy.</p>"},{"location":"all_strategies/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy","title":"<code> OPTIMADEResourceStrategy        </code>  <code>dataclass</code>","text":"<p>OPTIMADE Resource Strategy.</p> <p>Implements strategies:</p> <ul> <li><code>(\"accessService\", \"optimade\")</code></li> <li><code>(\"accessService\", \"OPTIMADE\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe\")</code></li> <li><code>(\"accessService\", \"optimade+dlite\")</code></li> <li><code>(\"accessService\", \"OPTIMADE+dlite\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe+dlite\")</code></li> <li><code>(\"accessService\", \"optimade+DLite\")</code></li> <li><code>(\"accessService\", \"OPTIMADE+DLite\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe+DLite\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>@dataclass\nclass OPTIMADEResourceStrategy:\n    \"\"\"OPTIMADE Resource Strategy.\n\n    **Implements strategies**:\n\n    - `(\"accessService\", \"optimade\")`\n    - `(\"accessService\", \"OPTIMADE\")`\n    - `(\"accessService\", \"OPTiMaDe\")`\n    - `(\"accessService\", \"optimade+dlite\")`\n    - `(\"accessService\", \"OPTIMADE+dlite\")`\n    - `(\"accessService\", \"OPTiMaDe+dlite\")`\n    - `(\"accessService\", \"optimade+DLite\")`\n    - `(\"accessService\", \"OPTIMADE+DLite\")`\n    - `(\"accessService\", \"OPTiMaDe+DLite\")`\n\n    \"\"\"\n\n    resource_config: OPTIMADEResourceConfig\n\n    def initialize(\n        self, session: dict[str, Any] | None = None\n    ) -&gt; SessionUpdate | DLiteSessionUpdate:\n        \"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if use_dlite(\n            self.resource_config.accessService,\n            self.resource_config.configuration.use_dlite,\n        ):\n            return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n        return SessionUpdate()\n\n    def get(\n        self, session: SessionUpdate | dict[str, Any] | None = None\n    ) -&gt; OPTIMADEResourceSession:\n        \"\"\"Execute an OPTIMADE query to `accessUrl`.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Configuration values provided in `resource_config.configuration` take\n        precedence over the derived values from `accessUrl`.\n\n        Workflow:\n        1. Update configuration according to session.\n        2. Deconstruct `accessUrl` (done partly by\n           `oteapi_optimade.models.custom_types.OPTIMADEUrl`).\n        3. Reconstruct the complete query URL.\n        4. Send query.\n        5. Store result in data cache.\n\n        Parameters:\n            session: A session-specific dictionary-like context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEResourceSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEResourceSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEResourceSession()\n\n        if session.optimade_config:\n            self.resource_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        optimade_endpoint = self.resource_config.accessUrl.endpoint or \"structures\"\n        optimade_query = (\n            self.resource_config.configuration.query_parameters\n            or OPTIMADEQueryParameters()\n        )\n        LOGGER.debug(\"resource_config: %r\", self.resource_config)\n\n        if self.resource_config.accessUrl.query:\n            parsed_query = parse_qs(self.resource_config.accessUrl.query)\n            for field, value in parsed_query.items():\n                # Only use the latest defined value for any parameter\n                if field not in optimade_query.__fields_set__:\n                    LOGGER.debug(\n                        \"Setting %r from accessUrl (value=%r)\", field, value[-1]\n                    )\n                    setattr(optimade_query, field, value[-1])\n\n        LOGGER.debug(\"optimade_query after update: %r\", optimade_query)\n\n        optimade_url = OPTIMADEUrl(\n            f\"{self.resource_config.accessUrl.base_url}\"\n            f\"/{self.resource_config.accessUrl.version or 'v1'}\"\n            f\"/{optimade_endpoint}?{optimade_query.generate_query_string()}\"\n        )\n        LOGGER.debug(\"OPTIMADE URL to be requested: %s\", optimade_url)\n\n        # Set cache access key to the full OPTIMADE URL.\n        self.resource_config.configuration.datacache_config.accessKey = optimade_url\n\n        # Perform query\n        response = requests.get(\n            optimade_url,\n            allow_redirects=True,\n            timeout=(3, 27),  # timeout in seconds (connect, read)\n        )\n\n        if optimade_query.response_format and optimade_query.response_format != \"json\":\n            error_message = (\n                \"Can only handle JSON responses for now. Requested response format: \"\n                f\"{optimade_query.response_format!r}\"\n            )\n            raise NotImplementedError(error_message)\n\n        cache = DataCache(config=self.resource_config.configuration.datacache_config)\n        cache.add(\n            {\n                \"status_code\": response.status_code,\n                \"ok\": response.ok,\n                \"json\": response.json(),\n            }\n        )\n\n        parse_with_dlite = use_dlite(\n            self.resource_config.accessService,\n            self.resource_config.configuration.use_dlite,\n        )\n\n        parse_mediaType = (\n            \"application/vnd.\"\n            f\"{self.resource_config.accessService.split('+', maxsplit=1)[0]}\"\n        )\n        if parse_with_dlite:\n            parse_mediaType += \"+DLite\"\n        elif optimade_query.response_format:\n            parse_mediaType += f\"+{optimade_query.response_format}\"\n\n        parse_config = {\n            \"downloadUrl\": optimade_url,\n            \"mediaType\": parse_mediaType,\n            \"configuration\": {\n                \"datacache_config\": self.resource_config.configuration.datacache_config,\n                \"return_object\": True,\n            },\n        }\n\n        session.update(\n            create_strategy(StrategyType.PARSE, parse_config).initialize(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n        session.update(\n            create_strategy(StrategyType.PARSE, parse_config).get(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n\n        if \"optimade_response_object\" not in session:\n            error_message = (\n                \"'optimade_response_object' was expected to be present in the session.\"\n            )\n            raise ValueError(error_message)\n\n        optimade_response: OPTIMADEResponse = session.pop(\"optimade_response_object\")\n        if \"optimade_response\" in session and not session.get(\"optimade_response\"):\n            del session[\"optimade_response\"]\n\n        if isinstance(optimade_response, ErrorResponse):\n            optimade_resources = optimade_response.errors\n            session.optimade_resource_model = (\n                f\"{OptimadeError.__module__}:OptimadeError\"\n            )\n        elif isinstance(optimade_response, ReferenceResponseMany):\n            optimade_resources = [\n                Reference(entry).as_dict\n                if isinstance(entry, dict)\n                else Reference(entry.dict()).as_dict\n                for entry in optimade_response.data\n            ]\n            session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n        elif isinstance(optimade_response, ReferenceResponseOne):\n            optimade_resources = [\n                Reference(optimade_response.data).as_dict\n                if isinstance(optimade_response.data, dict)\n                else Reference(optimade_response.data.dict()).as_dict\n            ]\n            session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n        elif isinstance(optimade_response, StructureResponseMany):\n            optimade_resources = [\n                Structure(entry).as_dict\n                if isinstance(entry, dict)\n                else Structure(entry.dict()).as_dict\n                for entry in optimade_response.data\n            ]\n            session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n        elif isinstance(optimade_response, StructureResponseOne):\n            optimade_resources = [\n                Structure(optimade_response.data).as_dict\n                if isinstance(optimade_response.data, dict)\n                else Structure(optimade_response.data.dict()).as_dict\n            ]\n            session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n        else:\n            LOGGER.debug(\n                \"Could not parse response as errors, references or structures. \"\n                \"Response:\\n%r\",\n                optimade_response,\n            )\n            error_message = (\n                \"Could not retrieve errors, references or structures from response \"\n                f\"from {optimade_url}. It could be a valid OPTIMADE API response, \"\n                \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \"\n                \"invalid response completely.\"\n            )\n            raise OPTIMADEParseError(error_message)\n\n        session.optimade_resources = [\n            model2dict(resource) for resource in optimade_resources\n        ]\n\n        if session.optimade_config and session.optimade_config.query_parameters:\n            session = session.copy(\n                update={\n                    \"optimade_config\": session.optimade_config.copy(\n                        update={\n                            \"query_parameters\": model2dict(\n                                session.optimade_config.query_parameters,\n                                exclude_defaults=True,\n                                exclude_unset=True,\n                            )\n                        }\n                    )\n                }\n            )\n\n        if TYPE_CHECKING:  # pragma: no cover\n            assert isinstance(session, OPTIMADEResourceSession)  # nosec\n\n        return session\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Execute an OPTIMADE query to <code>accessUrl</code>.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Configuration values provided in <code>resource_config.configuration</code> take precedence over the derived values from <code>accessUrl</code>.</p> <p>Workflow: 1. Update configuration according to session. 2. Deconstruct <code>accessUrl</code> (done partly by    <code>oteapi_optimade.models.custom_types.OPTIMADEUrl</code>). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>SessionUpdate | dict[str, Any] | None</code> <p>A session-specific dictionary-like context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEResourceSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def get(\n    self, session: SessionUpdate | dict[str, Any] | None = None\n) -&gt; OPTIMADEResourceSession:\n    \"\"\"Execute an OPTIMADE query to `accessUrl`.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Configuration values provided in `resource_config.configuration` take\n    precedence over the derived values from `accessUrl`.\n\n    Workflow:\n    1. Update configuration according to session.\n    2. Deconstruct `accessUrl` (done partly by\n       `oteapi_optimade.models.custom_types.OPTIMADEUrl`).\n    3. Reconstruct the complete query URL.\n    4. Send query.\n    5. Store result in data cache.\n\n    Parameters:\n        session: A session-specific dictionary-like context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEResourceSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEResourceSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEResourceSession()\n\n    if session.optimade_config:\n        self.resource_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    optimade_endpoint = self.resource_config.accessUrl.endpoint or \"structures\"\n    optimade_query = (\n        self.resource_config.configuration.query_parameters\n        or OPTIMADEQueryParameters()\n    )\n    LOGGER.debug(\"resource_config: %r\", self.resource_config)\n\n    if self.resource_config.accessUrl.query:\n        parsed_query = parse_qs(self.resource_config.accessUrl.query)\n        for field, value in parsed_query.items():\n            # Only use the latest defined value for any parameter\n            if field not in optimade_query.__fields_set__:\n                LOGGER.debug(\n                    \"Setting %r from accessUrl (value=%r)\", field, value[-1]\n                )\n                setattr(optimade_query, field, value[-1])\n\n    LOGGER.debug(\"optimade_query after update: %r\", optimade_query)\n\n    optimade_url = OPTIMADEUrl(\n        f\"{self.resource_config.accessUrl.base_url}\"\n        f\"/{self.resource_config.accessUrl.version or 'v1'}\"\n        f\"/{optimade_endpoint}?{optimade_query.generate_query_string()}\"\n    )\n    LOGGER.debug(\"OPTIMADE URL to be requested: %s\", optimade_url)\n\n    # Set cache access key to the full OPTIMADE URL.\n    self.resource_config.configuration.datacache_config.accessKey = optimade_url\n\n    # Perform query\n    response = requests.get(\n        optimade_url,\n        allow_redirects=True,\n        timeout=(3, 27),  # timeout in seconds (connect, read)\n    )\n\n    if optimade_query.response_format and optimade_query.response_format != \"json\":\n        error_message = (\n            \"Can only handle JSON responses for now. Requested response format: \"\n            f\"{optimade_query.response_format!r}\"\n        )\n        raise NotImplementedError(error_message)\n\n    cache = DataCache(config=self.resource_config.configuration.datacache_config)\n    cache.add(\n        {\n            \"status_code\": response.status_code,\n            \"ok\": response.ok,\n            \"json\": response.json(),\n        }\n    )\n\n    parse_with_dlite = use_dlite(\n        self.resource_config.accessService,\n        self.resource_config.configuration.use_dlite,\n    )\n\n    parse_mediaType = (\n        \"application/vnd.\"\n        f\"{self.resource_config.accessService.split('+', maxsplit=1)[0]}\"\n    )\n    if parse_with_dlite:\n        parse_mediaType += \"+DLite\"\n    elif optimade_query.response_format:\n        parse_mediaType += f\"+{optimade_query.response_format}\"\n\n    parse_config = {\n        \"downloadUrl\": optimade_url,\n        \"mediaType\": parse_mediaType,\n        \"configuration\": {\n            \"datacache_config\": self.resource_config.configuration.datacache_config,\n            \"return_object\": True,\n        },\n    }\n\n    session.update(\n        create_strategy(StrategyType.PARSE, parse_config).initialize(\n            model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    )\n    session.update(\n        create_strategy(StrategyType.PARSE, parse_config).get(\n            model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    )\n\n    if \"optimade_response_object\" not in session:\n        error_message = (\n            \"'optimade_response_object' was expected to be present in the session.\"\n        )\n        raise ValueError(error_message)\n\n    optimade_response: OPTIMADEResponse = session.pop(\"optimade_response_object\")\n    if \"optimade_response\" in session and not session.get(\"optimade_response\"):\n        del session[\"optimade_response\"]\n\n    if isinstance(optimade_response, ErrorResponse):\n        optimade_resources = optimade_response.errors\n        session.optimade_resource_model = (\n            f\"{OptimadeError.__module__}:OptimadeError\"\n        )\n    elif isinstance(optimade_response, ReferenceResponseMany):\n        optimade_resources = [\n            Reference(entry).as_dict\n            if isinstance(entry, dict)\n            else Reference(entry.dict()).as_dict\n            for entry in optimade_response.data\n        ]\n        session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n    elif isinstance(optimade_response, ReferenceResponseOne):\n        optimade_resources = [\n            Reference(optimade_response.data).as_dict\n            if isinstance(optimade_response.data, dict)\n            else Reference(optimade_response.data.dict()).as_dict\n        ]\n        session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n    elif isinstance(optimade_response, StructureResponseMany):\n        optimade_resources = [\n            Structure(entry).as_dict\n            if isinstance(entry, dict)\n            else Structure(entry.dict()).as_dict\n            for entry in optimade_response.data\n        ]\n        session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n    elif isinstance(optimade_response, StructureResponseOne):\n        optimade_resources = [\n            Structure(optimade_response.data).as_dict\n            if isinstance(optimade_response.data, dict)\n            else Structure(optimade_response.data.dict()).as_dict\n        ]\n        session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n    else:\n        LOGGER.debug(\n            \"Could not parse response as errors, references or structures. \"\n            \"Response:\\n%r\",\n            optimade_response,\n        )\n        error_message = (\n            \"Could not retrieve errors, references or structures from response \"\n            f\"from {optimade_url}. It could be a valid OPTIMADE API response, \"\n            \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \"\n            \"invalid response completely.\"\n        )\n        raise OPTIMADEParseError(error_message)\n\n    session.optimade_resources = [\n        model2dict(resource) for resource in optimade_resources\n    ]\n\n    if session.optimade_config and session.optimade_config.query_parameters:\n        session = session.copy(\n            update={\n                \"optimade_config\": session.optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            session.optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            }\n        )\n\n    if TYPE_CHECKING:  # pragma: no cover\n        assert isinstance(session, OPTIMADEResourceSession)  # nosec\n\n    return session\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict[str, Any] | None</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate | DLiteSessionUpdate</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def initialize(\n    self, session: dict[str, Any] | None = None\n) -&gt; SessionUpdate | DLiteSessionUpdate:\n    \"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if use_dlite(\n        self.resource_config.accessService,\n        self.resource_config.configuration.use_dlite,\n    ):\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi_optimade.strategies.resource.use_dlite","title":"<code>use_dlite(access_service, use_dlite_flag)</code>","text":"<p>Determine whether DLite should be utilized in the Resource strategy.</p> <p>Parameters:</p> Name Type Description Default <code>access_service</code> <code>str</code> <p>The accessService value from the resource's configuration.</p> required <code>use_dlite_flag</code> <code>bool</code> <p>The strategy-specific <code>use_dlite</code> configuration option.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Based on the accessService value, then whether DLite should be used or not.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def use_dlite(access_service: str, use_dlite_flag: bool) -&gt; bool:\n    \"\"\"Determine whether DLite should be utilized in the Resource strategy.\n\n    Parameters:\n        access_service: The accessService value from the resource's configuration.\n        use_dlite_flag: The strategy-specific `use_dlite` configuration option.\n\n    Returns:\n        Based on the accessService value, then whether DLite should be used or not.\n\n    \"\"\"\n    if (\n        any(dlite_form in access_service for dlite_form in [\"DLite\", \"dlite\"])\n        or use_dlite_flag\n    ):\n        if oteapi_dlite_version is None:\n            error_message = (\n                \"OTEAPI-DLite is not found on the system. This is required to use \"\n                \"DLite with the OTEAPI-OPTIMADE strategies.\"\n            )\n            raise MissingDependency(error_message)\n        return True\n    return False\n</code></pre>"},{"location":"api_reference/exceptions/","title":"exceptions","text":"<p>OTE-API OPTIMADE-specific Python exceptions.</p>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.BaseOteapiOptimadeException","title":"<code> BaseOteapiOptimadeException            (Exception)         </code>","text":"<p>Base OTE-API OPTIMADE exception.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class BaseOteapiOptimadeException(Exception):\n    \"\"\"Base OTE-API OPTIMADE exception.\"\"\"\n</code></pre>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.ConfigurationError","title":"<code> ConfigurationError            (BaseOteapiOptimadeException)         </code>","text":"<p>An error occurred when dealing with strategy configurations.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class ConfigurationError(BaseOteapiOptimadeException):\n    \"\"\"An error occurred when dealing with strategy configurations.\"\"\"\n</code></pre>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.MissingDependency","title":"<code> MissingDependency            (BaseOteapiOptimadeException)         </code>","text":"<p>A required dependency is missing.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class MissingDependency(BaseOteapiOptimadeException):\n    \"\"\"A required dependency is missing.\"\"\"\n</code></pre>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.OPTIMADEParseError","title":"<code> OPTIMADEParseError            (BaseOteapiOptimadeException)         </code>","text":"<p>Could not use OPTIMADE Python tools to parse an OPTIMADE API response.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class OPTIMADEParseError(BaseOteapiOptimadeException):\n    \"\"\"Could not use OPTIMADE Python tools to parse an OPTIMADE API response.\"\"\"\n</code></pre>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.OPTIMADEResponseError","title":"<code> OPTIMADEResponseError            (RequestError)         </code>","text":"<p>An OPTIMADE error was returned from a URL request.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class OPTIMADEResponseError(RequestError):\n    \"\"\"An OPTIMADE error was returned from a URL request.\"\"\"\n</code></pre>"},{"location":"api_reference/exceptions/#oteapi_optimade.exceptions.RequestError","title":"<code> RequestError            (BaseOteapiOptimadeException)         </code>","text":"<p>A general error occured when performing a URL request.</p> Source code in <code>oteapi_optimade/exceptions.py</code> <pre><code>class RequestError(BaseOteapiOptimadeException):\n    \"\"\"A general error occured when performing a URL request.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/","title":"utils","text":"<p>Utility functions to be used in OTEAPI OPTIMADE.</p>"},{"location":"api_reference/utils/#oteapi_optimade.utils.model2dict","title":"<code>model2dict(model, **dict_kwargs)</code>","text":"<p>Convert a pydantic model to a Python dictionary.</p> <p>This works similarly to the <code>dict()</code> method for pydantic models, but ensures any and all nested pydantic models are also converted to dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>BaseModel | dict[str, Any] | Any</code> <p>The pydantic model or Python dictionary to be converted fully to a Python dictionary, through and through.</p> required <code>**dict_kwargs</code> <code>Dict[Any, Any]</code> <p>Keyword arguments to be passed to <code>dict()</code> method calls for pydantic models. Note, this will be used for all <code>dict()</code> method calls.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A Python dictionary, where all nested values that were pydantic models are also converted to Python dictionaries.</p> Source code in <code>oteapi_optimade/utils.py</code> <pre><code>def model2dict(\n    model: BaseModel | dict[str, Any] | Any, **dict_kwargs: Any\n) -&gt; dict[str, Any]:\n    \"\"\"Convert a pydantic model to a Python dictionary.\n\n    This works similarly to the `dict()` method for pydantic models, but ensures any\n    and all nested pydantic models are also converted to dictionaries.\n\n    Parameters:\n        model: The pydantic model or Python dictionary to be converted fully to a\n            Python dictionary, through and through.\n        **dict_kwargs (Dict[Any, Any]): Keyword arguments to be passed to `dict()`\n            method calls for pydantic models.\n            Note, this will be used for _all_ `dict()` method calls.\n\n    Returns:\n        A Python dictionary, where all nested values that were pydantic models are also\n        converted to Python dictionaries.\n\n    \"\"\"\n\n    def _internal(model_: Any) -&gt; Any:\n        \"\"\"Internal function to be used recursively.\"\"\"\n        if isinstance(model_, dict):\n            return {key: _internal(value) for key, value in model_.items()}\n        if isinstance(model_, Iterable) and not isinstance(model_, (bytes, str)):\n            return type(model_)(_internal(value) for value in model_)  # type: ignore[call-arg]\n        if isinstance(model_, BaseModel):\n            return _internal(model_.dict(**dict_kwargs))\n        return model_\n\n    if isinstance(model, BaseModel):\n        res = model.dict(**dict_kwargs)\n    elif isinstance(model, dict):\n        res = deepcopy(model)\n    else:\n        error_message = \"model must be either a pydantic model or a dict.\"\n        raise TypeError(error_message)\n\n    final = _internal(res)\n    if not isinstance(final, dict):\n        error_message = (\n            \"Something went wrong in the conversion of the model to a dictionary. \"\n            f\"The final result ended up being a {type(final)} instead of a dict.\"\n        )\n        raise TypeError(error_message)\n\n    return final\n</code></pre>"},{"location":"api_reference/dlite/parse/","title":"parse","text":"<p>OTEAPI strategy for parsing OPTIMADE structure resources to DLite instances.</p>"},{"location":"api_reference/dlite/parse/#oteapi_optimade.dlite.parse.OPTIMADEDLiteParseStrategy","title":"<code> OPTIMADEDLiteParseStrategy        </code>  <code>dataclass</code>","text":"<p>Parse strategy for JSON.</p> <p>Implements strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.optimade+dlite\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE+dlite\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe+dlite\")</code></li> <li><code>(\"mediaType\", \"application/vnd.optimade+DLite\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE+DLite\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe+DLite\")</code></li> </ul> Source code in <code>oteapi_optimade/dlite/parse.py</code> <pre><code>@dataclass\nclass OPTIMADEDLiteParseStrategy:\n    \"\"\"Parse strategy for JSON.\n\n    **Implements strategies**:\n\n    - `(\"mediaType\", \"application/vnd.optimade+dlite\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE+dlite\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe+dlite\")`\n    - `(\"mediaType\", \"application/vnd.optimade+DLite\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE+DLite\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe+DLite\")`\n\n    \"\"\"\n\n    parse_config: OPTIMADEDLiteParseConfig\n\n    def initialize(self, session: dict[str, Any] | None = None) -&gt; DLiteSessionUpdate:\n        \"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n\n    def get(\n        self, session: SessionUpdate | dict[str, Any] | None = None\n    ) -&gt; OPTIMADEParseSession:\n        \"\"\"Request and parse an OPTIMADE response using OPT.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Configuration values provided in `resource_config.configuration` take\n        precedence over the derived values from `downloadUrl`.\n\n        Workflow:\n\n        1. Request OPTIMADE response.\n        2. Parse as an OPTIMADE Python tools (OPT) pydantic response model.\n\n        ---\n\n        The OPTIMADE Structure needs to be parsed into DLite instances inside-out,\n        meaning the most nested data structures must first be parsed, and then the ones\n        1 layer up and so on until the most upper layer can be parsed.\n\n        Parameters:\n            session: A session-specific dictionary-like context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        session = OPTIMADEParseStrategy(self.parse_config).get(session)\n\n        entities_path = Path(__file__).resolve().parent.resolve() / \"entities\"\n\n        dlite.storage_path.append(str(entities_path / \"*.yaml\"))\n\n        # JSONAPIResourceLinks = dlite.Instance.from_url(\n        #     f\"yaml://{entities_path}/JSONAPIResourceLinks.yaml\"\n        # )\n        OPTIMADEStructure = dlite.Instance.from_url(\n            f\"yaml://{entities_path}/OPTIMADEStructure.yaml\"\n        )\n        OPTIMADEStructureAssembly = dlite.Instance.from_url(\n            f\"yaml://{entities_path}/OPTIMADEStructureAssembly.yaml\"\n        )\n        OPTIMADEStructureAttributes = dlite.Instance.from_url(\n            f\"yaml://{entities_path}/OPTIMADEStructureAttributes.yaml\"\n        )\n        OPTIMADEStructureSpecies = dlite.Instance.from_url(\n            f\"yaml://{entities_path}/OPTIMADEStructureSpecies.yaml\"\n        )\n\n        error_message_supporting_only_structures = (\n            \"The DLite OPTIMADE Parser currently only supports structures entities.\"\n        )\n\n        if self.parse_config.configuration.return_object:\n            # The response is given as a \"proper\" pydantic data model instance\n\n            if \"optimade_response_object\" not in session:\n                error_message = (\n                    \"'optimade_response_object' was expected to be present in the \"\n                    \"session.\"\n                )\n                raise ValueError(error_message)\n\n            # Currently, only \"structures\" entries are supported and handled\n            if isinstance(session.optimade_response_object, StructureResponseMany):\n                structures = [\n                    Structure(entry)\n                    if isinstance(entry, dict)\n                    else Structure(entry.dict())\n                    for entry in session.optimade_response_object.data\n                ]\n            elif isinstance(session.optimade_response_object, StructureResponseOne):\n                structures = [\n                    Structure(session.optimade_response_object.data)\n                    if isinstance(session.optimade_response_object.data, dict)\n                    else Structure(session.optimade_response_object.data.dict())\n                ]\n            elif isinstance(session.optimade_response_object, Success):\n                if isinstance(session.optimade_response_object.data, dict):\n                    structures = [Structure(session.optimade_response_object.data)]\n                elif isinstance(session.optimade_response_object.data, BaseModel):\n                    structures = [\n                        Structure(session.optimade_response_object.data.dict())\n                    ]\n                elif isinstance(session.optimade_response_object.data, list):\n                    structures = [\n                        Structure(entry)\n                        if isinstance(entry, dict)\n                        else Structure(entry.dict())\n                        for entry in session.optimade_response_object.data\n                    ]\n                else:\n                    LOGGER.debug(\n                        \"Could not determine what to do with `data`. Type %s.\",\n                        type(session.optimade_response_object.data),\n                    )\n                    error_message = \"Could not parse `data` entry in response.\"\n                    raise OPTIMADEParseError(error_message)\n            else:\n                LOGGER.debug(\n                    \"Got currently unsupported response type %s. Only structures are \"\n                    \"supported.\",\n                    session.optimade_response_object.__class__.__name__,\n                )\n                raise OPTIMADEParseError(error_message_supporting_only_structures)\n        else:\n            # The response is given as pure Python dictionary\n\n            if \"optimade_response\" not in session:\n                error_message = (\n                    \"'optimade_response' was expected to be present in the session.\"\n                )\n                raise ValueError(error_message)\n\n            if not session.optimade_response or \"data\" not in session.optimade_response:\n                LOGGER.debug(\"Not a successful response - no 'data' entry found.\")\n                return session\n\n            if isinstance(session.optimade_response[\"data\"], list):\n                try:\n                    structures = [\n                        Structure(entry) for entry in session.optimade_response[\"data\"]\n                    ]\n                except ValidationError as exc:\n                    LOGGER.debug(\n                        \"Could not parse list of 'data' entries as structures.\"\n                    )\n                    raise OPTIMADEParseError(\n                        error_message_supporting_only_structures\n                    ) from exc\n            elif session.optimade_response is not None:\n                try:\n                    structures = [Structure(session.optimade_response[\"data\"])]\n                except ValidationError as exc:\n                    LOGGER.debug(\"Could not parse single 'data' entry as a structure.\")\n                    raise OPTIMADEParseError(\n                        error_message_supporting_only_structures\n                    ) from exc\n            else:\n                LOGGER.debug(\"Could not parse 'data' entries as structures.\")  # type: ignore[unreachable]\n                raise OPTIMADEParseError(error_message_supporting_only_structures)\n\n        dlite_collection = get_collection(session)\n\n        # DLite-fy OPTIMADE structures\n        for structure in structures:\n            new_structure_attributes: dict[str, Any] = {}\n\n            # Most inner layer: assemblies &amp; species\n            if structure.attributes.assemblies:\n                # Non-zero length list of assemblies (which could be a list of dicts or\n                # a list of pydantic models)\n\n                new_structure_attributes[\"assemblies\"] = []\n\n                for assembly in structure.attributes.assemblies:\n                    # Ensure we're dealing with a normal Python dict\n                    assembly_dict = (\n                        assembly.dict(exclude_none=True)\n                        if isinstance(assembly, BaseModel)\n                        else assembly\n                    )\n\n                    dimensions = {\n                        \"ngroups\": len(\n                            assembly_dict.get(\"group_probabilities\", []) or []\n                        ),\n                        \"nsites\": len(assembly_dict.get(\"sites_in_groups\", []) or []),\n                    }\n                    new_structure_attributes[\"assemblies\"].append(\n                        OPTIMADEStructureAssembly(\n                            dimensions=dimensions, properties=assembly_dict\n                        )\n                    )\n\n            if structure.attributes.species:\n                # Non-zero length list of species (which could be a list of dicts or a\n                # list of pydantic models)\n\n                new_structure_attributes[\"species\"] = []\n\n                for species_individual in structure.attributes.species:\n                    # Ensure we're dealing with a normal Python dict\n                    species_individual_dict = (\n                        species_individual.dict(exclude_none=True)\n                        if isinstance(species_individual, BaseModel)\n                        else species_individual\n                    )\n\n                    dimensions = {\n                        \"nelements\": len(\n                            species_individual_dict.get(\"chemical_symbols\", []) or []\n                        ),\n                        \"nattached_elements\": len(\n                            species_individual_dict.get(\"attached\", []) or []\n                        ),\n                    }\n                    new_structure_attributes[\"species\"].append(\n                        OPTIMADEStructureSpecies(\n                            dimensions=dimensions,\n                            properties=species_individual_dict,\n                        )\n                    )\n\n            # Attributes\n            new_structure_attributes.update(\n                structure.attributes.dict(\n                    exclude={\"species\", \"assemblies\", \"nelements\", \"nsites\"}\n                )\n            )\n            for key in list(new_structure_attributes):\n                if key.startswith(\"_\"):\n                    new_structure_attributes.pop(key)\n\n            # Structure features values are Enum values, so we need to convert them to\n            # their string (true) values\n            new_structure_attributes[\"structure_features\"] = [\n                _.value for _ in new_structure_attributes[\"structure_features\"]\n            ]\n\n            new_structure = OPTIMADEStructure(\n                dimensions={},\n                properties={\n                    \"attributes\": OPTIMADEStructureAttributes(\n                        dimensions={\n                            \"nelements\": structure.attributes.nelements or 0,\n                            \"dimensionality\": 3,\n                            \"nsites\": structure.attributes.nsites or 0,\n                            \"nspecies\": len(structure.attributes.species)\n                            if structure.attributes.species\n                            else 0,\n                            \"nstructure_features\": len(\n                                structure.attributes.structure_features\n                            ),\n                        },\n                        properties=new_structure_attributes,\n                    ),\n                    \"type\": structure.entry.type,\n                    \"id\": structure.entry.id,\n                },\n            )\n            dlite_collection.add(label=structure.entry.id, inst=new_structure)\n\n        update_collection(collection=dlite_collection)\n\n        return session\n</code></pre>"},{"location":"api_reference/dlite/parse/#oteapi_optimade.dlite.parse.OPTIMADEDLiteParseStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Request and parse an OPTIMADE response using OPT.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Configuration values provided in <code>resource_config.configuration</code> take precedence over the derived values from <code>downloadUrl</code>.</p> <p>Workflow:</p> <ol> <li>Request OPTIMADE response.</li> <li>Parse as an OPTIMADE Python tools (OPT) pydantic response model.</li> </ol> <p>The OPTIMADE Structure needs to be parsed into DLite instances inside-out, meaning the most nested data structures must first be parsed, and then the ones 1 layer up and so on until the most upper layer can be parsed.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>SessionUpdate | dict[str, Any] | None</code> <p>A session-specific dictionary-like context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEParseSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/dlite/parse.py</code> <pre><code>def get(\n    self, session: SessionUpdate | dict[str, Any] | None = None\n) -&gt; OPTIMADEParseSession:\n    \"\"\"Request and parse an OPTIMADE response using OPT.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Configuration values provided in `resource_config.configuration` take\n    precedence over the derived values from `downloadUrl`.\n\n    Workflow:\n\n    1. Request OPTIMADE response.\n    2. Parse as an OPTIMADE Python tools (OPT) pydantic response model.\n\n    ---\n\n    The OPTIMADE Structure needs to be parsed into DLite instances inside-out,\n    meaning the most nested data structures must first be parsed, and then the ones\n    1 layer up and so on until the most upper layer can be parsed.\n\n    Parameters:\n        session: A session-specific dictionary-like context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    session = OPTIMADEParseStrategy(self.parse_config).get(session)\n\n    entities_path = Path(__file__).resolve().parent.resolve() / \"entities\"\n\n    dlite.storage_path.append(str(entities_path / \"*.yaml\"))\n\n    # JSONAPIResourceLinks = dlite.Instance.from_url(\n    #     f\"yaml://{entities_path}/JSONAPIResourceLinks.yaml\"\n    # )\n    OPTIMADEStructure = dlite.Instance.from_url(\n        f\"yaml://{entities_path}/OPTIMADEStructure.yaml\"\n    )\n    OPTIMADEStructureAssembly = dlite.Instance.from_url(\n        f\"yaml://{entities_path}/OPTIMADEStructureAssembly.yaml\"\n    )\n    OPTIMADEStructureAttributes = dlite.Instance.from_url(\n        f\"yaml://{entities_path}/OPTIMADEStructureAttributes.yaml\"\n    )\n    OPTIMADEStructureSpecies = dlite.Instance.from_url(\n        f\"yaml://{entities_path}/OPTIMADEStructureSpecies.yaml\"\n    )\n\n    error_message_supporting_only_structures = (\n        \"The DLite OPTIMADE Parser currently only supports structures entities.\"\n    )\n\n    if self.parse_config.configuration.return_object:\n        # The response is given as a \"proper\" pydantic data model instance\n\n        if \"optimade_response_object\" not in session:\n            error_message = (\n                \"'optimade_response_object' was expected to be present in the \"\n                \"session.\"\n            )\n            raise ValueError(error_message)\n\n        # Currently, only \"structures\" entries are supported and handled\n        if isinstance(session.optimade_response_object, StructureResponseMany):\n            structures = [\n                Structure(entry)\n                if isinstance(entry, dict)\n                else Structure(entry.dict())\n                for entry in session.optimade_response_object.data\n            ]\n        elif isinstance(session.optimade_response_object, StructureResponseOne):\n            structures = [\n                Structure(session.optimade_response_object.data)\n                if isinstance(session.optimade_response_object.data, dict)\n                else Structure(session.optimade_response_object.data.dict())\n            ]\n        elif isinstance(session.optimade_response_object, Success):\n            if isinstance(session.optimade_response_object.data, dict):\n                structures = [Structure(session.optimade_response_object.data)]\n            elif isinstance(session.optimade_response_object.data, BaseModel):\n                structures = [\n                    Structure(session.optimade_response_object.data.dict())\n                ]\n            elif isinstance(session.optimade_response_object.data, list):\n                structures = [\n                    Structure(entry)\n                    if isinstance(entry, dict)\n                    else Structure(entry.dict())\n                    for entry in session.optimade_response_object.data\n                ]\n            else:\n                LOGGER.debug(\n                    \"Could not determine what to do with `data`. Type %s.\",\n                    type(session.optimade_response_object.data),\n                )\n                error_message = \"Could not parse `data` entry in response.\"\n                raise OPTIMADEParseError(error_message)\n        else:\n            LOGGER.debug(\n                \"Got currently unsupported response type %s. Only structures are \"\n                \"supported.\",\n                session.optimade_response_object.__class__.__name__,\n            )\n            raise OPTIMADEParseError(error_message_supporting_only_structures)\n    else:\n        # The response is given as pure Python dictionary\n\n        if \"optimade_response\" not in session:\n            error_message = (\n                \"'optimade_response' was expected to be present in the session.\"\n            )\n            raise ValueError(error_message)\n\n        if not session.optimade_response or \"data\" not in session.optimade_response:\n            LOGGER.debug(\"Not a successful response - no 'data' entry found.\")\n            return session\n\n        if isinstance(session.optimade_response[\"data\"], list):\n            try:\n                structures = [\n                    Structure(entry) for entry in session.optimade_response[\"data\"]\n                ]\n            except ValidationError as exc:\n                LOGGER.debug(\n                    \"Could not parse list of 'data' entries as structures.\"\n                )\n                raise OPTIMADEParseError(\n                    error_message_supporting_only_structures\n                ) from exc\n        elif session.optimade_response is not None:\n            try:\n                structures = [Structure(session.optimade_response[\"data\"])]\n            except ValidationError as exc:\n                LOGGER.debug(\"Could not parse single 'data' entry as a structure.\")\n                raise OPTIMADEParseError(\n                    error_message_supporting_only_structures\n                ) from exc\n        else:\n            LOGGER.debug(\"Could not parse 'data' entries as structures.\")  # type: ignore[unreachable]\n            raise OPTIMADEParseError(error_message_supporting_only_structures)\n\n    dlite_collection = get_collection(session)\n\n    # DLite-fy OPTIMADE structures\n    for structure in structures:\n        new_structure_attributes: dict[str, Any] = {}\n\n        # Most inner layer: assemblies &amp; species\n        if structure.attributes.assemblies:\n            # Non-zero length list of assemblies (which could be a list of dicts or\n            # a list of pydantic models)\n\n            new_structure_attributes[\"assemblies\"] = []\n\n            for assembly in structure.attributes.assemblies:\n                # Ensure we're dealing with a normal Python dict\n                assembly_dict = (\n                    assembly.dict(exclude_none=True)\n                    if isinstance(assembly, BaseModel)\n                    else assembly\n                )\n\n                dimensions = {\n                    \"ngroups\": len(\n                        assembly_dict.get(\"group_probabilities\", []) or []\n                    ),\n                    \"nsites\": len(assembly_dict.get(\"sites_in_groups\", []) or []),\n                }\n                new_structure_attributes[\"assemblies\"].append(\n                    OPTIMADEStructureAssembly(\n                        dimensions=dimensions, properties=assembly_dict\n                    )\n                )\n\n        if structure.attributes.species:\n            # Non-zero length list of species (which could be a list of dicts or a\n            # list of pydantic models)\n\n            new_structure_attributes[\"species\"] = []\n\n            for species_individual in structure.attributes.species:\n                # Ensure we're dealing with a normal Python dict\n                species_individual_dict = (\n                    species_individual.dict(exclude_none=True)\n                    if isinstance(species_individual, BaseModel)\n                    else species_individual\n                )\n\n                dimensions = {\n                    \"nelements\": len(\n                        species_individual_dict.get(\"chemical_symbols\", []) or []\n                    ),\n                    \"nattached_elements\": len(\n                        species_individual_dict.get(\"attached\", []) or []\n                    ),\n                }\n                new_structure_attributes[\"species\"].append(\n                    OPTIMADEStructureSpecies(\n                        dimensions=dimensions,\n                        properties=species_individual_dict,\n                    )\n                )\n\n        # Attributes\n        new_structure_attributes.update(\n            structure.attributes.dict(\n                exclude={\"species\", \"assemblies\", \"nelements\", \"nsites\"}\n            )\n        )\n        for key in list(new_structure_attributes):\n            if key.startswith(\"_\"):\n                new_structure_attributes.pop(key)\n\n        # Structure features values are Enum values, so we need to convert them to\n        # their string (true) values\n        new_structure_attributes[\"structure_features\"] = [\n            _.value for _ in new_structure_attributes[\"structure_features\"]\n        ]\n\n        new_structure = OPTIMADEStructure(\n            dimensions={},\n            properties={\n                \"attributes\": OPTIMADEStructureAttributes(\n                    dimensions={\n                        \"nelements\": structure.attributes.nelements or 0,\n                        \"dimensionality\": 3,\n                        \"nsites\": structure.attributes.nsites or 0,\n                        \"nspecies\": len(structure.attributes.species)\n                        if structure.attributes.species\n                        else 0,\n                        \"nstructure_features\": len(\n                            structure.attributes.structure_features\n                        ),\n                    },\n                    properties=new_structure_attributes,\n                ),\n                \"type\": structure.entry.type,\n                \"id\": structure.entry.id,\n            },\n        )\n        dlite_collection.add(label=structure.entry.id, inst=new_structure)\n\n    update_collection(collection=dlite_collection)\n\n    return session\n</code></pre>"},{"location":"api_reference/dlite/parse/#oteapi_optimade.dlite.parse.OPTIMADEDLiteParseStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict[str, Any] | None</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>DLiteSessionUpdate</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/dlite/parse.py</code> <pre><code>def initialize(self, session: dict[str, Any] | None = None) -&gt; DLiteSessionUpdate:\n    \"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n</code></pre>"},{"location":"api_reference/models/config/","title":"config","text":"<p>General OPTIMADE configuration models.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.DEFAULT_CACHE_CONFIG_VALUES","title":"<code>DEFAULT_CACHE_CONFIG_VALUES</code>","text":"<p>Set the <code>expireTime</code> and <code>tag</code> to default values for the data cache.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig","title":"<code> OPTIMADEConfig            (AttrDict)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE configuration.</p> Source code in <code>oteapi_optimade/models/config.py</code> <pre><code>class OPTIMADEConfig(AttrDict):  # type: ignore[misc]\n    \"\"\"OPTIMADE configuration.\"\"\"\n\n    version: str = Field(\n        \"v1\",\n        description=\"The version part of the OPTIMADE versioned base URL.\",\n        regex=r\"^v[0-9]+(\\.[0-9]+){,2}$\",\n    )\n    endpoint: Literal[\"references\", \"structures\"] = Field(\n        \"structures\",\n        description=\"Supported OPTIMADE entry resource endpoint.\",\n    )\n    query_parameters: Optional[OPTIMADEQueryParameters] = Field(\n        None,\n        description=\"URL query parameters to be used in the OPTIMADE query.\",\n    )\n    datacache_config: DataCacheConfig = Field(\n        DataCacheConfig(**DEFAULT_CACHE_CONFIG_VALUES),\n        description=\"Configuration options for the local data cache.\",\n    )\n    return_object: bool = Field(\n        False,\n        description=(\n            \"Whether or not to return a response object (using the pydantic model).\\n\"\n            \"\\nImportant:\\n    This should _only_ be used if the strategy is called \"\n            \"directly and not via an OTEAPI REST API service.\"\n        ),\n    )\n    use_dlite: bool = Field(\n        False,\n        description=\"Whether or not to store the results in a DLite Collection.\",\n    )\n\n    @validator(\"datacache_config\")\n    def default_datacache_config(cls, value: DataCacheConfig) -&gt; DataCacheConfig:\n        \"\"\"Use default values for `DataCacheConfig` if not supplied.\"\"\"\n        original_set_values = len(value.__fields_set__)\n\n        for field, default_value in DEFAULT_CACHE_CONFIG_VALUES.items():\n            if field in value.__fields_set__:\n                # Use the set value instead of the default\n                continue\n            setattr(value, field, default_value)\n\n        if len(value.__fields_set__) &gt; original_set_values:\n            # Re-validate model and return it\n            return value.validate(\n                {\n                    field: field_value\n                    for field, field_value in value.dict().items()\n                    if field in value.__fields_set__\n                }\n            )\n        return value\n</code></pre>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.datacache_config","title":"<code>datacache_config: DataCacheConfig</code>  <code>pydantic-field</code>","text":"<p>Configuration options for the local data cache.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.endpoint","title":"<code>endpoint: Literal['references', 'structures']</code>  <code>pydantic-field</code>","text":"<p>Supported OPTIMADE entry resource endpoint.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.query_parameters","title":"<code>query_parameters: OPTIMADEQueryParameters</code>  <code>pydantic-field</code>","text":"<p>URL query parameters to be used in the OPTIMADE query.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.return_object","title":"<code>return_object: bool</code>  <code>pydantic-field</code>","text":"<p>Whether or not to return a response object (using the pydantic model).</p> <p>Important</p> <p>This should only be used if the strategy is called directly and not via an OTEAPI REST API service.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.use_dlite","title":"<code>use_dlite: bool</code>  <code>pydantic-field</code>","text":"<p>Whether or not to store the results in a DLite Collection.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.version","title":"<code>version: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>The version part of the OPTIMADE versioned base URL.</p>"},{"location":"api_reference/models/config/#oteapi_optimade.models.config.OPTIMADEConfig.default_datacache_config","title":"<code>default_datacache_config(value)</code>  <code>classmethod</code>","text":"<p>Use default values for <code>DataCacheConfig</code> if not supplied.</p> Source code in <code>oteapi_optimade/models/config.py</code> <pre><code>@validator(\"datacache_config\")\ndef default_datacache_config(cls, value: DataCacheConfig) -&gt; DataCacheConfig:\n    \"\"\"Use default values for `DataCacheConfig` if not supplied.\"\"\"\n    original_set_values = len(value.__fields_set__)\n\n    for field, default_value in DEFAULT_CACHE_CONFIG_VALUES.items():\n        if field in value.__fields_set__:\n            # Use the set value instead of the default\n            continue\n        setattr(value, field, default_value)\n\n    if len(value.__fields_set__) &gt; original_set_values:\n        # Re-validate model and return it\n        return value.validate(\n            {\n                field: field_value\n                for field, field_value in value.dict().items()\n                if field in value.__fields_set__\n            }\n        )\n    return value\n</code></pre>"},{"location":"api_reference/models/custom_types/","title":"custom_types","text":"<p>Custom \"pydantic\" types used in OTEAPI-OPTIMADE.</p>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.LOGGER","title":"<code>LOGGER</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl","title":"<code> OPTIMADEUrl            (str)         </code>","text":"<p>A deconstructed OPTIMADE URL.</p> <p>An OPTIMADE URL is made up in the following way:</p> <pre><code>&lt;BASE URL&gt;/[&lt;VERSION&gt;/]&lt;ENDPOINT&gt;?&lt;QUERY PARAMETERS&gt;\n</code></pre> <p>Where parts in square brackets (<code>[]</code>) are optional.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>class OPTIMADEUrl(str):\n    \"\"\"A deconstructed OPTIMADE URL.\n\n    An OPTIMADE URL is made up in the following way:\n\n        &lt;BASE URL&gt;/[&lt;VERSION&gt;/]&lt;ENDPOINT&gt;?&lt;QUERY PARAMETERS&gt;\n\n    Where parts in square brackets (`[]`) are optional.\n    \"\"\"\n\n    strip_whitespace = True\n    min_length = 1\n    # https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers\n    max_length = 2083\n    allowed_schemes: ClassVar[set[Literal[\"http\", \"https\"]]] = {\"http\", \"https\"}\n    tld_required = False\n    user_required = False\n\n    __slots__ = (\n        \"base_url\",\n        \"version\",\n        \"endpoint\",\n        \"query\",\n        \"scheme\",\n        \"tld\",\n        \"host_type\",\n    )\n\n    @no_type_check\n    def __new__(cls, url: str | None = None, **kwargs) -&gt; object:\n        return str.__new__(\n            cls,\n            cls.build(**kwargs) if url is None else url,\n        )\n\n    def __init__(\n        self,\n        url: str,\n        *,\n        base_url: str | None = None,\n        version: str | None = None,\n        endpoint: str | None = None,\n        query: str | None = None,\n        scheme: str | None = None,\n        tld: str | None = None,\n        host_type: str = \"domain\",\n    ) -&gt; None:\n        str.__init__(url)\n        self.base_url = base_url\n        self.version = version\n        self.endpoint = endpoint\n        self.query = query\n        self.scheme = scheme\n        self.tld = tld\n        self.host_type = host_type\n\n    @classmethod\n    def build(\n        cls,\n        *,\n        base_url: str,\n        version: str | None = None,\n        endpoint: str | None = None,\n        query: str | None = None,\n        **_kwargs: str,\n    ) -&gt; str:\n        \"\"\"Build complete URL from URL parts.\"\"\"\n        url = base_url.rstrip(\"/\")\n        if version:\n            url += f\"/{version}\"\n        if endpoint:\n            url += f\"/{endpoint}\"\n        if query:\n            url += f\"?{query}\"\n        return url\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: dict[str, Any]) -&gt; None:\n        update_not_none(\n            field_schema,\n            minLength=cls.min_length,\n            maxLength=cls.max_length,\n            format=\"uri\",\n        )\n\n    @classmethod\n    def __get_validators__(cls) -&gt; CallableGenerator:\n        yield cls.validate\n\n    @staticmethod\n    def urlquote_qs(url: str) -&gt; str:\n        \"\"\"Use `urllib.parse.quote` for query part of URL.\"\"\"\n        parsed_url = urlparse(url)\n        quoted_query = urlquote(parsed_url.query, safe=\"=&amp;,\")\n        parsed_url_list = list(parsed_url)\n        parsed_url_list[-2] = quoted_query\n        return urlunparse(parsed_url_list)\n\n    @classmethod\n    def validate(cls, value: Any, field: ModelField, config: BaseConfig) -&gt; OPTIMADEUrl:\n        \"\"\"Pydantic validation of an OPTIMADE URL.\"\"\"\n        if type(value) == cls:\n            return value\n\n        value: str = str_validator(value)\n        if cls.strip_whitespace:\n            value = value.strip()\n        url: str = cast(str, constr_length_validator(value, field, config))\n        url = cls.urlquote_qs(url)\n\n        url_match = url_regex().match(url)\n        if url_match is None:\n            error_message = f\"Cannot match URL ({url!r}) as a valid URL.\"\n            raise ValueError(error_message)\n\n        original_parts = cast(\"Parts\", url_match.groupdict())\n        parts = cls.apply_default_parts(original_parts)\n        host, tld, host_type, rebuild = cls.validate_host(parts)\n        optimade_parts = cls.build_optimade_parts(parts, host)\n        optimade_parts = cls.validate_parts(parts, optimade_parts)\n\n        if url_match.end() != len(url):\n            raise errors.UrlExtraError(extra=url[url_match.end() :])\n\n        return cls(  # type: ignore[no-any-return]\n            None if rebuild else url,\n            base_url=optimade_parts[\"base_url\"],\n            version=optimade_parts[\"version\"],\n            endpoint=optimade_parts[\"endpoint\"],\n            query=optimade_parts[\"query\"],\n            scheme=parts[\"scheme\"],\n            tld=tld,\n            host_type=host_type,\n        )\n\n    @classmethod\n    def validate_host(cls, parts: Parts) -&gt; tuple[str, str | None, str, bool]:\n        \"\"\"Validate host-part of the URL.\"\"\"\n        host: str | None = None\n        tld: str | None = None\n        rebuild: bool = False\n        for host_type in (\"domain\", \"ipv4\", \"ipv6\"):\n            host = parts[host_type]  # type: ignore[literal-required]\n            if host:\n                break\n        else:\n            raise errors.UrlHostError()\n\n        if host_type == \"domain\":\n            is_international = False\n            domain = ascii_domain_regex().fullmatch(host)\n            if domain is None:\n                domain = int_domain_regex().fullmatch(host)\n                if domain is None:\n                    raise errors.UrlHostError()\n                is_international = True\n\n            tld = domain.group(\"tld\")\n            if tld is None and not is_international:\n                domain = int_domain_regex().fullmatch(host)\n                if domain is None:\n                    error_message = \"domain cannot be None\"\n                    raise ValueError(error_message)\n                tld = domain.group(\"tld\")\n                is_international = True\n\n            if tld is not None:\n                tld = tld[1:]\n            elif cls.tld_required:\n                raise errors.UrlHostTldError()\n\n            if is_international:\n                host_type = \"int_domain\"\n                rebuild = True\n                host = host.encode(\"idna\").decode(\"ascii\")\n                if tld is not None:\n                    tld = tld.encode(\"idna\").decode(\"ascii\")\n\n        return host, tld, host_type, rebuild\n\n    @staticmethod\n    def get_default_parts(parts: Parts) -&gt; Parts:\n        \"\"\"Dictionary of default URL-part values.\"\"\"\n        return {\"port\": \"80\" if parts[\"scheme\"] == \"http\" else \"443\"}\n\n    @classmethod\n    def apply_default_parts(cls, parts: Parts) -&gt; Parts:\n        \"\"\"Apply default URL-part values if no value is given.\"\"\"\n        for key, value in cls.get_default_parts(parts).items():\n            if not parts[key]:  # type: ignore[literal-required]\n                parts[key] = value  # type: ignore[literal-required]\n        return parts\n\n    @classmethod\n    def build_optimade_parts(cls, parts: Parts, host: str) -&gt; OPTIMADEParts:\n        \"\"\"Convert URL parts to equivalent OPTIMADE URL parts.\"\"\"\n        base_url = f\"{parts['scheme']}://\"\n        if parts[\"user\"]:\n            base_url += parts[\"user\"]\n        if parts[\"password\"]:\n            base_url += f\":{parts['password']}\"\n        if parts[\"user\"] or parts[\"password\"]:\n            base_url += \"@\"\n        base_url += host\n        # Hide port if it's a standard HTTP (80) or HTTPS (443) port.\n        if parts[\"port\"] and parts[\"port\"] not in (\"80\", \"443\"):\n            base_url += f\":{parts['port']}\"\n        if parts[\"path\"]:\n            base_url += parts[\"path\"]\n\n        base_url_match = _OPTIMADE_BASE_URL_REGEX.fullmatch(base_url)\n        LOGGER.debug(\n            \"OPTIMADE base URL regex match groups: %s\",\n            base_url_match.groupdict() if base_url_match else base_url_match,\n        )\n        if base_url_match is None:\n            error_message = \"Could not match given string with OPTIMADE base URL regex.\"\n            raise ValueError(error_message)\n\n        endpoint_match = _OPTIMADE_ENDPOINT_REGEX.findall(\n            base_url_match.group(\"path\") if base_url_match.group(\"path\") else \"\"\n        )\n        LOGGER.debug(\"OPTIMADE endpoint regex matches: %s\", endpoint_match)\n        for path_version, path_endpoint in endpoint_match:  # noqa: B007\n            if path_endpoint:\n                break\n        else:\n            LOGGER.debug(\"Could not match given string with OPTIMADE endpoint regex.\")\n            path_version, path_endpoint = \"\", \"\"\n\n        base_url = base_url_match.group(\"base_url\")\n        if path_version:\n            base_url = base_url[: -(len(path_version) + len(path_endpoint) + 2)]\n        elif path_endpoint:\n            base_url = base_url[: -(len(path_endpoint) + 1)]\n\n        optimade_parts = {\n            \"base_url\": base_url.rstrip(\"/\"),\n            \"version\": path_version or None,\n            \"endpoint\": path_endpoint or None,\n            \"query\": parts[\"query\"],\n        }\n        return cast(\"OPTIMADEParts\", optimade_parts)\n\n    @classmethod\n    def validate_parts(\n        cls, parts: Parts, optimade_parts: OPTIMADEParts\n    ) -&gt; OPTIMADEParts:\n        \"\"\"\n        A method used to validate parts of an URL.\n        Could be overridden to set default values for parts if missing\n        \"\"\"\n        scheme = parts[\"scheme\"]\n        if scheme is None:\n            raise errors.UrlSchemeError()\n\n        if cls.allowed_schemes and scheme.lower() not in cls.allowed_schemes:\n            raise errors.UrlSchemePermittedError(set(cls.allowed_schemes))\n\n        port = parts[\"port\"]\n        if port is not None and int(port) &gt; 65_535:\n            raise errors.UrlPortError()\n\n        user = parts[\"user\"]\n        if cls.user_required and user is None:\n            raise errors.UrlUserInfoError()\n\n        base_url = optimade_parts[\"base_url\"]\n        if base_url is None:\n            raise errors.UrlError()\n\n        return optimade_parts\n\n    def __repr__(self) -&gt; str:\n        extra = \", \".join(\n            f\"{n}={getattr(self, n)!r}\"\n            for n in self.__slots__\n            if getattr(self, n) is not None\n        )\n        return f\"{self.__class__.__name__}({super().__repr__()}, {extra})\"\n\n    def response_model(self) -&gt; tuple[Success, ...] | Success | None:\n        \"\"\"Return the endpoint's corresponding response model (from OPT).\"\"\"\n        if not self.endpoint or self.endpoint == \"versions\":\n            return None\n        return {\n            \"info\": (InfoResponse, EntryInfoResponse),\n            \"links\": LinksResponse,\n            \"structures\": (StructureResponseMany, StructureResponseOne),\n            \"references\": (ReferenceResponseMany, ReferenceResponseOne),\n            \"calculations\": (EntryResponseMany, EntryResponseOne),\n        }.get(self.endpoint, Success)\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.allowed_schemes","title":"<code>allowed_schemes</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.max_length","title":"<code>max_length</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.min_length","title":"<code>min_length</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.strip_whitespace","title":"<code>strip_whitespace</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.tld_required","title":"<code>tld_required</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.user_required","title":"<code>user_required</code>","text":""},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.__init__","title":"<code>__init__(self, url, *, base_url=None, version=None, endpoint=None, query=None, scheme=None, tld=None, host_type='domain')</code>  <code>special</code>","text":"Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    *,\n    base_url: str | None = None,\n    version: str | None = None,\n    endpoint: str | None = None,\n    query: str | None = None,\n    scheme: str | None = None,\n    tld: str | None = None,\n    host_type: str = \"domain\",\n) -&gt; None:\n    str.__init__(url)\n    self.base_url = base_url\n    self.version = version\n    self.endpoint = endpoint\n    self.query = query\n    self.scheme = scheme\n    self.tld = tld\n    self.host_type = host_type\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.apply_default_parts","title":"<code>apply_default_parts(parts)</code>  <code>classmethod</code>","text":"<p>Apply default URL-part values if no value is given.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef apply_default_parts(cls, parts: Parts) -&gt; Parts:\n    \"\"\"Apply default URL-part values if no value is given.\"\"\"\n    for key, value in cls.get_default_parts(parts).items():\n        if not parts[key]:  # type: ignore[literal-required]\n            parts[key] = value  # type: ignore[literal-required]\n    return parts\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.build","title":"<code>build(*, base_url, version=None, endpoint=None, query=None, **_kwargs)</code>  <code>classmethod</code>","text":"<p>Build complete URL from URL parts.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef build(\n    cls,\n    *,\n    base_url: str,\n    version: str | None = None,\n    endpoint: str | None = None,\n    query: str | None = None,\n    **_kwargs: str,\n) -&gt; str:\n    \"\"\"Build complete URL from URL parts.\"\"\"\n    url = base_url.rstrip(\"/\")\n    if version:\n        url += f\"/{version}\"\n    if endpoint:\n        url += f\"/{endpoint}\"\n    if query:\n        url += f\"?{query}\"\n    return url\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.build_optimade_parts","title":"<code>build_optimade_parts(parts, host)</code>  <code>classmethod</code>","text":"<p>Convert URL parts to equivalent OPTIMADE URL parts.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef build_optimade_parts(cls, parts: Parts, host: str) -&gt; OPTIMADEParts:\n    \"\"\"Convert URL parts to equivalent OPTIMADE URL parts.\"\"\"\n    base_url = f\"{parts['scheme']}://\"\n    if parts[\"user\"]:\n        base_url += parts[\"user\"]\n    if parts[\"password\"]:\n        base_url += f\":{parts['password']}\"\n    if parts[\"user\"] or parts[\"password\"]:\n        base_url += \"@\"\n    base_url += host\n    # Hide port if it's a standard HTTP (80) or HTTPS (443) port.\n    if parts[\"port\"] and parts[\"port\"] not in (\"80\", \"443\"):\n        base_url += f\":{parts['port']}\"\n    if parts[\"path\"]:\n        base_url += parts[\"path\"]\n\n    base_url_match = _OPTIMADE_BASE_URL_REGEX.fullmatch(base_url)\n    LOGGER.debug(\n        \"OPTIMADE base URL regex match groups: %s\",\n        base_url_match.groupdict() if base_url_match else base_url_match,\n    )\n    if base_url_match is None:\n        error_message = \"Could not match given string with OPTIMADE base URL regex.\"\n        raise ValueError(error_message)\n\n    endpoint_match = _OPTIMADE_ENDPOINT_REGEX.findall(\n        base_url_match.group(\"path\") if base_url_match.group(\"path\") else \"\"\n    )\n    LOGGER.debug(\"OPTIMADE endpoint regex matches: %s\", endpoint_match)\n    for path_version, path_endpoint in endpoint_match:  # noqa: B007\n        if path_endpoint:\n            break\n    else:\n        LOGGER.debug(\"Could not match given string with OPTIMADE endpoint regex.\")\n        path_version, path_endpoint = \"\", \"\"\n\n    base_url = base_url_match.group(\"base_url\")\n    if path_version:\n        base_url = base_url[: -(len(path_version) + len(path_endpoint) + 2)]\n    elif path_endpoint:\n        base_url = base_url[: -(len(path_endpoint) + 1)]\n\n    optimade_parts = {\n        \"base_url\": base_url.rstrip(\"/\"),\n        \"version\": path_version or None,\n        \"endpoint\": path_endpoint or None,\n        \"query\": parts[\"query\"],\n    }\n    return cast(\"OPTIMADEParts\", optimade_parts)\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.get_default_parts","title":"<code>get_default_parts(parts)</code>  <code>staticmethod</code>","text":"<p>Dictionary of default URL-part values.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@staticmethod\ndef get_default_parts(parts: Parts) -&gt; Parts:\n    \"\"\"Dictionary of default URL-part values.\"\"\"\n    return {\"port\": \"80\" if parts[\"scheme\"] == \"http\" else \"443\"}\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.response_model","title":"<code>response_model(self)</code>","text":"<p>Return the endpoint's corresponding response model (from OPT).</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>def response_model(self) -&gt; tuple[Success, ...] | Success | None:\n    \"\"\"Return the endpoint's corresponding response model (from OPT).\"\"\"\n    if not self.endpoint or self.endpoint == \"versions\":\n        return None\n    return {\n        \"info\": (InfoResponse, EntryInfoResponse),\n        \"links\": LinksResponse,\n        \"structures\": (StructureResponseMany, StructureResponseOne),\n        \"references\": (ReferenceResponseMany, ReferenceResponseOne),\n        \"calculations\": (EntryResponseMany, EntryResponseOne),\n    }.get(self.endpoint, Success)\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.urlquote_qs","title":"<code>urlquote_qs(url)</code>  <code>staticmethod</code>","text":"<p>Use <code>urllib.parse.quote</code> for query part of URL.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@staticmethod\ndef urlquote_qs(url: str) -&gt; str:\n    \"\"\"Use `urllib.parse.quote` for query part of URL.\"\"\"\n    parsed_url = urlparse(url)\n    quoted_query = urlquote(parsed_url.query, safe=\"=&amp;,\")\n    parsed_url_list = list(parsed_url)\n    parsed_url_list[-2] = quoted_query\n    return urlunparse(parsed_url_list)\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.validate","title":"<code>validate(value, field, config)</code>  <code>classmethod</code>","text":"<p>Pydantic validation of an OPTIMADE URL.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef validate(cls, value: Any, field: ModelField, config: BaseConfig) -&gt; OPTIMADEUrl:\n    \"\"\"Pydantic validation of an OPTIMADE URL.\"\"\"\n    if type(value) == cls:\n        return value\n\n    value: str = str_validator(value)\n    if cls.strip_whitespace:\n        value = value.strip()\n    url: str = cast(str, constr_length_validator(value, field, config))\n    url = cls.urlquote_qs(url)\n\n    url_match = url_regex().match(url)\n    if url_match is None:\n        error_message = f\"Cannot match URL ({url!r}) as a valid URL.\"\n        raise ValueError(error_message)\n\n    original_parts = cast(\"Parts\", url_match.groupdict())\n    parts = cls.apply_default_parts(original_parts)\n    host, tld, host_type, rebuild = cls.validate_host(parts)\n    optimade_parts = cls.build_optimade_parts(parts, host)\n    optimade_parts = cls.validate_parts(parts, optimade_parts)\n\n    if url_match.end() != len(url):\n        raise errors.UrlExtraError(extra=url[url_match.end() :])\n\n    return cls(  # type: ignore[no-any-return]\n        None if rebuild else url,\n        base_url=optimade_parts[\"base_url\"],\n        version=optimade_parts[\"version\"],\n        endpoint=optimade_parts[\"endpoint\"],\n        query=optimade_parts[\"query\"],\n        scheme=parts[\"scheme\"],\n        tld=tld,\n        host_type=host_type,\n    )\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.validate_host","title":"<code>validate_host(parts)</code>  <code>classmethod</code>","text":"<p>Validate host-part of the URL.</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef validate_host(cls, parts: Parts) -&gt; tuple[str, str | None, str, bool]:\n    \"\"\"Validate host-part of the URL.\"\"\"\n    host: str | None = None\n    tld: str | None = None\n    rebuild: bool = False\n    for host_type in (\"domain\", \"ipv4\", \"ipv6\"):\n        host = parts[host_type]  # type: ignore[literal-required]\n        if host:\n            break\n    else:\n        raise errors.UrlHostError()\n\n    if host_type == \"domain\":\n        is_international = False\n        domain = ascii_domain_regex().fullmatch(host)\n        if domain is None:\n            domain = int_domain_regex().fullmatch(host)\n            if domain is None:\n                raise errors.UrlHostError()\n            is_international = True\n\n        tld = domain.group(\"tld\")\n        if tld is None and not is_international:\n            domain = int_domain_regex().fullmatch(host)\n            if domain is None:\n                error_message = \"domain cannot be None\"\n                raise ValueError(error_message)\n            tld = domain.group(\"tld\")\n            is_international = True\n\n        if tld is not None:\n            tld = tld[1:]\n        elif cls.tld_required:\n            raise errors.UrlHostTldError()\n\n        if is_international:\n            host_type = \"int_domain\"\n            rebuild = True\n            host = host.encode(\"idna\").decode(\"ascii\")\n            if tld is not None:\n                tld = tld.encode(\"idna\").decode(\"ascii\")\n\n    return host, tld, host_type, rebuild\n</code></pre>"},{"location":"api_reference/models/custom_types/#oteapi_optimade.models.custom_types.OPTIMADEUrl.validate_parts","title":"<code>validate_parts(parts, optimade_parts)</code>  <code>classmethod</code>","text":"<p>A method used to validate parts of an URL. Could be overridden to set default values for parts if missing</p> Source code in <code>oteapi_optimade/models/custom_types.py</code> <pre><code>@classmethod\ndef validate_parts(\n    cls, parts: Parts, optimade_parts: OPTIMADEParts\n) -&gt; OPTIMADEParts:\n    \"\"\"\n    A method used to validate parts of an URL.\n    Could be overridden to set default values for parts if missing\n    \"\"\"\n    scheme = parts[\"scheme\"]\n    if scheme is None:\n        raise errors.UrlSchemeError()\n\n    if cls.allowed_schemes and scheme.lower() not in cls.allowed_schemes:\n        raise errors.UrlSchemePermittedError(set(cls.allowed_schemes))\n\n    port = parts[\"port\"]\n    if port is not None and int(port) &gt; 65_535:\n        raise errors.UrlPortError()\n\n    user = parts[\"user\"]\n    if cls.user_required and user is None:\n        raise errors.UrlUserInfoError()\n\n    base_url = optimade_parts[\"base_url\"]\n    if base_url is None:\n        raise errors.UrlError()\n\n    return optimade_parts\n</code></pre>"},{"location":"api_reference/models/query/","title":"query","text":"<p>Data models related to OPTIMADE queries.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.QUERY_PARAMETERS","title":"<code>QUERY_PARAMETERS</code>","text":"<p>Entry listing URL query parameters from the <code>optimade</code> package (<code>EntryListingQueryParams</code>).</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters","title":"<code> OPTIMADEQueryParameters            (BaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Common OPTIMADE entry listing endpoint query parameters.</p> Source code in <code>oteapi_optimade/models/query.py</code> <pre><code>class OPTIMADEQueryParameters(BaseModel, validate_assignment=True):\n    \"\"\"Common OPTIMADE entry listing endpoint query parameters.\"\"\"\n\n    filter: Optional[str] = Field(\n        QUERY_PARAMETERS.filter.default,\n        description=QUERY_PARAMETERS.filter.description,\n    )\n    response_format: Optional[str] = Field(\n        QUERY_PARAMETERS.response_format.default,\n        description=QUERY_PARAMETERS.response_format.description,\n    )\n    email_address: Optional[EmailStr] = Field(\n        QUERY_PARAMETERS.email_address.default,\n        description=QUERY_PARAMETERS.email_address.description,\n    )\n    response_fields: Optional[str] = Field(\n        QUERY_PARAMETERS.response_fields.default,\n        description=QUERY_PARAMETERS.response_fields.description,\n        regex=QUERY_PARAMETERS.response_fields.regex,\n    )\n    sort: Optional[str] = Field(\n        QUERY_PARAMETERS.sort.default,\n        description=QUERY_PARAMETERS.sort.description,\n        regex=QUERY_PARAMETERS.sort.regex,\n    )\n    page_limit: Optional[int] = Field(\n        QUERY_PARAMETERS.page_limit.default,\n        description=QUERY_PARAMETERS.page_limit.description,\n        ge=QUERY_PARAMETERS.page_limit.ge,\n    )\n    page_offset: Optional[int] = Field(\n        QUERY_PARAMETERS.page_offset.default,\n        description=QUERY_PARAMETERS.page_offset.description,\n        ge=QUERY_PARAMETERS.page_offset.ge,\n    )\n    page_number: Optional[int] = Field(\n        QUERY_PARAMETERS.page_number.default,\n        description=QUERY_PARAMETERS.page_number.description,\n        ge=QUERY_PARAMETERS.page_number.ge,\n    )\n    page_cursor: Optional[int] = Field(\n        QUERY_PARAMETERS.page_cursor.default,\n        description=QUERY_PARAMETERS.page_cursor.description,\n        ge=QUERY_PARAMETERS.page_cursor.ge,\n    )\n    page_above: Optional[int] = Field(\n        QUERY_PARAMETERS.page_above.default,\n        description=QUERY_PARAMETERS.page_above.description,\n        ge=QUERY_PARAMETERS.page_above.ge,\n    )\n    page_below: Optional[int] = Field(\n        QUERY_PARAMETERS.page_below.default,\n        description=QUERY_PARAMETERS.page_below.description,\n        ge=QUERY_PARAMETERS.page_below.ge,\n    )\n    include: Optional[str] = Field(\n        QUERY_PARAMETERS.include.default,\n        description=QUERY_PARAMETERS.include.description,\n    )\n    # api_hint is not yet initialized in `EntryListingQueryParams`.\n    # These values are copied verbatim from `optimade==0.16.10`.\n    api_hint: Optional[str] = Field(\n        \"\",\n        description=(\n            \"If the client provides the parameter, the value SHOULD have the format \"\n            \"`vMAJOR` or `vMAJOR.MINOR`, where MAJOR is a major version and MINOR is a\"\n            \" minor version of the API. For example, if a client appends \"\n            \"`api_hint=v1.0` to the query string, the hint provided is for major \"\n            \"version 1 and minor version 0.\"\n        ),\n        regex=r\"(v[0-9]+(\\.[0-9]+)?)?\",\n    )\n\n    def generate_query_string(self) -&gt; str:\n        \"\"\"Generate a valid URL query string based on the set fields.\"\"\"\n        res = {}\n        for field, value in self.dict().items():\n            if value or field in self.__fields_set__:\n                res[field] = unquote(value) if isinstance(value, str) else value\n        return urlencode(res, quote_via=quote)\n</code></pre>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.api_hint","title":"<code>api_hint: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>If the client provides the parameter, the value SHOULD have the format <code>vMAJOR</code> or <code>vMAJOR.MINOR</code>, where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends <code>api_hint=v1.0</code> to the query string, the hint provided is for major version 1 and minor version 0.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.email_address","title":"<code>email_address: EmailStr</code>  <code>pydantic-field</code>","text":"<p>An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: <code>http://example.com/v1/structures?email_address=user@example.com</code></p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.filter","title":"<code>filter: str</code>  <code>pydantic-field</code>","text":"<p>A filter string, in the format described in section API Filtering Format Specification of the specification.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.include","title":"<code>include: str</code>  <code>pydantic-field</code>","text":"<p>A server MAY implement the JSON API concept of returning compound documents by utilizing the <code>include</code> query parameter as specified by JSON API 1.0.</p> <p>All related resource objects MUST be returned as part of an array value for the top-level <code>included</code> field, see the section JSON Response Schema: Common Fields.</p> <p>The value of <code>include</code> MUST be a comma-separated list of \"relationship paths\", as defined in the JSON API. If relationship paths are not supported, or a server is unable to identify a relationship path a <code>400 Bad Request</code> response MUST be made.</p> <p>The default value for <code>include</code> is <code>references</code>. This means <code>references</code> entries MUST always be included under the top-level field <code>included</code> as default, since a server assumes if <code>include</code> is not specified by a client in the request, it is still specified as <code>include=references</code>. Note, if a client explicitly specifies <code>include</code> and leaves out <code>references</code>, <code>references</code> resource objects MUST NOT be included under the top-level field <code>included</code>, as per the definition of <code>included</code>, see section JSON Response Schema: Common Fields.</p> <p>Note: A query with the parameter <code>include</code> set to the empty string means no related resource objects are to be returned under the top-level field <code>included</code>.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_above","title":"<code>page_above: int</code>  <code>pydantic-field</code>","text":"<p>RECOMMENDED for use with value-based pagination: using <code>page_above</code>/<code>page_below</code> and <code>page_limit</code> is RECOMMENDED. Example: Fetch up to 100 structures above sort-field value 4000 (in this example, server chooses to fetch results sorted by increasing <code>id</code>, so <code>page_above</code> value refers to an <code>id</code> value): <code>/structures?page_above=4000&amp;page_limit=100</code>.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_below","title":"<code>page_below: int</code>  <code>pydantic-field</code>","text":"<p>RECOMMENDED for use with value-based pagination: using <code>page_above</code>/<code>page_below</code> and <code>page_limit</code> is RECOMMENDED.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_cursor","title":"<code>page_cursor: ConstrainedIntValue</code>  <code>pydantic-field</code>","text":"<p>RECOMMENDED for use with cursor-based pagination: using <code>page_cursor</code> and <code>page_limit</code> is RECOMMENDED.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_limit","title":"<code>page_limit: ConstrainedIntValue</code>  <code>pydantic-field</code>","text":"<p>Sets a numerical limit on the number of entries returned. See JSON API 1.0. The API implementation MUST return no more than the number specified. It MAY return fewer. The database MAY have a maximum limit and not accept larger numbers (in which case an error code -- 403 Forbidden -- MUST be returned). The default limit value is up to the API implementation to decide. Example: <code>http://example.com/optimade/v1/structures?page_limit=100</code></p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_number","title":"<code>page_number: int</code>  <code>pydantic-field</code>","text":"<p>RECOMMENDED for use with page-based pagination: using <code>page_number</code> and <code>page_limit</code> is RECOMMENDED. It is RECOMMENDED that the first page has number 1, i.e., that <code>page_number</code> is 1-based. Example: Fetch page 2 of up to 50 structures per page: <code>/structures?page_number=2&amp;page_limit=50</code>.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.page_offset","title":"<code>page_offset: ConstrainedIntValue</code>  <code>pydantic-field</code>","text":"<p>RECOMMENDED for use with offset-based pagination: using <code>page_offset</code> and <code>page_limit</code> is RECOMMENDED. Example: Skip 50 structures and fetch up to 100: <code>/structures?page_offset=50&amp;page_limit=100</code>.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.response_fields","title":"<code>response_fields: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: <code>http://example.com/v1/structures?response_fields=last_modified,nsites</code></p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.response_format","title":"<code>response_format: str</code>  <code>pydantic-field</code>","text":"<p>The output format requested (see section Response Format). Defaults to the format string 'json', which specifies the standard output format described in this specification. Example: <code>http://example.com/v1/structures?response_format=xml</code></p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.sort","title":"<code>sort: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>If supporting sortable queries, an implementation MUST use the <code>sort</code> query parameter with format as specified by JSON API 1.0.</p> <p>An implementation MAY support multiple sort fields for a single query. If it does, it again MUST conform to the JSON API 1.0 specification.</p> <p>If an implementation supports sorting for an entry listing endpoint, then the <code>/info/&lt;entries&gt;</code> endpoint MUST include, for each field name <code>&lt;fieldname&gt;</code> in its <code>data.properties.&lt;fieldname&gt;</code> response value that can be used for sorting, the key <code>sortable</code> with value <code>true</code>. If a field name under an entry listing endpoint supporting sorting cannot be used for sorting, the server MUST either leave out the <code>sortable</code> key or set it equal to <code>false</code> for the specific field name. The set of field names, with <code>sortable</code> equal to <code>true</code> are allowed to be used in the \"sort fields\" list according to its definition in the JSON API 1.0 specification. The field <code>sortable</code> is in addition to each property description and other OPTIONAL fields. An example is shown in the section Entry Listing Info Endpoints.</p>"},{"location":"api_reference/models/query/#oteapi_optimade.models.query.OPTIMADEQueryParameters.generate_query_string","title":"<code>generate_query_string(self)</code>","text":"<p>Generate a valid URL query string based on the set fields.</p> Source code in <code>oteapi_optimade/models/query.py</code> <pre><code>def generate_query_string(self) -&gt; str:\n    \"\"\"Generate a valid URL query string based on the set fields.\"\"\"\n    res = {}\n    for field, value in self.dict().items():\n        if value or field in self.__fields_set__:\n            res[field] = unquote(value) if isinstance(value, str) else value\n    return urlencode(res, quote_via=quote)\n</code></pre>"},{"location":"api_reference/models/strategies/filter/","title":"filter","text":"<p>Models specific to the filter strategy.</p>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterConfig","title":"<code> OPTIMADEFilterConfig            (FilterConfig)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE-specific filter strategy config.</p> <p>Note</p> <p>The <code>condition</code> parameter is not taken into account.</p> Source code in <code>oteapi_optimade/models/strategies/filter.py</code> <pre><code>class OPTIMADEFilterConfig(FilterConfig):  # type: ignore[misc]\n    \"\"\"OPTIMADE-specific filter strategy config.\n\n    Note:\n        The `condition` parameter is not taken into account.\n\n    \"\"\"\n\n    filterType: Literal[\"optimade\", \"OPTIMADE\", \"OPTiMaDe\"] = Field(\n        ...,\n        description=\"The registered strategy name for OPTIMADEFilterStrategy.\",\n    )\n    query: Optional[str] = Field(\n        None,\n        description=(\n            \"The `filter` OPTIMADE query parameter value. This parameter value can \"\n            \"also be provided through the [`configuration.query_parameters.filter`]\"\n            \"[oteapi_optimade.models.query.OPTIMADEQueryParameters.filter] parameter. \"\n            \"Note, this value takes precedence over [`configuration`][oteapi_optimade.\"\n            \"models.strategies.filter.OPTIMADEFilterConfig.configuration] values.\"\n        ),\n    )\n    limit: Optional[int] = Field(\n        None,\n        description=(\n            \"The `page_limit` OPTIMADE query parameter value. This parameter value can\"\n            \" also be provided through the [`configuration.query_parameters.\"\n            \"page_limit`][oteapi_optimade.models.query.OPTIMADEQueryParameters.\"\n            \"page_limit] parameter. Note, this value takes precedence over \"\n            \"[`configuration`][oteapi_optimade.models.strategies.filter.\"\n            \"OPTIMADEFilterConfig.configuration] values.\"\n        ),\n    )\n    configuration: OPTIMADEConfig = Field(\n        OPTIMADEConfig(),\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession","title":"<code> OPTIMADEFilterSession            (SessionUpdate)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE session for the filter strategy.</p> Source code in <code>oteapi_optimade/models/strategies/filter.py</code> <pre><code>class OPTIMADEFilterSession(SessionUpdate):  # type: ignore[misc]\n    \"\"\"OPTIMADE session for the filter strategy.\"\"\"\n\n    optimade_config: Optional[OPTIMADEConfig] = Field(\n        None,\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n    optimade_response_object: Optional[Response] = Field(\n        None,\n        description=\"An OPTIMADE Python tools (OPT) pydantic response object.\",\n    )\n    optimade_response: Optional[dict[str, Any]] = Field(\n        None,\n        description=\"An OPTIMADE response as a Python dictionary.\",\n    )\n\n    class Config:\n        \"\"\"Pydantic configuration for `OPTIMADEFilterSession`.\"\"\"\n\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession.optimade_config","title":"<code>optimade_config: OPTIMADEConfig</code>  <code>pydantic-field</code>","text":"<p>OPTIMADE configuration. Contains relevant information necessary to perform OPTIMADE queries.</p>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession.optimade_response","title":"<code>optimade_response: dict</code>  <code>pydantic-field</code>","text":"<p>An OPTIMADE response as a Python dictionary.</p>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession.optimade_response_object","title":"<code>optimade_response_object: Response</code>  <code>pydantic-field</code>","text":"<p>An OPTIMADE Python tools (OPT) pydantic response object.</p>"},{"location":"api_reference/models/strategies/filter/#oteapi_optimade.models.strategies.filter.OPTIMADEFilterSession.Config","title":"<code> Config        </code>","text":"<p>Pydantic configuration for <code>OPTIMADEFilterSession</code>.</p> Source code in <code>oteapi_optimade/models/strategies/filter.py</code> <pre><code>class Config:\n    \"\"\"Pydantic configuration for `OPTIMADEFilterSession`.\"\"\"\n\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/strategies/parse/","title":"parse","text":"<p>Models specific to the parse strategy.</p>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEDLiteParseConfig","title":"<code> OPTIMADEDLiteParseConfig            (OPTIMADEParseConfig)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE-specific parse strategy config.</p> Source code in <code>oteapi_optimade/models/strategies/parse.py</code> <pre><code>class OPTIMADEDLiteParseConfig(OPTIMADEParseConfig):\n    \"\"\"OPTIMADE-specific parse strategy config.\"\"\"\n\n    mediaType: Literal[\n        \"application/vnd.optimade+dlite\",\n        \"application/vnd.OPTIMADE+dlite\",\n        \"application/vnd.OPTiMaDe+dlite\",\n        \"application/vnd.optimade+DLite\",\n        \"application/vnd.OPTIMADE+DLite\",\n        \"application/vnd.OPTiMaDe+DLite\",\n    ] = Field(  # type: ignore[assignment]\n        ...,\n        description=\"The registered strategy name for OPTIMADEDLiteParseStrategy.\",\n    )\n</code></pre>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseConfig","title":"<code> OPTIMADEParseConfig            (ResourceConfig)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE-specific parse strategy config.</p> Source code in <code>oteapi_optimade/models/strategies/parse.py</code> <pre><code>class OPTIMADEParseConfig(ResourceConfig):  # type: ignore[misc]\n    \"\"\"OPTIMADE-specific parse strategy config.\"\"\"\n\n    downloadUrl: OPTIMADEUrl = Field(\n        ...,\n        description=\"Either a base OPTIMADE URL or a full OPTIMADE URL.\",\n    )\n    mediaType: Literal[\n        \"application/vnd.optimade+json\",\n        \"application/vnd.OPTIMADE+json\",\n        \"application/vnd.OPTiMaDe+json\",\n        \"application/vnd.optimade+JSON\",\n        \"application/vnd.OPTIMADE+JSON\",\n        \"application/vnd.OPTiMaDe+JSON\",\n        \"application/vnd.optimade\",\n        \"application/vnd.OPTIMADE\",\n        \"application/vnd.OPTiMaDe\",\n    ] = Field(\n        ...,\n        description=\"The registered strategy name for OPTIMADEParseStrategy.\",\n    )\n    configuration: OPTIMADEConfig = Field(\n        OPTIMADEConfig(),\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession","title":"<code> OPTIMADEParseSession            (SessionUpdate)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE session for the parse strategy.</p> Source code in <code>oteapi_optimade/models/strategies/parse.py</code> <pre><code>class OPTIMADEParseSession(SessionUpdate):  # type: ignore[misc]\n    \"\"\"OPTIMADE session for the parse strategy.\"\"\"\n\n    optimade_config: Optional[OPTIMADEConfig] = Field(\n        None,\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n    optimade_response_object: Optional[Response] = Field(\n        None,\n        description=\"An OPTIMADE Python tools (OPT) pydantic response object.\",\n    )\n    optimade_response: Optional[dict[str, Any]] = Field(\n        None,\n        description=\"An OPTIMADE response as a Python dictionary.\",\n    )\n\n    class Config:\n        \"\"\"Pydantic configuration for `OPTIMADEParseSession`.\"\"\"\n\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession.optimade_config","title":"<code>optimade_config: OPTIMADEConfig</code>  <code>pydantic-field</code>","text":"<p>OPTIMADE configuration. Contains relevant information necessary to perform OPTIMADE queries.</p>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession.optimade_response","title":"<code>optimade_response: dict</code>  <code>pydantic-field</code>","text":"<p>An OPTIMADE response as a Python dictionary.</p>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession.optimade_response_object","title":"<code>optimade_response_object: Response</code>  <code>pydantic-field</code>","text":"<p>An OPTIMADE Python tools (OPT) pydantic response object.</p>"},{"location":"api_reference/models/strategies/parse/#oteapi_optimade.models.strategies.parse.OPTIMADEParseSession.Config","title":"<code> Config        </code>","text":"<p>Pydantic configuration for <code>OPTIMADEParseSession</code>.</p> Source code in <code>oteapi_optimade/models/strategies/parse.py</code> <pre><code>class Config:\n    \"\"\"Pydantic configuration for `OPTIMADEParseSession`.\"\"\"\n\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/strategies/resource/","title":"resource","text":"<p>Models specific to the resource strategy.</p>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceConfig","title":"<code> OPTIMADEResourceConfig            (ResourceConfig)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE-specific resource strategy config.</p> Source code in <code>oteapi_optimade/models/strategies/resource.py</code> <pre><code>class OPTIMADEResourceConfig(ResourceConfig):  # type: ignore[misc]\n    \"\"\"OPTIMADE-specific resource strategy config.\"\"\"\n\n    accessUrl: OPTIMADEUrl = Field(\n        ...,\n        description=\"Either a base OPTIMADE URL or a full OPTIMADE URL.\",\n    )\n    accessService: Literal[\n        \"optimade\",\n        \"OPTIMADE\",\n        \"OPTiMaDe\",\n        \"optimade+dlite\",\n        \"OPTIMADE+dlite\",\n        \"OPTiMaDe+dlite\",\n        \"optimade+DLite\",\n        \"OPTIMADE+DLite\",\n        \"OPTiMaDe+DLite\",\n    ] = Field(\n        ...,\n        description=\"The registered strategy name for OPTIMADEResourceStrategy.\",\n    )\n    configuration: OPTIMADEConfig = Field(\n        OPTIMADEConfig(),\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession","title":"<code> OPTIMADEResourceSession            (SessionUpdate)         </code>  <code>pydantic-model</code>","text":"<p>OPTIMADE session for the resource strategy.</p> Source code in <code>oteapi_optimade/models/strategies/resource.py</code> <pre><code>class OPTIMADEResourceSession(SessionUpdate):  # type: ignore[misc]\n    \"\"\"OPTIMADE session for the resource strategy.\"\"\"\n\n    optimade_config: Optional[OPTIMADEConfig] = Field(\n        None,\n        description=(\n            \"OPTIMADE configuration. Contains relevant information necessary to \"\n            \"perform OPTIMADE queries.\"\n        ),\n    )\n    optimade_resources: list[dict[str, Any]] = Field(\n        [],\n        description=(\n            \"List of OPTIMADE resources (structures, references, errors, ...) returned\"\n            \" from the OPTIMADE request.\"\n        ),\n    )\n    optimade_resource_model: str = Field(\n        \"\",\n        description=(\n            \"Importable path to the resource model to be used to parse the OPTIMADE \"\n            \"resources in `optimade_resource`. The importable path should be a fully \"\n            \"importable path to a module separated by a colon (`:`) to then define the \"\n            \"resource model class name. This means one can then do:\\n\\n```python\\n\"\n            \"from PACKAGE.MODULE import RESOURCE_CLS\\n```\\nFrom the value \"\n            \"`PACKAGE.MODULE:RESOURCE_CLS`\"\n        ),\n        regex=(\n            r\"^([a-zA-Z][a-zA-Z0-9_]*(\\.[a-zA-Z][a-zA-Z0-9_]*)*\"  # package.module\n            r\":[a-zA-Z][a-zA-Z0-9_]*)?$\"  # class\n        ),\n    )\n\n    class Config:\n        \"\"\"Pydantic configuration for `OPTIMADEResourceSession`.\"\"\"\n\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession.optimade_config","title":"<code>optimade_config: OPTIMADEConfig</code>  <code>pydantic-field</code>","text":"<p>OPTIMADE configuration. Contains relevant information necessary to perform OPTIMADE queries.</p>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession.optimade_resource_model","title":"<code>optimade_resource_model: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Importable path to the resource model to be used to parse the OPTIMADE resources in <code>optimade_resource</code>. The importable path should be a fully importable path to a module separated by a colon (<code>:</code>) to then define the resource model class name. This means one can then do:</p> <p><pre><code>from PACKAGE.MODULE import RESOURCE_CLS\n</code></pre> From the value <code>PACKAGE.MODULE:RESOURCE_CLS</code></p>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession.optimade_resources","title":"<code>optimade_resources: list</code>  <code>pydantic-field</code>","text":"<p>List of OPTIMADE resources (structures, references, errors, ...) returned from the OPTIMADE request.</p>"},{"location":"api_reference/models/strategies/resource/#oteapi_optimade.models.strategies.resource.OPTIMADEResourceSession.Config","title":"<code> Config        </code>","text":"<p>Pydantic configuration for <code>OPTIMADEResourceSession</code>.</p> Source code in <code>oteapi_optimade/models/strategies/resource.py</code> <pre><code>class Config:\n    \"\"\"Pydantic configuration for `OPTIMADEResourceSession`.\"\"\"\n\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/strategies/filter/","title":"filter","text":"<p>Demo filter strategy.</p>"},{"location":"api_reference/strategies/filter/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy","title":"<code> OPTIMADEFilterStrategy        </code>  <code>dataclass</code>","text":"<p>Filter Strategy.</p> <p>Implements strategies:</p> <ul> <li><code>(\"filterType\", \"OPTIMADE\")</code></li> <li><code>(\"filterType\", \"optimade\")</code></li> <li><code>(\"filterType\", \"OPTiMaDe\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>@dataclass\nclass OPTIMADEFilterStrategy:\n    \"\"\"Filter Strategy.\n\n    **Implements strategies**:\n\n    - `(\"filterType\", \"OPTIMADE\")`\n    - `(\"filterType\", \"optimade\")`\n    - `(\"filterType\", \"OPTiMaDe\")`\n\n    \"\"\"\n\n    filter_config: OPTIMADEFilterConfig\n\n    def initialize(\n        self, session: SessionUpdate | dict[str, Any] | None = None\n    ) -&gt; OPTIMADEFilterSession:\n        \"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Configuration values, specifically URL query parameters, can be provided to the\n        OPTIMADE resource strategy through this filter strategy.\n\n        Workflow:\n\n        1. Compile received information.\n        2. Update session with compiled information.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEFilterSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEFilterSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEFilterSession()\n\n        if session.optimade_config:\n            self.filter_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        optimade_config = self.filter_config.configuration.copy()\n\n        if not optimade_config.query_parameters:\n            optimade_config.query_parameters = OPTIMADEQueryParameters()\n\n        if self.filter_config.query:\n            LOGGER.debug(\"Setting filter from query.\")\n            optimade_config.query_parameters.filter = self.filter_config.query\n\n        if self.filter_config.limit:\n            LOGGER.debug(\"Setting page_limit from limit.\")\n            optimade_config.query_parameters.page_limit = self.filter_config.limit\n\n        return session.copy(  # type: ignore[no-any-return]\n            update={\n                \"optimade_config\": optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            },\n        )\n\n    def get(\n        self,\n        session: dict[str, Any] | None = None,  # noqa: ARG002\n    ) -&gt; SessionUpdate:\n        \"\"\"Execute the strategy.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n        return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/filter/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Execute the strategy.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict[str, Any] | None</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>def get(\n    self,\n    session: dict[str, Any] | None = None,  # noqa: ARG002\n) -&gt; SessionUpdate:\n    \"\"\"Execute the strategy.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/filter/#oteapi_optimade.strategies.filter.OPTIMADEFilterStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Configuration values, specifically URL query parameters, can be provided to the OPTIMADE resource strategy through this filter strategy.</p> <p>Workflow:</p> <ol> <li>Compile received information.</li> <li>Update session with compiled information.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>SessionUpdate | dict[str, Any] | None</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEFilterSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/filter.py</code> <pre><code>def initialize(\n    self, session: SessionUpdate | dict[str, Any] | None = None\n) -&gt; OPTIMADEFilterSession:\n    \"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Configuration values, specifically URL query parameters, can be provided to the\n    OPTIMADE resource strategy through this filter strategy.\n\n    Workflow:\n\n    1. Compile received information.\n    2. Update session with compiled information.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEFilterSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEFilterSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEFilterSession()\n\n    if session.optimade_config:\n        self.filter_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    optimade_config = self.filter_config.configuration.copy()\n\n    if not optimade_config.query_parameters:\n        optimade_config.query_parameters = OPTIMADEQueryParameters()\n\n    if self.filter_config.query:\n        LOGGER.debug(\"Setting filter from query.\")\n        optimade_config.query_parameters.filter = self.filter_config.query\n\n    if self.filter_config.limit:\n        LOGGER.debug(\"Setting page_limit from limit.\")\n        optimade_config.query_parameters.page_limit = self.filter_config.limit\n\n    return session.copy(  # type: ignore[no-any-return]\n        update={\n            \"optimade_config\": optimade_config.copy(\n                update={\n                    \"query_parameters\": model2dict(\n                        optimade_config.query_parameters,\n                        exclude_defaults=True,\n                        exclude_unset=True,\n                    )\n                }\n            )\n        },\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/","title":"parse","text":"<p>Demo strategy class for text/json.</p>"},{"location":"api_reference/strategies/parse/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy","title":"<code> OPTIMADEParseStrategy        </code>  <code>dataclass</code>","text":"<p>Parse strategy for JSON.</p> <p>Implements strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.optimade+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe+json\")</code></li> <li><code>(\"mediaType\", \"application/vnd.optimade+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")</code></li> <li><code>(\"mediaType\", \"application/vnd.optimade\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTIMADE\")</code></li> <li><code>(\"mediaType\", \"application/vnd.OPTiMaDe\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>@dataclass\nclass OPTIMADEParseStrategy:\n    \"\"\"Parse strategy for JSON.\n\n    **Implements strategies**:\n\n    - `(\"mediaType\", \"application/vnd.optimade+json\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE+json\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe+json\")`\n    - `(\"mediaType\", \"application/vnd.optimade+JSON\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE+JSON\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe+JSON\")`\n    - `(\"mediaType\", \"application/vnd.optimade\")`\n    - `(\"mediaType\", \"application/vnd.OPTIMADE\")`\n    - `(\"mediaType\", \"application/vnd.OPTiMaDe\")`\n\n    \"\"\"\n\n    parse_config: OPTIMADEParseConfig\n\n    def initialize(\n        self,\n        session: dict[str, Any] | None = None,  # noqa: ARG002\n    ) -&gt; SessionUpdate:\n        \"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        return SessionUpdate()\n\n    def get(\n        self, session: SessionUpdate | dict[str, Any] | None = None\n    ) -&gt; OPTIMADEParseSession:\n        \"\"\"Request and parse an OPTIMADE response using OPT.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Configuration values provided in `resource_config.configuration` take\n        precedence over the derived values from `downloadUrl`.\n\n        Workflow:\n\n        1. Request OPTIMADE response.\n        2. Parse as an OPTIMADE Python tools (OPT) pydantic response model.\n\n        Parameters:\n            session: A session-specific dictionary-like context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEParseSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEParseSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEParseSession()\n\n        if session.optimade_config:\n            self.parse_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        if self.parse_config.downloadUrl in cache:\n            response: dict[str, Any] = cache.get(self.parse_config.downloadUrl)\n        elif (\n            self.parse_config.configuration.datacache_config.accessKey\n            and self.parse_config.configuration.datacache_config.accessKey in cache\n        ):\n            response = cache.get(\n                self.parse_config.configuration.datacache_config.accessKey\n            )\n        else:\n            download_config = self.parse_config.copy()\n            session.update(\n                create_strategy(StrategyType.DOWNLOAD, download_config).initialize(\n                    model2dict(session, exclude_defaults=True, exclude_unset=True)\n                )\n            )\n            session.update(\n                create_strategy(StrategyType.DOWNLOAD, download_config).get(\n                    model2dict(session, exclude_defaults=True, exclude_unset=True)\n                )\n            )\n\n            response = {\"json\": json.loads(cache.get(session.pop(\"key\")))}\n\n        if (\n            not response.get(\"ok\", True)\n            or (\n                response.get(\"status_code\", 200) &lt; 200\n                or response.get(\"status_code\", 200) &gt;= 300\n            )\n            or \"errors\" in response.get(\"json\", {})\n        ):\n            # Error response\n            try:\n                response_object = ErrorResponse(**response.get(\"json\", {}))\n            except ValidationError as exc:\n                error_message = \"Could not validate an error response.\"\n                LOGGER.error(\n                    \"%s\\nValidationError: \" \"%s\\nresponse=%r\",\n                    error_message,\n                    exc,\n                    response,\n                )\n                raise OPTIMADEParseError(error_message) from exc\n        else:\n            # Successful response\n            response_model = self.parse_config.downloadUrl.response_model()\n            if response_model:\n                if not isinstance(response_model, tuple):\n                    response_model = (response_model,)\n                for model_cls in response_model:\n                    try:\n                        response_object = model_cls(**response.get(\"json\", {}))\n                    except ValidationError:\n                        pass\n                    else:\n                        break\n                else:\n                    error_message = \"Could not validate for an expected response model.\"\n                    LOGGER.error(\n                        \"%s\\nURL=%r\\n\" \"response_models=%r\\nresponse=%s\",\n                        error_message,\n                        self.parse_config.downloadUrl,\n                        response_model,\n                        response,\n                    )\n                    raise OPTIMADEParseError(error_message)\n            else:\n                # No \"endpoint\" or unknown\n                try:\n                    response_object = Success(**response.get(\"json\", {}))\n                except ValidationError as exc:\n                    error_message = \"Unknown or unparseable endpoint.\"\n                    LOGGER.error(\n                        \"%s\\nValidatonError: %s\\n\"\n                        \"URL=%r\\nendpoint=%r\\nresponse_model=%r\\nresponse=%s\",\n                        error_message,\n                        exc,\n                        self.parse_config.downloadUrl,\n                        self.parse_config.downloadUrl.endpoint,\n                        response_model,\n                        response,\n                    )\n                    raise OPTIMADEParseError(error_message) from exc\n\n        if self.parse_config.configuration.return_object:\n            session.optimade_response_object = response_object\n        else:\n            session.optimade_response = model2dict(response_object)\n\n        if session.optimade_config and session.optimade_config.query_parameters:\n            session = session.copy(\n                update={\n                    \"optimade_config\": session.optimade_config.copy(\n                        update={\n                            \"query_parameters\": model2dict(\n                                session.optimade_config.query_parameters,\n                                exclude_defaults=True,\n                                exclude_unset=True,\n                            )\n                        }\n                    )\n                }\n            )\n\n        if TYPE_CHECKING:  # pragma: no cover\n            assert isinstance(session, OPTIMADEParseSession)  # nosec\n\n        return session\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Request and parse an OPTIMADE response using OPT.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Configuration values provided in <code>resource_config.configuration</code> take precedence over the derived values from <code>downloadUrl</code>.</p> <p>Workflow:</p> <ol> <li>Request OPTIMADE response.</li> <li>Parse as an OPTIMADE Python tools (OPT) pydantic response model.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>SessionUpdate | dict[str, Any] | None</code> <p>A session-specific dictionary-like context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEParseSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>def get(\n    self, session: SessionUpdate | dict[str, Any] | None = None\n) -&gt; OPTIMADEParseSession:\n    \"\"\"Request and parse an OPTIMADE response using OPT.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Configuration values provided in `resource_config.configuration` take\n    precedence over the derived values from `downloadUrl`.\n\n    Workflow:\n\n    1. Request OPTIMADE response.\n    2. Parse as an OPTIMADE Python tools (OPT) pydantic response model.\n\n    Parameters:\n        session: A session-specific dictionary-like context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEParseSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEParseSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEParseSession()\n\n    if session.optimade_config:\n        self.parse_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    if self.parse_config.downloadUrl in cache:\n        response: dict[str, Any] = cache.get(self.parse_config.downloadUrl)\n    elif (\n        self.parse_config.configuration.datacache_config.accessKey\n        and self.parse_config.configuration.datacache_config.accessKey in cache\n    ):\n        response = cache.get(\n            self.parse_config.configuration.datacache_config.accessKey\n        )\n    else:\n        download_config = self.parse_config.copy()\n        session.update(\n            create_strategy(StrategyType.DOWNLOAD, download_config).initialize(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n        session.update(\n            create_strategy(StrategyType.DOWNLOAD, download_config).get(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n\n        response = {\"json\": json.loads(cache.get(session.pop(\"key\")))}\n\n    if (\n        not response.get(\"ok\", True)\n        or (\n            response.get(\"status_code\", 200) &lt; 200\n            or response.get(\"status_code\", 200) &gt;= 300\n        )\n        or \"errors\" in response.get(\"json\", {})\n    ):\n        # Error response\n        try:\n            response_object = ErrorResponse(**response.get(\"json\", {}))\n        except ValidationError as exc:\n            error_message = \"Could not validate an error response.\"\n            LOGGER.error(\n                \"%s\\nValidationError: \" \"%s\\nresponse=%r\",\n                error_message,\n                exc,\n                response,\n            )\n            raise OPTIMADEParseError(error_message) from exc\n    else:\n        # Successful response\n        response_model = self.parse_config.downloadUrl.response_model()\n        if response_model:\n            if not isinstance(response_model, tuple):\n                response_model = (response_model,)\n            for model_cls in response_model:\n                try:\n                    response_object = model_cls(**response.get(\"json\", {}))\n                except ValidationError:\n                    pass\n                else:\n                    break\n            else:\n                error_message = \"Could not validate for an expected response model.\"\n                LOGGER.error(\n                    \"%s\\nURL=%r\\n\" \"response_models=%r\\nresponse=%s\",\n                    error_message,\n                    self.parse_config.downloadUrl,\n                    response_model,\n                    response,\n                )\n                raise OPTIMADEParseError(error_message)\n        else:\n            # No \"endpoint\" or unknown\n            try:\n                response_object = Success(**response.get(\"json\", {}))\n            except ValidationError as exc:\n                error_message = \"Unknown or unparseable endpoint.\"\n                LOGGER.error(\n                    \"%s\\nValidatonError: %s\\n\"\n                    \"URL=%r\\nendpoint=%r\\nresponse_model=%r\\nresponse=%s\",\n                    error_message,\n                    exc,\n                    self.parse_config.downloadUrl,\n                    self.parse_config.downloadUrl.endpoint,\n                    response_model,\n                    response,\n                )\n                raise OPTIMADEParseError(error_message) from exc\n\n    if self.parse_config.configuration.return_object:\n        session.optimade_response_object = response_object\n    else:\n        session.optimade_response = model2dict(response_object)\n\n    if session.optimade_config and session.optimade_config.query_parameters:\n        session = session.copy(\n            update={\n                \"optimade_config\": session.optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            session.optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            }\n        )\n\n    if TYPE_CHECKING:  # pragma: no cover\n        assert isinstance(session, OPTIMADEParseSession)  # nosec\n\n    return session\n</code></pre>"},{"location":"api_reference/strategies/parse/#oteapi_optimade.strategies.parse.OPTIMADEParseStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict[str, Any] | None</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/parse.py</code> <pre><code>def initialize(\n    self,\n    session: dict[str, Any] | None = None,  # noqa: ARG002\n) -&gt; SessionUpdate:\n    \"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/resource/","title":"resource","text":"<p>OPTIMADE resource strategy.</p>"},{"location":"api_reference/strategies/resource/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy","title":"<code> OPTIMADEResourceStrategy        </code>  <code>dataclass</code>","text":"<p>OPTIMADE Resource Strategy.</p> <p>Implements strategies:</p> <ul> <li><code>(\"accessService\", \"optimade\")</code></li> <li><code>(\"accessService\", \"OPTIMADE\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe\")</code></li> <li><code>(\"accessService\", \"optimade+dlite\")</code></li> <li><code>(\"accessService\", \"OPTIMADE+dlite\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe+dlite\")</code></li> <li><code>(\"accessService\", \"optimade+DLite\")</code></li> <li><code>(\"accessService\", \"OPTIMADE+DLite\")</code></li> <li><code>(\"accessService\", \"OPTiMaDe+DLite\")</code></li> </ul> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>@dataclass\nclass OPTIMADEResourceStrategy:\n    \"\"\"OPTIMADE Resource Strategy.\n\n    **Implements strategies**:\n\n    - `(\"accessService\", \"optimade\")`\n    - `(\"accessService\", \"OPTIMADE\")`\n    - `(\"accessService\", \"OPTiMaDe\")`\n    - `(\"accessService\", \"optimade+dlite\")`\n    - `(\"accessService\", \"OPTIMADE+dlite\")`\n    - `(\"accessService\", \"OPTiMaDe+dlite\")`\n    - `(\"accessService\", \"optimade+DLite\")`\n    - `(\"accessService\", \"OPTIMADE+DLite\")`\n    - `(\"accessService\", \"OPTiMaDe+DLite\")`\n\n    \"\"\"\n\n    resource_config: OPTIMADEResourceConfig\n\n    def initialize(\n        self, session: dict[str, Any] | None = None\n    ) -&gt; SessionUpdate | DLiteSessionUpdate:\n        \"\"\"Initialize strategy.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if use_dlite(\n            self.resource_config.accessService,\n            self.resource_config.configuration.use_dlite,\n        ):\n            return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n        return SessionUpdate()\n\n    def get(\n        self, session: SessionUpdate | dict[str, Any] | None = None\n    ) -&gt; OPTIMADEResourceSession:\n        \"\"\"Execute an OPTIMADE query to `accessUrl`.\n\n        This method will be called through the strategy-specific endpoint of the\n        OTE-API Services.\n\n        Configuration values provided in `resource_config.configuration` take\n        precedence over the derived values from `accessUrl`.\n\n        Workflow:\n        1. Update configuration according to session.\n        2. Deconstruct `accessUrl` (done partly by\n           `oteapi_optimade.models.custom_types.OPTIMADEUrl`).\n        3. Reconstruct the complete query URL.\n        4. Send query.\n        5. Store result in data cache.\n\n        Parameters:\n            session: A session-specific dictionary-like context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the session-specific\n            context from services.\n\n        \"\"\"\n        if session and isinstance(session, dict):\n            session = OPTIMADEResourceSession(**session)\n        elif session and isinstance(session, SessionUpdate):\n            session = OPTIMADEResourceSession(\n                **model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        else:\n            session = OPTIMADEResourceSession()\n\n        if session.optimade_config:\n            self.resource_config.configuration.update(\n                model2dict(\n                    session.optimade_config, exclude_defaults=True, exclude_unset=True\n                )\n            )\n\n        optimade_endpoint = self.resource_config.accessUrl.endpoint or \"structures\"\n        optimade_query = (\n            self.resource_config.configuration.query_parameters\n            or OPTIMADEQueryParameters()\n        )\n        LOGGER.debug(\"resource_config: %r\", self.resource_config)\n\n        if self.resource_config.accessUrl.query:\n            parsed_query = parse_qs(self.resource_config.accessUrl.query)\n            for field, value in parsed_query.items():\n                # Only use the latest defined value for any parameter\n                if field not in optimade_query.__fields_set__:\n                    LOGGER.debug(\n                        \"Setting %r from accessUrl (value=%r)\", field, value[-1]\n                    )\n                    setattr(optimade_query, field, value[-1])\n\n        LOGGER.debug(\"optimade_query after update: %r\", optimade_query)\n\n        optimade_url = OPTIMADEUrl(\n            f\"{self.resource_config.accessUrl.base_url}\"\n            f\"/{self.resource_config.accessUrl.version or 'v1'}\"\n            f\"/{optimade_endpoint}?{optimade_query.generate_query_string()}\"\n        )\n        LOGGER.debug(\"OPTIMADE URL to be requested: %s\", optimade_url)\n\n        # Set cache access key to the full OPTIMADE URL.\n        self.resource_config.configuration.datacache_config.accessKey = optimade_url\n\n        # Perform query\n        response = requests.get(\n            optimade_url,\n            allow_redirects=True,\n            timeout=(3, 27),  # timeout in seconds (connect, read)\n        )\n\n        if optimade_query.response_format and optimade_query.response_format != \"json\":\n            error_message = (\n                \"Can only handle JSON responses for now. Requested response format: \"\n                f\"{optimade_query.response_format!r}\"\n            )\n            raise NotImplementedError(error_message)\n\n        cache = DataCache(config=self.resource_config.configuration.datacache_config)\n        cache.add(\n            {\n                \"status_code\": response.status_code,\n                \"ok\": response.ok,\n                \"json\": response.json(),\n            }\n        )\n\n        parse_with_dlite = use_dlite(\n            self.resource_config.accessService,\n            self.resource_config.configuration.use_dlite,\n        )\n\n        parse_mediaType = (\n            \"application/vnd.\"\n            f\"{self.resource_config.accessService.split('+', maxsplit=1)[0]}\"\n        )\n        if parse_with_dlite:\n            parse_mediaType += \"+DLite\"\n        elif optimade_query.response_format:\n            parse_mediaType += f\"+{optimade_query.response_format}\"\n\n        parse_config = {\n            \"downloadUrl\": optimade_url,\n            \"mediaType\": parse_mediaType,\n            \"configuration\": {\n                \"datacache_config\": self.resource_config.configuration.datacache_config,\n                \"return_object\": True,\n            },\n        }\n\n        session.update(\n            create_strategy(StrategyType.PARSE, parse_config).initialize(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n        session.update(\n            create_strategy(StrategyType.PARSE, parse_config).get(\n                model2dict(session, exclude_defaults=True, exclude_unset=True)\n            )\n        )\n\n        if \"optimade_response_object\" not in session:\n            error_message = (\n                \"'optimade_response_object' was expected to be present in the session.\"\n            )\n            raise ValueError(error_message)\n\n        optimade_response: OPTIMADEResponse = session.pop(\"optimade_response_object\")\n        if \"optimade_response\" in session and not session.get(\"optimade_response\"):\n            del session[\"optimade_response\"]\n\n        if isinstance(optimade_response, ErrorResponse):\n            optimade_resources = optimade_response.errors\n            session.optimade_resource_model = (\n                f\"{OptimadeError.__module__}:OptimadeError\"\n            )\n        elif isinstance(optimade_response, ReferenceResponseMany):\n            optimade_resources = [\n                Reference(entry).as_dict\n                if isinstance(entry, dict)\n                else Reference(entry.dict()).as_dict\n                for entry in optimade_response.data\n            ]\n            session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n        elif isinstance(optimade_response, ReferenceResponseOne):\n            optimade_resources = [\n                Reference(optimade_response.data).as_dict\n                if isinstance(optimade_response.data, dict)\n                else Reference(optimade_response.data.dict()).as_dict\n            ]\n            session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n        elif isinstance(optimade_response, StructureResponseMany):\n            optimade_resources = [\n                Structure(entry).as_dict\n                if isinstance(entry, dict)\n                else Structure(entry.dict()).as_dict\n                for entry in optimade_response.data\n            ]\n            session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n        elif isinstance(optimade_response, StructureResponseOne):\n            optimade_resources = [\n                Structure(optimade_response.data).as_dict\n                if isinstance(optimade_response.data, dict)\n                else Structure(optimade_response.data.dict()).as_dict\n            ]\n            session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n        else:\n            LOGGER.debug(\n                \"Could not parse response as errors, references or structures. \"\n                \"Response:\\n%r\",\n                optimade_response,\n            )\n            error_message = (\n                \"Could not retrieve errors, references or structures from response \"\n                f\"from {optimade_url}. It could be a valid OPTIMADE API response, \"\n                \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \"\n                \"invalid response completely.\"\n            )\n            raise OPTIMADEParseError(error_message)\n\n        session.optimade_resources = [\n            model2dict(resource) for resource in optimade_resources\n        ]\n\n        if session.optimade_config and session.optimade_config.query_parameters:\n            session = session.copy(\n                update={\n                    \"optimade_config\": session.optimade_config.copy(\n                        update={\n                            \"query_parameters\": model2dict(\n                                session.optimade_config.query_parameters,\n                                exclude_defaults=True,\n                                exclude_unset=True,\n                            )\n                        }\n                    )\n                }\n            )\n\n        if TYPE_CHECKING:  # pragma: no cover\n            assert isinstance(session, OPTIMADEResourceSession)  # nosec\n\n        return session\n</code></pre>"},{"location":"api_reference/strategies/resource/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.get","title":"<code>get(self, session=None)</code>","text":"<p>Execute an OPTIMADE query to <code>accessUrl</code>.</p> <p>This method will be called through the strategy-specific endpoint of the OTE-API Services.</p> <p>Configuration values provided in <code>resource_config.configuration</code> take precedence over the derived values from <code>accessUrl</code>.</p> <p>Workflow: 1. Update configuration according to session. 2. Deconstruct <code>accessUrl</code> (done partly by    <code>oteapi_optimade.models.custom_types.OPTIMADEUrl</code>). 3. Reconstruct the complete query URL. 4. Send query. 5. Store result in data cache.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>SessionUpdate | dict[str, Any] | None</code> <p>A session-specific dictionary-like context.</p> <code>None</code> <p>Returns:</p> Type Description <code>OPTIMADEResourceSession</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def get(\n    self, session: SessionUpdate | dict[str, Any] | None = None\n) -&gt; OPTIMADEResourceSession:\n    \"\"\"Execute an OPTIMADE query to `accessUrl`.\n\n    This method will be called through the strategy-specific endpoint of the\n    OTE-API Services.\n\n    Configuration values provided in `resource_config.configuration` take\n    precedence over the derived values from `accessUrl`.\n\n    Workflow:\n    1. Update configuration according to session.\n    2. Deconstruct `accessUrl` (done partly by\n       `oteapi_optimade.models.custom_types.OPTIMADEUrl`).\n    3. Reconstruct the complete query URL.\n    4. Send query.\n    5. Store result in data cache.\n\n    Parameters:\n        session: A session-specific dictionary-like context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if session and isinstance(session, dict):\n        session = OPTIMADEResourceSession(**session)\n    elif session and isinstance(session, SessionUpdate):\n        session = OPTIMADEResourceSession(\n            **model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    else:\n        session = OPTIMADEResourceSession()\n\n    if session.optimade_config:\n        self.resource_config.configuration.update(\n            model2dict(\n                session.optimade_config, exclude_defaults=True, exclude_unset=True\n            )\n        )\n\n    optimade_endpoint = self.resource_config.accessUrl.endpoint or \"structures\"\n    optimade_query = (\n        self.resource_config.configuration.query_parameters\n        or OPTIMADEQueryParameters()\n    )\n    LOGGER.debug(\"resource_config: %r\", self.resource_config)\n\n    if self.resource_config.accessUrl.query:\n        parsed_query = parse_qs(self.resource_config.accessUrl.query)\n        for field, value in parsed_query.items():\n            # Only use the latest defined value for any parameter\n            if field not in optimade_query.__fields_set__:\n                LOGGER.debug(\n                    \"Setting %r from accessUrl (value=%r)\", field, value[-1]\n                )\n                setattr(optimade_query, field, value[-1])\n\n    LOGGER.debug(\"optimade_query after update: %r\", optimade_query)\n\n    optimade_url = OPTIMADEUrl(\n        f\"{self.resource_config.accessUrl.base_url}\"\n        f\"/{self.resource_config.accessUrl.version or 'v1'}\"\n        f\"/{optimade_endpoint}?{optimade_query.generate_query_string()}\"\n    )\n    LOGGER.debug(\"OPTIMADE URL to be requested: %s\", optimade_url)\n\n    # Set cache access key to the full OPTIMADE URL.\n    self.resource_config.configuration.datacache_config.accessKey = optimade_url\n\n    # Perform query\n    response = requests.get(\n        optimade_url,\n        allow_redirects=True,\n        timeout=(3, 27),  # timeout in seconds (connect, read)\n    )\n\n    if optimade_query.response_format and optimade_query.response_format != \"json\":\n        error_message = (\n            \"Can only handle JSON responses for now. Requested response format: \"\n            f\"{optimade_query.response_format!r}\"\n        )\n        raise NotImplementedError(error_message)\n\n    cache = DataCache(config=self.resource_config.configuration.datacache_config)\n    cache.add(\n        {\n            \"status_code\": response.status_code,\n            \"ok\": response.ok,\n            \"json\": response.json(),\n        }\n    )\n\n    parse_with_dlite = use_dlite(\n        self.resource_config.accessService,\n        self.resource_config.configuration.use_dlite,\n    )\n\n    parse_mediaType = (\n        \"application/vnd.\"\n        f\"{self.resource_config.accessService.split('+', maxsplit=1)[0]}\"\n    )\n    if parse_with_dlite:\n        parse_mediaType += \"+DLite\"\n    elif optimade_query.response_format:\n        parse_mediaType += f\"+{optimade_query.response_format}\"\n\n    parse_config = {\n        \"downloadUrl\": optimade_url,\n        \"mediaType\": parse_mediaType,\n        \"configuration\": {\n            \"datacache_config\": self.resource_config.configuration.datacache_config,\n            \"return_object\": True,\n        },\n    }\n\n    session.update(\n        create_strategy(StrategyType.PARSE, parse_config).initialize(\n            model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    )\n    session.update(\n        create_strategy(StrategyType.PARSE, parse_config).get(\n            model2dict(session, exclude_defaults=True, exclude_unset=True)\n        )\n    )\n\n    if \"optimade_response_object\" not in session:\n        error_message = (\n            \"'optimade_response_object' was expected to be present in the session.\"\n        )\n        raise ValueError(error_message)\n\n    optimade_response: OPTIMADEResponse = session.pop(\"optimade_response_object\")\n    if \"optimade_response\" in session and not session.get(\"optimade_response\"):\n        del session[\"optimade_response\"]\n\n    if isinstance(optimade_response, ErrorResponse):\n        optimade_resources = optimade_response.errors\n        session.optimade_resource_model = (\n            f\"{OptimadeError.__module__}:OptimadeError\"\n        )\n    elif isinstance(optimade_response, ReferenceResponseMany):\n        optimade_resources = [\n            Reference(entry).as_dict\n            if isinstance(entry, dict)\n            else Reference(entry.dict()).as_dict\n            for entry in optimade_response.data\n        ]\n        session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n    elif isinstance(optimade_response, ReferenceResponseOne):\n        optimade_resources = [\n            Reference(optimade_response.data).as_dict\n            if isinstance(optimade_response.data, dict)\n            else Reference(optimade_response.data.dict()).as_dict\n        ]\n        session.optimade_resource_model = f\"{Reference.__module__}:Reference\"\n    elif isinstance(optimade_response, StructureResponseMany):\n        optimade_resources = [\n            Structure(entry).as_dict\n            if isinstance(entry, dict)\n            else Structure(entry.dict()).as_dict\n            for entry in optimade_response.data\n        ]\n        session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n    elif isinstance(optimade_response, StructureResponseOne):\n        optimade_resources = [\n            Structure(optimade_response.data).as_dict\n            if isinstance(optimade_response.data, dict)\n            else Structure(optimade_response.data.dict()).as_dict\n        ]\n        session.optimade_resource_model = f\"{Structure.__module__}:Structure\"\n    else:\n        LOGGER.debug(\n            \"Could not parse response as errors, references or structures. \"\n            \"Response:\\n%r\",\n            optimade_response,\n        )\n        error_message = (\n            \"Could not retrieve errors, references or structures from response \"\n            f\"from {optimade_url}. It could be a valid OPTIMADE API response, \"\n            \"however it may not be supported by OTEAPI-OPTIMADE. It may also be an \"\n            \"invalid response completely.\"\n        )\n        raise OPTIMADEParseError(error_message)\n\n    session.optimade_resources = [\n        model2dict(resource) for resource in optimade_resources\n    ]\n\n    if session.optimade_config and session.optimade_config.query_parameters:\n        session = session.copy(\n            update={\n                \"optimade_config\": session.optimade_config.copy(\n                    update={\n                        \"query_parameters\": model2dict(\n                            session.optimade_config.query_parameters,\n                            exclude_defaults=True,\n                            exclude_unset=True,\n                        )\n                    }\n                )\n            }\n        )\n\n    if TYPE_CHECKING:  # pragma: no cover\n        assert isinstance(session, OPTIMADEResourceSession)  # nosec\n\n    return session\n</code></pre>"},{"location":"api_reference/strategies/resource/#oteapi_optimade.strategies.resource.OPTIMADEResourceStrategy.initialize","title":"<code>initialize(self, session=None)</code>","text":"<p>Initialize strategy.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict[str, Any] | None</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate | DLiteSessionUpdate</code> <p>An update model of key/value-pairs to be stored in the session-specific context from services.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def initialize(\n    self, session: dict[str, Any] | None = None\n) -&gt; SessionUpdate | DLiteSessionUpdate:\n    \"\"\"Initialize strategy.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the session-specific\n        context from services.\n\n    \"\"\"\n    if use_dlite(\n        self.resource_config.accessService,\n        self.resource_config.configuration.use_dlite,\n    ):\n        return DLiteSessionUpdate(collection_id=get_collection(session).uuid)\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/resource/#oteapi_optimade.strategies.resource.use_dlite","title":"<code>use_dlite(access_service, use_dlite_flag)</code>","text":"<p>Determine whether DLite should be utilized in the Resource strategy.</p> <p>Parameters:</p> Name Type Description Default <code>access_service</code> <code>str</code> <p>The accessService value from the resource's configuration.</p> required <code>use_dlite_flag</code> <code>bool</code> <p>The strategy-specific <code>use_dlite</code> configuration option.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Based on the accessService value, then whether DLite should be used or not.</p> Source code in <code>oteapi_optimade/strategies/resource.py</code> <pre><code>def use_dlite(access_service: str, use_dlite_flag: bool) -&gt; bool:\n    \"\"\"Determine whether DLite should be utilized in the Resource strategy.\n\n    Parameters:\n        access_service: The accessService value from the resource's configuration.\n        use_dlite_flag: The strategy-specific `use_dlite` configuration option.\n\n    Returns:\n        Based on the accessService value, then whether DLite should be used or not.\n\n    \"\"\"\n    if (\n        any(dlite_form in access_service for dlite_form in [\"DLite\", \"dlite\"])\n        or use_dlite_flag\n    ):\n        if oteapi_dlite_version is None:\n            error_message = (\n                \"OTEAPI-DLite is not found on the system. This is required to use \"\n                \"DLite with the OTEAPI-OPTIMADE strategies.\"\n            )\n            raise MissingDependency(error_message)\n        return True\n    return False\n</code></pre>"},{"location":"examples/","title":"Overview","text":"<p>This section provides examples of how to use this OTEAPI plugin to perform OPTIMADE queries and handle the results.</p> <p>In Use OTEAPI-OPTIMADE with OTElib you can find an example of how to use this plugin with the OTElib client.</p> <p>It is worth noting that there are several different ways to use the strategies in this plugin. For example, an OPTIMADE query can be provided using the <code>OPTIMADE</code> filter strategy, but it can also be provided directly in the URL value of the <code>OPTIMADE</code> data resource strategy's <code>accessUlr</code> parameter. Further, it could be set through a <code>configuration</code> parameter entry to either of these strategies.</p> <p>In the examples only one of these options are given, and this is the same for other aspects: What we believe is the most common and transparent use case is given.</p> <p>Finally, it is important to note that using OTElib directly is not intended for end users. Using OTElib should be done as a backend task in a web application, and the results should be presented to the end user in a more user friendly way.</p>"},{"location":"examples/#setup-for-examples","title":"Setup for examples","text":""},{"location":"examples/#prerequisites","title":"Prerequisites","text":"<p>To run the examples locally, you need to have the following tools available (in addition to a working Python 3.9+ installation):</p> <ul> <li>Jupyter</li> <li>Docker (or similar containerization tool)</li> </ul>"},{"location":"examples/#jupyter-installation","title":"Jupyter installation","text":"<p>To install Jupyter, please refer to the Jupyter documentation. If you want to use <code>pip</code> to install Jupyter, you can do so by installing the <code>examples</code> extra for this plugin package:</p> <pre><code>pip install oteapi-optimade[examples]\n</code></pre> <p>This will also install OTElib and any other Python packages you may need for the examples.</p>"},{"location":"examples/#docker-installation","title":"Docker installation","text":"<p>To install Docker, please refer to the Docker documentation.</p>"},{"location":"examples/#start-a-local-oteapi-server","title":"Start a local OTEAPI server","text":"<p>When running a local OTEAPI server, you need to ensure the OTEAPI-OPTIMADE plugin is installed. This can be done by using the <code>OTEAPI_PLUGIN_PACKAGES</code> environment variables as described in the OTEAPI Services README.</p> <p>There are two methods of starting the server:</p> <ol> <li>Using Docker</li> <li>Using Docker Compose</li> </ol> <p>No matter the method, the server will be available at <code>http://localhost:80/</code>. To check it, go to the <code>/docs</code> endpoint: localhost:80/docs.</p>"},{"location":"examples/#using-docker","title":"Using Docker","text":"<p>There are no extra files needed to start the server using Docker. However, several commands need to be run to start the server, which is a collection of different microservices running in different containers on the same Docker network.</p> <p>The general setup is outlined in the OTEAPI Services README.</p> <p>For convenience, the following commands can be used to start the services:</p> <pre><code>docker network create otenet\ndocker volume create redis-persist\ndocker run \\\n    --detach \\\n    --name redis \\\n    --volume redis-persist:/data \\\n    --network otenet \\\n    redis:latest\ndocker run \\\n    --rm \\\n    --network otenet \\\n    --detach \\\n    --publish 80:8080 \\\n    --env OTEAPI_REDIS_TYPE=redis \\\n    --env OTEAPI_REDIS_HOST=redis \\\n    --env OTEAPI_REDIS_PORT=6379 \\\n    --env OTEAPI_INCLUDE_REDISADMIN=False \\\n    --env OTEAPI_EXPOSE_SECRETS=True \\\n    --env OTEAPI_PLUGIN_PACKAGES=oteapi-optimade \\\n    ghcr.io/emmc-asbl/oteapi:1.20231108.329\n</code></pre> <p>Note</p> <p>To use the <code>/triples</code> endpoint, an AllegroGraph triplestore needs to be running. For more information see the OTEAPI Services README to see how to set this up and run it.</p> <p>Important</p> <p>Pinning to version '1.20231108.329' of the OTEAPI image is important, as the latest version is currently not compatible with this plugin. To follow this issue, please see GitHub issue #187 and GitHub issue #163.</p>"},{"location":"examples/#using-docker-compose","title":"Using Docker Compose","text":"<p>Download the Docker Compose file from the OTEAPI Services repository:</p> <pre><code>curl -O https://raw.githubusercontent.com/EMMC-ASBL/oteapi-services/master/docker-compose.yml\n</code></pre> <p>And either update the <code>OTEAPI_PLUGIN_PACKAGES</code> environment variable in the file to include <code>oteapi-optimade</code>:</p> <pre><code># ...\n      OTEAPI_PLUGIN_PACKAGES: oteapi-optimade\n# ...\n</code></pre> <p>Or set the environment variable when starting the services by prefixing it to the Docker Compose command.</p> <p>Then start the services:</p> <pre><code>docker compose pull\ndocker compose up --detach\n</code></pre> <p>Note</p> <p>When setting the environment variables as a prefix to the <code>docker compose</code> command, it is only needed for the command that runs the services:</p> <pre><code>OTEAPI_PLUGIN_PACKAGES=oteapi-optimade docker compose up --detach\n</code></pre>"},{"location":"examples/dlite/","title":"Use DLite strategies from OTEAPI-OPTIMADE","text":"In\u00a0[1]: Copied! <pre>from otelib import OTEClient\n\nclient = OTEClient(\"python\")\n</pre> from otelib import OTEClient  client = OTEClient(\"python\") In\u00a0[2]: Copied! <pre>data_resource_strategy = client.create_dataresource(\n    accessService=\"OPTIMADE+DLite\",\n    accessUrl=\"https://optimade.materialsproject.org\",\n)\n\n# This is equivalent to:\n# data_resource_strategy = client.create_dataresource(\n#     accessService=\"OPTIMADE\",\n#     accessUrl=\"https://optimade.materialsproject.org\",\n#     configuration={\"use_dlite\": True},\n# )\n</pre> data_resource_strategy = client.create_dataresource(     accessService=\"OPTIMADE+DLite\",     accessUrl=\"https://optimade.materialsproject.org\", )  # This is equivalent to: # data_resource_strategy = client.create_dataresource( #     accessService=\"OPTIMADE\", #     accessUrl=\"https://optimade.materialsproject.org\", #     configuration={\"use_dlite\": True}, # ) In\u00a0[3]: Copied! <pre>filter_strategy = client.create_filter(\n    filterType=\"OPTIMADE\",\n    query='elements HAS ALL \"Si\",\"O\" AND nelements&lt;=4',\n)\n</pre> filter_strategy = client.create_filter(     filterType=\"OPTIMADE\",     query='elements HAS ALL \"Si\",\"O\" AND nelements&lt;=4', ) In\u00a0[4]: Copied! <pre>import json\n\npipeline = filter_strategy &gt;&gt; data_resource_strategy\nsession = pipeline.get()\nparsed_session = json.loads(session)\nparsed_session.keys()\n</pre> import json  pipeline = filter_strategy &gt;&gt; data_resource_strategy session = pipeline.get() parsed_session = json.loads(session) parsed_session.keys() <pre>/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/optimade/server/config.py:113: UserWarning: Unable to find config file at /home/runner/.optimade.json, using the default settings instead.\n  warnings.warn(\n</pre> Out[4]: <pre>dict_keys(['optimade_config', 'optimade_resources', 'optimade_resource_model', 'collection_id'])</pre> In\u00a0[5]: Copied! <pre>from importlib import import_module\n\nimport_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1)\nResourceClass = getattr(import_module(import_path), class_name)\n\nparsed_structures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]]\nprint(f\"The query resulted in {len(parsed_structures)} structures found (on page 1) of the returned data.\")\nprint(f\"Their Materials Project IDs are: {[structure.id for structure in parsed_structures]}\")\n</pre> from importlib import import_module  import_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1) ResourceClass = getattr(import_module(import_path), class_name)  parsed_structures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]] print(f\"The query resulted in {len(parsed_structures)} structures found (on page 1) of the returned data.\") print(f\"Their Materials Project IDs are: {[structure.id for structure in parsed_structures]}\") <pre>The query resulted in 20 structures found (on page 1) of the returned data.\nTheir Materials Project IDs are: ['mp-1033911', 'mp-733539', 'mp-1219366', 'mp-757887', 'mp-542090', 'mp-560675', 'mp-758465', 'mp-774171', 'mp-1304778', 'mp-1016821', 'mp-1363556', 'mp-757013', 'mp-1020609', 'mp-17612', 'mp-683953', 'mp-759087', 'mp-752892', 'mp-581955', 'mp-802450', 'mp-1195212']\n</pre> In\u00a0[6]: Copied! <pre>from oteapi_dlite.utils import get_collection\n\ncollection = get_collection(session=parsed_session)\nprint(collection)\n</pre> from oteapi_dlite.utils import get_collection  collection = get_collection(session=parsed_session) print(collection) <pre>{\n  \"fc925ad9-8eed-4e84-9ee0-f5dfed3e84d9\":  {\n    \"meta\": \"http://onto-ns.com/meta/0.1/Collection\",\n    \"dimensions\": {\n      \"nrelations\": 60\n    },\n    \"properties\": {\n      \"relations\": [[\"mp-1033911\", \"_is-a\", \"Instance\"], [\"mp-1033911\", \"_has-uuid\", \"ca1ac001-f437-4f31-96ef-f832a3ff7e9d\"], [\"mp-1033911\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-733539\", \"_is-a\", \"Instance\"], [\"mp-733539\", \"_has-uuid\", \"2a7bd4df-dae7-4557-9e66-490fd6a66fa1\"], [\"mp-733539\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-1219366\", \"_is-a\", \"Instance\"], [\"mp-1219366\", \"_has-uuid\", \"91a0861e-6b37-4d27-a62b-ec88b7ffc624\"], [\"mp-1219366\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-757887\", \"_is-a\", \"Instance\"], [\"mp-757887\", \"_has-uuid\", \"75a5daba-4076-4e39-9d8d-348655dedf33\"], [\"mp-757887\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-542090\", \"_is-a\", \"Instance\"], [\"mp-542090\", \"_has-uuid\", \"fed2f146-9cb8-4394-b57b-cf7a0aaaed4d\"], [\"mp-542090\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-560675\", \"_is-a\", \"Instance\"], [\"mp-560675\", \"_has-uuid\", \"a7e0f5f8-3efc-4c8b-9adc-51db5f9ea60c\"], [\"mp-560675\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-758465\", \"_is-a\", \"Instance\"], [\"mp-758465\", \"_has-uuid\", \"5ac2a031-1efe-40db-96b9-09ebce81bc78\"], [\"mp-758465\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-774171\", \"_is-a\", \"Instance\"], [\"mp-774171\", \"_has-uuid\", \"cb44e4de-0150-4604-90e3-22295cf2d842\"], [\"mp-774171\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-1304778\", \"_is-a\", \"Instance\"], [\"mp-1304778\", \"_has-uuid\", \"d75b7b83-6e1f-4be9-b7f1-98e6a3b5d2e1\"], [\"mp-1304778\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-1016821\", \"_is-a\", \"Instance\"], [\"mp-1016821\", \"_has-uuid\", \"191d4531-b7ed-4d86-b4be-dd634216474b\"], [\"mp-1016821\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-1363556\", \"_is-a\", \"Instance\"], [\"mp-1363556\", \"_has-uuid\", \"d5acae2d-5fbb-4d76-98f3-9e3228875c4b\"], [\"mp-1363556\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-757013\", \"_is-a\", \"Instance\"], [\"mp-757013\", \"_has-uuid\", \"37ba681d-0ae8-45e8-8109-0f8082fed5f2\"], [\"mp-757013\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-1020609\", \"_is-a\", \"Instance\"], [\"mp-1020609\", \"_has-uuid\", \"ae261285-3429-4dfe-9abf-66c7db8386a0\"], [\"mp-1020609\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-17612\", \"_is-a\", \"Instance\"], [\"mp-17612\", \"_has-uuid\", \"bbb368fd-63a1-4538-afc1-2043e41ea293\"], [\"mp-17612\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-683953\", \"_is-a\", \"Instance\"], [\"mp-683953\", \"_has-uuid\", \"21ac056a-7ca4-4a5f-bcc5-06bcf9ac1e2a\"], [\"mp-683953\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-759087\", \"_is-a\", \"Instance\"], [\"mp-759087\", \"_has-uuid\", \"396dd669-8342-4946-a536-5a22b5e40c07\"], [\"mp-759087\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-752892\", \"_is-a\", \"Instance\"], [\"mp-752892\", \"_has-uuid\", \"5a6f450a-b146-4d57-a570-77f90d4e0ca2\"], [\"mp-752892\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-581955\", \"_is-a\", \"Instance\"], [\"mp-581955\", \"_has-uuid\", \"9c4f6fdc-3bd3-4aac-99b0-107f4e883f2e\"], [\"mp-581955\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-802450\", \"_is-a\", \"Instance\"], [\"mp-802450\", \"_has-uuid\", \"de8b4bfb-bdc1-49da-a5c7-ac41182e9a86\"], [\"mp-802450\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"], [\"mp-1195212\", \"_is-a\", \"Instance\"], [\"mp-1195212\", \"_has-uuid\", \"2fa3cb36-3c50-4b7e-afbe-d8269fbe0a5f\"], [\"mp-1195212\", \"_has-meta\", \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\"]]\n    }\n  }\n}\n</pre> In\u00a0[7]: Copied! <pre>for inst in collection.get_instances():\n    print(inst)\n</pre> for inst in collection.get_instances():     print(inst) <pre>{\n  \"ca1ac001-f437-4f31-96ef-f832a3ff7e9d\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"7b312fde-3c3d-4206-b028-5e93a7b3ee0a\",\n      \"id\": \"mp-1033911\"\n    }\n  }\n}\n{\n  \"2a7bd4df-dae7-4557-9e66-490fd6a66fa1\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"82f2d821-92dd-484c-9640-e9fe9db02a31\",\n      \"id\": \"mp-733539\"\n    }\n  }\n}\n{\n  \"91a0861e-6b37-4d27-a62b-ec88b7ffc624\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"2007f0d1-147c-4e88-adc9-e85209c1f64e\",\n      \"id\": \"mp-1219366\"\n    }\n  }\n}\n{\n  \"75a5daba-4076-4e39-9d8d-348655dedf33\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"4810bec1-01ca-49ad-ad41-aebf846e5003\",\n      \"id\": \"mp-757887\"\n    }\n  }\n}\n{\n  \"fed2f146-9cb8-4394-b57b-cf7a0aaaed4d\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"06d26603-74a8-4c91-811b-a914bc8f90e6\",\n      \"id\": \"mp-542090\"\n    }\n  }\n}\n{\n  \"a7e0f5f8-3efc-4c8b-9adc-51db5f9ea60c\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"c41ff7ad-55df-4070-ba3d-41cd58809114\",\n      \"id\": \"mp-560675\"\n    }\n  }\n}\n{\n  \"5ac2a031-1efe-40db-96b9-09ebce81bc78\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"9edbb1fa-29c4-45ef-830a-e8e8bb4181bf\",\n      \"id\": \"mp-758465\"\n    }\n  }\n}\n{\n  \"cb44e4de-0150-4604-90e3-22295cf2d842\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"3d1b10d8-a934-4d6d-be28-970330e99143\",\n      \"id\": \"mp-774171\"\n    }\n  }\n}\n{\n  \"d75b7b83-6e1f-4be9-b7f1-98e6a3b5d2e1\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"add44ee5-1d68-4d54-b990-c27abdf221d7\",\n      \"id\": \"mp-1304778\"\n    }\n  }\n}\n{\n  \"191d4531-b7ed-4d86-b4be-dd634216474b\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"17cd161d-78c7-487f-a049-bbd865d4c731\",\n      \"id\": \"mp-1016821\"\n    }\n  }\n}\n{\n  \"d5acae2d-5fbb-4d76-98f3-9e3228875c4b\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"e9b85881-d234-4bbe-806b-b50a7daba7c1\",\n      \"id\": \"mp-1363556\"\n    }\n  }\n}\n{\n  \"37ba681d-0ae8-45e8-8109-0f8082fed5f2\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"5e445a56-9703-499c-8b35-fd06bb37a2df\",\n      \"id\": \"mp-757013\"\n    }\n  }\n}\n{\n  \"ae261285-3429-4dfe-9abf-66c7db8386a0\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"c78d5fa1-31b1-4301-b0d2-2c4c32bafa62\",\n      \"id\": \"mp-1020609\"\n    }\n  }\n}\n{\n  \"bbb368fd-63a1-4538-afc1-2043e41ea293\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"abce813a-4971-4ffa-b62a-4057d923c70e\",\n      \"id\": \"mp-17612\"\n    }\n  }\n}\n{\n  \"21ac056a-7ca4-4a5f-bcc5-06bcf9ac1e2a\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"ed590ac6-9759-49d2-9937-0b21478e1a19\",\n      \"id\": \"mp-683953\"\n    }\n  }\n}\n{\n  \"396dd669-8342-4946-a536-5a22b5e40c07\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"7f3c423b-596b-49d9-a58c-115869225b44\",\n      \"id\": \"mp-759087\"\n    }\n  }\n}\n{\n  \"5a6f450a-b146-4d57-a570-77f90d4e0ca2\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"f5646a09-5ccd-4de8-868d-e3a4bbe2e5e4\",\n      \"id\": \"mp-752892\"\n    }\n  }\n}\n{\n  \"9c4f6fdc-3bd3-4aac-99b0-107f4e883f2e\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"cbec9461-7c5a-4039-a02a-63a7c6e811ab\",\n      \"id\": \"mp-581955\"\n    }\n  }\n}\n{\n  \"de8b4bfb-bdc1-49da-a5c7-ac41182e9a86\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"0e60aab4-a47c-4f3e-9642-66225ef5f0b7\",\n      \"id\": \"mp-802450\"\n    }\n  }\n}\n{\n  \"2fa3cb36-3c50-4b7e-afbe-d8269fbe0a5f\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructure\",\n    \"dimensions\": {\n    },\n    \"properties\": {\n      \"type\": \"structures\",\n      \"attributes\": \"48e23680-c707-4323-84d2-0dc879d14ac0\",\n      \"id\": \"mp-1195212\"\n    }\n  }\n}\n</pre> In\u00a0[8]: Copied! <pre>import dlite\n\nstructure_instances: list[dlite.Instance] = list(collection.get_instances())\n\nstructure_attributes_instance: dlite.Instance = dlite.get_instance(structure_instances[0].attributes)\n\nprint(structure_attributes_instance)\n</pre> import dlite  structure_instances: list[dlite.Instance] = list(collection.get_instances())  structure_attributes_instance: dlite.Instance = dlite.get_instance(structure_instances[0].attributes)  print(structure_attributes_instance) <pre>{\n  \"7b312fde-3c3d-4206-b028-5e93a7b3ee0a\":  {\n    \"meta\": \"http://onto-ns.com/meta/1.0/OPTIMADEStructureAttributes\",\n    \"dimensions\": {\n      \"nelements\": 4,\n      \"dimensionality\": 3,\n      \"nsites\": 32,\n      \"nspecies\": 4,\n      \"nstructure_features\": 0\n    },\n    \"properties\": {\n      \"elements\": [\"K\", \"Mg\", \"O\", \"Si\"],\n      \"elements_ratios\": [0.03125, 0.4375, 0.03125, 0.5],\n      \"chemical_formula_descriptive\": \"KMg14O16Si\",\n      \"chemical_formula_reduced\": \"KMg14O16Si\",\n      \"chemical_formula_hill\": \"KMg14O16Si\",\n      \"chemical_formula_anonymous\": \"A16B14CD\",\n      \"dimension_types\": [1, 1, 1],\n      \"nperiodic_dimensions\": 3,\n      \"lattice_vectors\": [[8.59318, 0, 0], [0, 8.59318, 0], [0, 0, 4.41201]],\n      \"cartesian_site_positions\": [[0, 0, 0], [0, 4.29659, 0], [4.29659, 0, 0], [0, 2.1438, 2.20601], [0, 6.44938, 2.20601], [4.29659, 2.13079, 2.20601], [4.29659, 6.46238, 2.20601], [2.1438, 0, 2.20601], [2.13079, 4.29659, 2.20601], [6.44938, 0, 2.20601], [6.46238, 4.29659, 2.20601], [2.12673, 2.12673, 0], [2.12673, 6.46645, 0], [6.46645, 2.12673, 0], [6.46645, 6.46645, 0], [4.29659, 4.29659, 0], [2.37689, 0, 0], [2.32997, 4.29659, 0], [6.21628, 0, 0], [6.2632, 4.29659, 0], [2.16162, 2.16162, 2.20601], [2.16162, 6.43155, 2.20601], [6.43155, 2.16162, 2.20601], [6.43155, 6.43155, 2.20601], [0, 0, 2.20601], [0, 4.29659, 2.20601], [4.29659, 0, 2.20601], [4.29659, 4.29659, 2.20601], [0, 2.37689, 0], [0, 6.21628, 0], [4.29659, 2.32997, 0], [4.29659, 6.2632, 0]],\n      \"species\": [\"880b5e68-270f-42ac-b7e9-ffd8a4f0ddb6\", \"a39f351c-3664-4aaf-a5ca-f98bc1df5551\", \"fe9d178c-491f-431d-9d95-677f19985848\", \"4cbbc9ff-0098-44e7-a1eb-9f7263ecc4a8\"],\n      \"species_at_sites\": [\"K\", \"Mg\", \"Mg\", \"Mg\", \"Mg\", \"Mg\", \"Mg\", \"Mg\", \"Mg\", \"Mg\", \"Mg\", \"Mg\", \"Mg\", \"Mg\", \"Mg\", \"Si\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\", \"O\"],\n      \"assemblies\": null,\n      \"structure_features\": [],\n      \"immutable_id\": \"645d2b74bcd30f748b4746a3\",\n      \"last_modified\": \"2019-10-23 12:27:13.694000\"\n    }\n  }\n}\n</pre>"},{"location":"examples/dlite/#use-dlite-strategies-from-oteapi-optimade","title":"Use DLite strategies from OTEAPI-OPTIMADE\u00b6","text":"<p>This example shows how to use the DLite strategies from the OTEAPI-OPTIMADE plugin.</p> <p>DLite is a Python library for working with data models and semantics. It is considered to be the default semantic data model backend for use with OTEAPI.</p> <p>To see more fundamental examples of how to use OTEAPI-OPTIMADE, see the example Use OTEAPI-OPTIMADE with OTElib. OTElib will also be used as a client in the current example. Furthermore, only the HTTP requests-based backend will be used in this example.</p>"},{"location":"examples/dlite/#setup","title":"Setup\u00b6","text":"<p>Please see the setup instructions in Use OTEAPI-OPTIMADE with OTElib for how to ensure you have a proper environment to run the example in.</p>"},{"location":"examples/dlite/#example","title":"Example\u00b6","text":"<p>In this example, we will use the DLite strategies to query the Materials Project OPTIMADE API. We are interested in finding all structures that include the elements <code>Si</code> and <code>O</code>, and that have a maximum of 4 elements in total.</p>"},{"location":"examples/dlite/#create-a-client","title":"Create a client\u00b6","text":"<p>Let's start by initializing a client:</p>"},{"location":"examples/dlite/#data-resource-strategy","title":"Data Resource strategy\u00b6","text":"<p>The general pipeline is the same as it was for Use OTEAPI-OPTIMADE with OTElib:</p> <p></p> <p>However, in order to use DLite we need to either reference a specific <code>accessService</code> or set a flag in the configuration of the data resource strategy.</p> <p>Note, it is only for the data resource strategy we need to specify the usage of DLite, as the filter strategy is generic and merely a helper for more explicitly setting the query parameters to be used for the underlying OPTIMADE query.</p>"},{"location":"examples/dlite/#filter-strategy","title":"Filter strategy\u00b6","text":"<p>The OPTIMADE filter query to fulfill the interests outlined above should look like this:</p> <pre><code>elements HAS ALL \"Si\",\"O\" AND nelements&lt;=4\n</code></pre>"},{"location":"examples/dlite/#setup-execute-and-inspect-the-pipeline","title":"Setup, execute and inspect the pipeline\u00b6","text":""},{"location":"examples/otelib/","title":"Use OTEAPI-OPTIMADE with OTElib","text":"In\u00a0[1]: Copied! <pre>from otelib import OTEClient\n\nclient = OTEClient(\"http://localhost:80\")\n</pre> from otelib import OTEClient  client = OTEClient(\"http://localhost:80\") In\u00a0[2]: Copied! <pre>data_resource_strategy = client.create_dataresource(\n    accessService=\"OPTIMADE\",\n    accessUrl=\"https://optimade.materialsproject.org/\",\n)\n</pre> data_resource_strategy = client.create_dataresource(     accessService=\"OPTIMADE\",     accessUrl=\"https://optimade.materialsproject.org/\", ) <p>For the filter strategy, we need to know the OPTIMADE query that we want to execute.</p> <p>For retrieving all structures with the formula <code>Al2O3</code>, we can use the following OPTIMADE filter query:</p> <pre><code>chemical_formula_descriptive = \"Al2O3\" OR chemical_formula_reduced = \"Al2O3\" OR chemical_formula_hill = \"Al2O3\"\n</code></pre> In\u00a0[3]: Copied! <pre>filter_strategy = client.create_filter(\n    filterType=\"OPTIMADE\",\n    query='chemical_formula_descriptive = \"Al2O3\" OR chemical_formula_reduced = \"Al2O3\" OR chemical_formula_hill = \"Al2O3\"',\n)\n</pre> filter_strategy = client.create_filter(     filterType=\"OPTIMADE\",     query='chemical_formula_descriptive = \"Al2O3\" OR chemical_formula_reduced = \"Al2O3\" OR chemical_formula_hill = \"Al2O3\"', ) <p>Now we can create the OTE pipeline shown above and execute it.</p> In\u00a0[4]: Copied! <pre>pipeline = filter_strategy &gt;&gt; data_resource_strategy\nsession = pipeline.get()\n</pre> pipeline = filter_strategy &gt;&gt; data_resource_strategy session = pipeline.get() <p>The returned session is a JSON object we can parse and investigate.</p> In\u00a0[5]: Copied! <pre>import json\n\nparsed_session: dict = json.loads(session)\nprint(parsed_session.keys())\n</pre> import json  parsed_session: dict = json.loads(session) print(parsed_session.keys()) <pre>dict_keys(['optimade_resources', 'optimade_config', 'optimade_resource_model'])\n</pre> <p>As can be seen, there are three keys in the returned session. <code>optimade_config</code> summarizes the query that has been performed to Materials Project. The OPTIMADE structures are listed under the <code>optimade_resources</code>. It is named as such due to there being different OPTIMADE resources, e.g., <code>structures</code>, <code>references</code>, <code>links</code>, etc. The OPTIMADE Python tools has a useful OPTIMADE Structure model class that can be used to parse the OPTIMADE structures into Python objects as well as validating them according to the OPTIMADE specification. Again, since one can query for different OPTIMADE resources, the specific Python class to use is given in <code>optimade_resource_model</code>.</p> In\u00a0[6]: Copied! <pre>from importlib import import_module\n\nimport_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1)\nResourceClass = getattr(import_module(import_path), class_name)\n\nparsed_structures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]]\nprint(f\"The query resulted in {len(parsed_structures)} structures found (on page 1) of the returned data.\")\nprint(f\"Their Materials Project IDs are: {[structure.id for structure in parsed_structures]}\")\n</pre> from importlib import import_module  import_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1) ResourceClass = getattr(import_module(import_path), class_name)  parsed_structures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]] print(f\"The query resulted in {len(parsed_structures)} structures found (on page 1) of the returned data.\") print(f\"Their Materials Project IDs are: {[structure.id for structure in parsed_structures]}\") <pre>The query resulted in 20 structures found (on page 1) of the returned data.\nTheir Materials Project IDs are: ['mp-1228448', 'mp-755483', 'mp-1245081', 'mp-1244878', 'mp-1105018', 'mp-754401', 'mp-1245063', 'mp-1245265', 'mp-684591', 'mp-1244898', 'mp-1245211', 'mp-1245056', 'mp-642363', 'mp-1244930', 'mp-1244937', 'mp-1244967', 'mp-1244954', 'mp-1244874', 'mp-1245008', 'mp-1245023']\n</pre> <p>To find them on the Materials Project website, go to <code>materialsproject.org/materials/&lt;ID&gt;</code>, for example: materialsproject.org/materials/mp-1228448.</p> <p>What is more, we can investigate the structure according to the well-defined OPTIMADE structure model attributes. For example, so assert the chemical formula is what we expected, we can check the different chemical formula attributes:</p> In\u00a0[7]: Copied! <pre>structure = parsed_structures[0]\nprint(structure.id)\nfor attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):\n    print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\")\n</pre> structure = parsed_structures[0] print(structure.id) for attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):     print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\") <pre>mp-1228448\nchemical_formula_descriptive: Al2O3\nchemical_formula_reduced: Al2O3\nchemical_formula_hill: Al2O3\nchemical_formula_anonymous: A3B2\n</pre> In\u00a0[8]: Copied! <pre>filter_strategy = client.create_filter(\n    filterType=\"OPTIMADE\",\n    query='elements HAS ALL \"Al\",\"O\"',\n    limit=5,\n)\n</pre> filter_strategy = client.create_filter(     filterType=\"OPTIMADE\",     query='elements HAS ALL \"Al\",\"O\"',     limit=5, ) <p>For this query, we have added the <code>limit</code> parameter to the filter configuration, which will pass a <code>page_limit</code> query parameter to the OPTIMADE API ensuring that we only retrieve the first 5 structures (it limits each result's page to 5 resources).</p> <p>Let us investigate the result again, checking the list of elements and the chemical formula attributes:</p> In\u00a0[9]: Copied! <pre>pipeline = filter_strategy &gt;&gt; data_resource_strategy\nparsed_session = json.loads(pipeline.get())\nprint(f\"The query resulted in {len(parsed_session['optimade_resources'])} structures found (on page 1) of the returned data.\")\n\nimport_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1)\nResourceClass = getattr(import_module(import_path), class_name)\nstructures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]]\nprint(f\"Their Materials Project IDs are: {[structure.id for structure in structures]}\")\n</pre> pipeline = filter_strategy &gt;&gt; data_resource_strategy parsed_session = json.loads(pipeline.get()) print(f\"The query resulted in {len(parsed_session['optimade_resources'])} structures found (on page 1) of the returned data.\")  import_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1) ResourceClass = getattr(import_module(import_path), class_name) structures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]] print(f\"Their Materials Project IDs are: {[structure.id for structure in structures]}\") <pre>The query resulted in 5 structures found (on page 1) of the returned data.\nTheir Materials Project IDs are: ['mp-1038042', 'mp-1182891', 'mp-1208627', 'mp-1247835', 'mp-1521059']\n</pre> <p>Let us also check the query parameters used for the request to the OPTIMADE API to ensure that the <code>page_limit</code> query parameter was passed:</p> In\u00a0[10]: Copied! <pre>parsed_session[\"optimade_config\"]\n</pre> parsed_session[\"optimade_config\"] Out[10]: <pre>{'query_parameters': {'filter': 'elements HAS ALL \"Al\",\"O\"', 'page_limit': 5}}</pre> In\u00a0[11]: Copied! <pre>structure = structures[0]\nprint(structure.id)\nprint(f\"elements: {structure.elements}\")\nfor attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):\n    print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\")\n</pre> structure = structures[0] print(structure.id) print(f\"elements: {structure.elements}\") for attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):     print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\") <pre>mp-1038042\nelements: ['Al', 'Cr', 'Mg', 'O']\nchemical_formula_descriptive: AlCrMg30O32\nchemical_formula_reduced: AlCrMg30O32\nchemical_formula_hill: AlCrMg30O32\nchemical_formula_anonymous: A32B30CD\n</pre> In\u00a0[12]: Copied! <pre>data_resource_strategy = client.create_dataresource(\n    accessService=\"OPTIMADE\",\n    accessUrl=\"https://aiida.materialscloud.org/mc3d/optimade\",\n)\n</pre> data_resource_strategy = client.create_dataresource(     accessService=\"OPTIMADE\",     accessUrl=\"https://aiida.materialscloud.org/mc3d/optimade\", ) In\u00a0[13]: Copied! <pre>pipeline = filter_strategy &gt;&gt; data_resource_strategy\nparsed_session = json.loads(pipeline.get())\nprint(f\"The query resulted in {len(parsed_session['optimade_resources'])} structures found (on page 1) of the returned data.\")\n\nimport_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1)\nResourceClass = getattr(import_module(import_path), class_name)\nstructures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]]\nprint(f\"Their Materials Cloud (AiiDA) IDs are: {[structure.id for structure in structures]}\")\n</pre> pipeline = filter_strategy &gt;&gt; data_resource_strategy parsed_session = json.loads(pipeline.get()) print(f\"The query resulted in {len(parsed_session['optimade_resources'])} structures found (on page 1) of the returned data.\")  import_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1) ResourceClass = getattr(import_module(import_path), class_name) structures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]] print(f\"Their Materials Cloud (AiiDA) IDs are: {[structure.id for structure in structures]}\") <pre>The query resulted in 5 structures found (on page 1) of the returned data.\nTheir Materials Cloud (AiiDA) IDs are: ['13952', '43703', '43800', '56101', '56270']\n</pre> <p>Again, let's check the query parameters used for the request to the OPTIMADE API to ensure it is equivalent to the previous search:</p> In\u00a0[14]: Copied! <pre>parsed_session[\"optimade_config\"]\n</pre> parsed_session[\"optimade_config\"] Out[14]: <pre>{'query_parameters': {'filter': 'elements HAS ALL \"Al\",\"O\"', 'page_limit': 5}}</pre> In\u00a0[15]: Copied! <pre>structure = structures[0]\nprint(structure.id)\nprint(f\"elements: {structure.elements}\")\nfor attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):\n    print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\")\n</pre> structure = structures[0] print(structure.id) print(f\"elements: {structure.elements}\") for attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):     print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\") <pre>13952\nelements: ['Al', 'O']\nchemical_formula_descriptive: Al2O6\nchemical_formula_reduced: AlO3\nchemical_formula_hill: Al2O6\nchemical_formula_anonymous: A3B\n</pre> <p>The MC3D structures can, unfortunately, not be found easily in the Materials Cloud website, as the ID in the DISCOVER section does not match the ID in the OPTIMADE structure. However, the full OPTIMADE structure can be found at <code>&lt;OPTIMADE_BASE_URL&gt;/structures/&lt;ID&gt;</code>, for example: aiida.materialscloud.org/mc3d/optimade/structures/13952.</p> <p>Note</p> <p>     The structure with the OPTIMADE ID 13952 is found with the Materials Cloud DISCOVER ID <code>mc3d-76896</code> and can be found here.   </p> In\u00a0[16]: Copied! <pre>client = OTEClient(\"python\")\n</pre> client = OTEClient(\"python\") <p>Now we can go through the same searches as we did with the HTTP requests-based backend. The result should not change.</p> In\u00a0[17]: Copied! <pre>data_resource_strategy = client.create_dataresource(\n    accessService=\"OPTIMADE\",\n    accessUrl=\"https://optimade.materialsproject.org/\",\n)\n\nfilter_strategy = client.create_filter(\n    filterType=\"OPTIMADE\",\n    query='chemical_formula_descriptive = \"Al2O3\" OR chemical_formula_reduced = \"Al2O3\" OR chemical_formula_hill = \"Al2O3\"',\n)\n\npipeline = filter_strategy &gt;&gt; data_resource_strategy\nsession = pipeline.get()\n</pre> data_resource_strategy = client.create_dataresource(     accessService=\"OPTIMADE\",     accessUrl=\"https://optimade.materialsproject.org/\", )  filter_strategy = client.create_filter(     filterType=\"OPTIMADE\",     query='chemical_formula_descriptive = \"Al2O3\" OR chemical_formula_reduced = \"Al2O3\" OR chemical_formula_hill = \"Al2O3\"', )  pipeline = filter_strategy &gt;&gt; data_resource_strategy session = pipeline.get() <pre>Setting filter from query.\nSetting filter from query.\nresource_config: OPTIMADEResourceConfig(user=None, password=None, token=None, client_id=None, client_secret=None, configuration=OPTIMADEConfig(version='v1', endpoint='structures', query_parameters=OPTIMADEQueryParameters(filter='chemical_formula_descriptive = \"Al2O3\" OR chemical_formula_reduced = \"Al2O3\" OR chemical_formula_hill = \"Al2O3\"', response_format='json', email_address='', response_fields='', sort='', page_limit=20, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint=''), datacache_config=DataCacheConfig(cacheDir=PosixPath('oteapi'), accessKey=None, hashType='md5', expireTime=86400, tag='optimade'), return_object=False, use_dlite=False), description='Resource Strategy Data Configuration.\\n\\n    Important:\\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\\n        `accessUrl`/`accessService` MUST be specified.\\n\\n    ', downloadUrl=None, mediaType=None, accessUrl=OPTIMADEUrl('https://optimade.materialsproject.org/', base_url='https://optimade.materialsproject.org', scheme='https', tld='org', host_type='domain'), accessService='OPTIMADE', license=None, accessRights=None, publisher=None)\nresource_config: OPTIMADEResourceConfig(user=None, password=None, token=None, client_id=None, client_secret=None, configuration=OPTIMADEConfig(version='v1', endpoint='structures', query_parameters=OPTIMADEQueryParameters(filter='chemical_formula_descriptive = \"Al2O3\" OR chemical_formula_reduced = \"Al2O3\" OR chemical_formula_hill = \"Al2O3\"', response_format='json', email_address='', response_fields='', sort='', page_limit=20, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint=''), datacache_config=DataCacheConfig(cacheDir=PosixPath('oteapi'), accessKey=None, hashType='md5', expireTime=86400, tag='optimade'), return_object=False, use_dlite=False), description='Resource Strategy Data Configuration.\\n\\n    Important:\\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\\n        `accessUrl`/`accessService` MUST be specified.\\n\\n    ', downloadUrl=None, mediaType=None, accessUrl=OPTIMADEUrl('https://optimade.materialsproject.org/', base_url='https://optimade.materialsproject.org', scheme='https', tld='org', host_type='domain'), accessService='OPTIMADE', license=None, accessRights=None, publisher=None)\noptimade_query after update: OPTIMADEQueryParameters(filter='chemical_formula_descriptive = \"Al2O3\" OR chemical_formula_reduced = \"Al2O3\" OR chemical_formula_hill = \"Al2O3\"', response_format='json', email_address='', response_fields='', sort='', page_limit=20, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint='')\noptimade_query after update: OPTIMADEQueryParameters(filter='chemical_formula_descriptive = \"Al2O3\" OR chemical_formula_reduced = \"Al2O3\" OR chemical_formula_hill = \"Al2O3\"', response_format='json', email_address='', response_fields='', sort='', page_limit=20, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint='')\nOPTIMADE URL to be requested: https://optimade.materialsproject.org/v1/structures?filter=chemical_formula_descriptive%20%3D%20%22Al2O3%22%20OR%20chemical_formula_reduced%20%3D%20%22Al2O3%22%20OR%20chemical_formula_hill%20%3D%20%22Al2O3%22&amp;response_format=json&amp;page_limit=20&amp;include=references\nOPTIMADE URL to be requested: https://optimade.materialsproject.org/v1/structures?filter=chemical_formula_descriptive%20%3D%20%22Al2O3%22%20OR%20chemical_formula_reduced%20%3D%20%22Al2O3%22%20OR%20chemical_formula_hill%20%3D%20%22Al2O3%22&amp;response_format=json&amp;page_limit=20&amp;include=references\n</pre> <pre>/home/cwa/.venvs/oteapi-optimade/lib/python3.9/site-packages/optimade/server/config.py:113: UserWarning: Unable to find config file at /home/cwa/.optimade.json, using the default settings instead.\n  warnings.warn(\n</pre> <p>As one can see, this backend runs locally within the same Python environment as the notebook. This is useful for development purposes, where the logging messages are shown directly in the output.</p> In\u00a0[18]: Copied! <pre>parsed_session: dict = json.loads(session)\nprint(parsed_session.keys())\n</pre> parsed_session: dict = json.loads(session) print(parsed_session.keys()) <pre>dict_keys(['optimade_config', 'optimade_resources', 'optimade_resource_model'])\n</pre> <p>We get the same keys in the returned session as we did with the HTTP requests-based backend. If we again import the OPTIMADE Structure model class from the OPTIMADE Python tools, we can parse the OPTIMADE structures into Python objects as well as validating them according to the OPTIMADE specification, just as we did with the HTTP requests-based backend.</p> In\u00a0[19]: Copied! <pre>import_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1)\nResourceClass = getattr(import_module(import_path), class_name)\n\nparsed_structures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]]\nprint(f\"The query resulted in {len(parsed_structures)} structures found (on page 1) of the returned data.\")\nprint(f\"Their Materials Project IDs are: {[structure.id for structure in parsed_structures]}\")\n\nstructure = parsed_structures[0]\nprint(structure.id)\nfor attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):\n    print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\")\n</pre> import_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1) ResourceClass = getattr(import_module(import_path), class_name)  parsed_structures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]] print(f\"The query resulted in {len(parsed_structures)} structures found (on page 1) of the returned data.\") print(f\"Their Materials Project IDs are: {[structure.id for structure in parsed_structures]}\")  structure = parsed_structures[0] print(structure.id) for attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):     print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\") <pre>The query resulted in 20 structures found (on page 1) of the returned data.\nTheir Materials Project IDs are: ['mp-1228448', 'mp-755483', 'mp-1245081', 'mp-1244878', 'mp-1105018', 'mp-754401', 'mp-1245063', 'mp-1245265', 'mp-684591', 'mp-1244898', 'mp-1245211', 'mp-1245056', 'mp-642363', 'mp-1244930', 'mp-1244937', 'mp-1244967', 'mp-1244954', 'mp-1244874', 'mp-1245008', 'mp-1245023']\nmp-1228448\nchemical_formula_descriptive: Al2O3\nchemical_formula_reduced: Al2O3\nchemical_formula_hill: Al2O3\nchemical_formula_anonymous: A3B2\n</pre> In\u00a0[20]: Copied! <pre>filter_strategy = client.create_filter(\n    filterType=\"OPTIMADE\",\n    query='elements HAS ALL \"Al\",\"O\"',\n    limit=5,\n)\n\npipeline = filter_strategy &gt;&gt; data_resource_strategy\nparsed_session = json.loads(pipeline.get())\nprint(f\"The query resulted in {len(parsed_session['optimade_resources'])} structures found (on page 1) of the returned data.\")\n\nimport_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1)\nResourceClass = getattr(import_module(import_path), class_name)\nstructures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]]\nprint(f\"Their Materials Project IDs are: {[structure.id for structure in structures]}\")\n</pre> filter_strategy = client.create_filter(     filterType=\"OPTIMADE\",     query='elements HAS ALL \"Al\",\"O\"',     limit=5, )  pipeline = filter_strategy &gt;&gt; data_resource_strategy parsed_session = json.loads(pipeline.get()) print(f\"The query resulted in {len(parsed_session['optimade_resources'])} structures found (on page 1) of the returned data.\")  import_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1) ResourceClass = getattr(import_module(import_path), class_name) structures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]] print(f\"Their Materials Project IDs are: {[structure.id for structure in structures]}\") <pre>Setting filter from query.\nSetting filter from query.\nSetting filter from query.\nSetting page_limit from limit.\nSetting page_limit from limit.\nSetting page_limit from limit.\nresource_config: OPTIMADEResourceConfig(user=None, password=None, token=None, client_id=None, client_secret=None, configuration=OPTIMADEConfig(version='v1', endpoint='structures', query_parameters=OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint=''), datacache_config=DataCacheConfig(cacheDir=PosixPath('oteapi'), accessKey=None, hashType='md5', expireTime=86400, tag='optimade'), return_object=False, use_dlite=False), description='Resource Strategy Data Configuration.\\n\\n    Important:\\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\\n        `accessUrl`/`accessService` MUST be specified.\\n\\n    ', downloadUrl=None, mediaType=None, accessUrl=OPTIMADEUrl('https://optimade.materialsproject.org/', base_url='https://optimade.materialsproject.org', scheme='https', tld='org', host_type='domain'), accessService='OPTIMADE', license=None, accessRights=None, publisher=None)\nresource_config: OPTIMADEResourceConfig(user=None, password=None, token=None, client_id=None, client_secret=None, configuration=OPTIMADEConfig(version='v1', endpoint='structures', query_parameters=OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint=''), datacache_config=DataCacheConfig(cacheDir=PosixPath('oteapi'), accessKey=None, hashType='md5', expireTime=86400, tag='optimade'), return_object=False, use_dlite=False), description='Resource Strategy Data Configuration.\\n\\n    Important:\\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\\n        `accessUrl`/`accessService` MUST be specified.\\n\\n    ', downloadUrl=None, mediaType=None, accessUrl=OPTIMADEUrl('https://optimade.materialsproject.org/', base_url='https://optimade.materialsproject.org', scheme='https', tld='org', host_type='domain'), accessService='OPTIMADE', license=None, accessRights=None, publisher=None)\nresource_config: OPTIMADEResourceConfig(user=None, password=None, token=None, client_id=None, client_secret=None, configuration=OPTIMADEConfig(version='v1', endpoint='structures', query_parameters=OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint=''), datacache_config=DataCacheConfig(cacheDir=PosixPath('oteapi'), accessKey=None, hashType='md5', expireTime=86400, tag='optimade'), return_object=False, use_dlite=False), description='Resource Strategy Data Configuration.\\n\\n    Important:\\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\\n        `accessUrl`/`accessService` MUST be specified.\\n\\n    ', downloadUrl=None, mediaType=None, accessUrl=OPTIMADEUrl('https://optimade.materialsproject.org/', base_url='https://optimade.materialsproject.org', scheme='https', tld='org', host_type='domain'), accessService='OPTIMADE', license=None, accessRights=None, publisher=None)\noptimade_query after update: OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint='')\noptimade_query after update: OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint='')\noptimade_query after update: OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint='')\nOPTIMADE URL to be requested: https://optimade.materialsproject.org/v1/structures?filter=elements%20HAS%20ALL%20%22Al%22%2C%22O%22&amp;response_format=json&amp;page_limit=5&amp;include=references\nOPTIMADE URL to be requested: https://optimade.materialsproject.org/v1/structures?filter=elements%20HAS%20ALL%20%22Al%22%2C%22O%22&amp;response_format=json&amp;page_limit=5&amp;include=references\nOPTIMADE URL to be requested: https://optimade.materialsproject.org/v1/structures?filter=elements%20HAS%20ALL%20%22Al%22%2C%22O%22&amp;response_format=json&amp;page_limit=5&amp;include=references\nThe query resulted in 5 structures found (on page 1) of the returned data.\nTheir Materials Project IDs are: ['mp-1038042', 'mp-1182891', 'mp-1208627', 'mp-1247835', 'mp-1521059']\n</pre> <p>The configuration in <code>optimade_config</code> is quite more extensive than with the HTTP requests-based backend, as it includes more information, automatically setting the default values so they are shown in the config:</p> In\u00a0[21]: Copied! <pre>parsed_session[\"optimade_config\"]\n</pre> parsed_session[\"optimade_config\"] Out[21]: <pre>{'version': 'v1',\n 'endpoint': 'structures',\n 'query_parameters': {'filter': 'elements HAS ALL \"Al\",\"O\"', 'page_limit': 5},\n 'datacache_config': {'cacheDir': 'oteapi',\n  'accessKey': None,\n  'hashType': 'md5',\n  'expireTime': 86400,\n  'tag': 'optimade'},\n 'return_object': False,\n 'use_dlite': False}</pre> <p>Let's look at the first structure again:</p> In\u00a0[22]: Copied! <pre>structure = structures[0]\nprint(structure.id)\nprint(f\"elements: {structure.elements}\")\nfor attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):\n    print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\")\n</pre> structure = structures[0] print(structure.id) print(f\"elements: {structure.elements}\") for attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):     print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\") <pre>mp-1038042\nelements: ['Al', 'Cr', 'Mg', 'O']\nchemical_formula_descriptive: AlCrMg30O32\nchemical_formula_reduced: AlCrMg30O32\nchemical_formula_hill: AlCrMg30O32\nchemical_formula_anonymous: A32B30CD\n</pre> In\u00a0[23]: Copied! <pre>data_resource_strategy = client.create_dataresource(\n    accessService=\"OPTIMADE\",\n    accessUrl=\"https://aiida.materialscloud.org/mc3d/optimade\",\n)\n\npipeline = filter_strategy &gt;&gt; data_resource_strategy\nparsed_session = json.loads(pipeline.get())\nprint(f\"The query resulted in {len(parsed_session['optimade_resources'])} structures found (on page 1) of the returned data.\")\n\nimport_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1)\nResourceClass = getattr(import_module(import_path), class_name)\nstructures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]]\nprint(f\"Their Materials Cloud (AiiDA) IDs are: {[structure.id for structure in structures]}\")\n\nprint(parsed_session[\"optimade_config\"])\n\nstructure = structures[0]\nprint(structure.id)\nprint(f\"elements: {structure.elements}\")\nfor attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):\n    print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\")\n</pre> data_resource_strategy = client.create_dataresource(     accessService=\"OPTIMADE\",     accessUrl=\"https://aiida.materialscloud.org/mc3d/optimade\", )  pipeline = filter_strategy &gt;&gt; data_resource_strategy parsed_session = json.loads(pipeline.get()) print(f\"The query resulted in {len(parsed_session['optimade_resources'])} structures found (on page 1) of the returned data.\")  import_path, class_name = parsed_session[\"optimade_resource_model\"].split(\":\", maxsplit=1) ResourceClass = getattr(import_module(import_path), class_name) structures = [ResourceClass(structure) for structure in parsed_session[\"optimade_resources\"]] print(f\"Their Materials Cloud (AiiDA) IDs are: {[structure.id for structure in structures]}\")  print(parsed_session[\"optimade_config\"])  structure = structures[0] print(structure.id) print(f\"elements: {structure.elements}\") for attribute in (\"descriptive\", \"reduced\", \"hill\", \"anonymous\"):     print(f\"chemical_formula_{attribute}: {getattr(structure, f'chemical_formula_{attribute}', '(not defined)')}\") <pre>Setting filter from query.\nSetting filter from query.\nSetting filter from query.\nSetting page_limit from limit.\nSetting page_limit from limit.\nSetting page_limit from limit.\nresource_config: OPTIMADEResourceConfig(user=None, password=None, token=None, client_id=None, client_secret=None, configuration=OPTIMADEConfig(version='v1', endpoint='structures', query_parameters=OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint=''), datacache_config=DataCacheConfig(cacheDir=PosixPath('oteapi'), accessKey=None, hashType='md5', expireTime=86400, tag='optimade'), return_object=False, use_dlite=False), description='Resource Strategy Data Configuration.\\n\\n    Important:\\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\\n        `accessUrl`/`accessService` MUST be specified.\\n\\n    ', downloadUrl=None, mediaType=None, accessUrl=OPTIMADEUrl('https://aiida.materialscloud.org/mc3d/optimade', base_url='https://aiida.materialscloud.org/mc3d/optimade', scheme='https', tld='org', host_type='domain'), accessService='OPTIMADE', license=None, accessRights=None, publisher=None)\nresource_config: OPTIMADEResourceConfig(user=None, password=None, token=None, client_id=None, client_secret=None, configuration=OPTIMADEConfig(version='v1', endpoint='structures', query_parameters=OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint=''), datacache_config=DataCacheConfig(cacheDir=PosixPath('oteapi'), accessKey=None, hashType='md5', expireTime=86400, tag='optimade'), return_object=False, use_dlite=False), description='Resource Strategy Data Configuration.\\n\\n    Important:\\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\\n        `accessUrl`/`accessService` MUST be specified.\\n\\n    ', downloadUrl=None, mediaType=None, accessUrl=OPTIMADEUrl('https://aiida.materialscloud.org/mc3d/optimade', base_url='https://aiida.materialscloud.org/mc3d/optimade', scheme='https', tld='org', host_type='domain'), accessService='OPTIMADE', license=None, accessRights=None, publisher=None)\nresource_config: OPTIMADEResourceConfig(user=None, password=None, token=None, client_id=None, client_secret=None, configuration=OPTIMADEConfig(version='v1', endpoint='structures', query_parameters=OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint=''), datacache_config=DataCacheConfig(cacheDir=PosixPath('oteapi'), accessKey=None, hashType='md5', expireTime=86400, tag='optimade'), return_object=False, use_dlite=False), description='Resource Strategy Data Configuration.\\n\\n    Important:\\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\\n        `accessUrl`/`accessService` MUST be specified.\\n\\n    ', downloadUrl=None, mediaType=None, accessUrl=OPTIMADEUrl('https://aiida.materialscloud.org/mc3d/optimade', base_url='https://aiida.materialscloud.org/mc3d/optimade', scheme='https', tld='org', host_type='domain'), accessService='OPTIMADE', license=None, accessRights=None, publisher=None)\noptimade_query after update: OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint='')\noptimade_query after update: OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint='')\noptimade_query after update: OPTIMADEQueryParameters(filter='elements HAS ALL \"Al\",\"O\"', response_format='json', email_address='', response_fields='', sort='', page_limit=5, page_offset=0, page_number=None, page_cursor=0, page_above=None, page_below=None, include='references', api_hint='')\nOPTIMADE URL to be requested: https://aiida.materialscloud.org/mc3d/optimade/v1/structures?filter=elements%20HAS%20ALL%20%22Al%22%2C%22O%22&amp;response_format=json&amp;page_limit=5&amp;include=references\nOPTIMADE URL to be requested: https://aiida.materialscloud.org/mc3d/optimade/v1/structures?filter=elements%20HAS%20ALL%20%22Al%22%2C%22O%22&amp;response_format=json&amp;page_limit=5&amp;include=references\nOPTIMADE URL to be requested: https://aiida.materialscloud.org/mc3d/optimade/v1/structures?filter=elements%20HAS%20ALL%20%22Al%22%2C%22O%22&amp;response_format=json&amp;page_limit=5&amp;include=references\nThe query resulted in 5 structures found (on page 1) of the returned data.\nTheir Materials Cloud (AiiDA) IDs are: ['13952', '43703', '43800', '56101', '56270']\n{'version': 'v1', 'endpoint': 'structures', 'query_parameters': {'filter': 'elements HAS ALL \"Al\",\"O\"', 'page_limit': 5}, 'datacache_config': {'cacheDir': 'oteapi', 'accessKey': None, 'hashType': 'md5', 'expireTime': 86400, 'tag': 'optimade'}, 'return_object': False, 'use_dlite': False}\n13952\nelements: ['Al', 'O']\nchemical_formula_descriptive: Al2O6\nchemical_formula_reduced: AlO3\nchemical_formula_hill: Al2O6\nchemical_formula_anonymous: A3B\n</pre>"},{"location":"examples/otelib/#use-oteapi-optimade-with-otelib","title":"Use OTEAPI-OPTIMADE with OTElib\u00b6","text":"<p>OTElib is a Python client library for the OTEAPI system. It has two usable backends:</p> <ol> <li>Python-based. This uses the OTEAPI Core library directly to exectue pipelines. This backend should mainly be used for development purposes.</li> <li>HTTP requests-based. This uses the OTEAPI Services library to execute pipelines via HTTP requests to a running OTEAPI server. This backend should be used for production purposes.</li> </ol> <p>This notebook demonstrates how to use OTEAPI-OPTIMADE with OTElib.</p>"},{"location":"examples/otelib/#example","title":"Example\u00b6","text":"<p>Using OTElib we will do different OPTIMADE queries. First, we will search through the Materials Project database for all structures with the formula <code>Al2O3</code>. Then, we will search through the Materials Project database for all structures that include <code>Al</code> and <code>O</code> in their chemical formula. Finally, we will search through the Materials Cloud MC3D - Materials Cloud three-dimensional crystals database for all structures that include <code>Al</code> and <code>O</code> in their chemical formula.</p>"},{"location":"examples/otelib/#http-requests-based-backend","title":"HTTP requests-based backend\u00b6","text":"<p>This backend is equivalent to running in production. It requires a running OTEAPI server.</p>"},{"location":"examples/otelib/#setup","title":"Setup\u00b6","text":"<p>First, we need to have a running OTEAPI server. If one is not available, we can start one using Docker. See the overview for instructions on how to start a server.</p> <p>Further documentation about the OTEAPI Service is available as a README on GitHub.</p> <p>Note</p> <p>     It is advisable to run the OTEAPI server in a separate terminal window, so that we can see the logs from the server.     Furthermore, we can stop the server by pressing <code>Ctrl+C</code> in the terminal window.   </p> <p>After following the instructions, we should have a running OTEAPI server at localhost:80.</p>"},{"location":"examples/otelib/#create-a-client","title":"Create a client\u00b6","text":""},{"location":"examples/otelib/#search-through-materials-project-for-all-structures-with-the-formula-al2o3","title":"Search through Materials Project for all structures with the formula <code>Al2O3</code>\u00b6","text":"<p>To search through Materials Project for all structures with the formula <code>Al2O3</code>, we need to create the OTE strategies that we want to use for creating the OTE pipeline:</p> <p></p> <p>To create the strategies, we need to know how to configure them. This information is available in the OTEAPI Core documentation, specifically for Data Resource strategies and for Filter strategies.</p> <p>For the data resource strategy, i.e., the OPTIMADE DB strategy, we need to know the base URL of the OPTIMADE API for Materials Project. OPTIMADE has a useful providers dashboard that lists all known OPTIMADE providers and their (sub-)databases. Here we can find the base URL for the Materials Project: <code>https://optimade.materialsproject.org</code>.</p>"},{"location":"examples/otelib/#search-through-materials-project-for-all-structures-that-include-al-and-o-in-their-chemical-formula","title":"Search through Materials Project for all structures that include <code>Al</code> and <code>O</code> in their chemical formula\u00b6","text":"<p>We must use a different OPTIMADE filter query for this search:</p> <pre><code>elements HAS ALL \"Al\",\"O\"\n</code></pre> <p><code>elements</code> is a structure attribute that lists all elements in the structure. The <code>HAS ALL</code> operator matches if, for each value, there is at least one element in <code>elements</code> equal to that value. (This implements the set operator <code>&gt;=</code>.)</p> <p>To do this search, we can reuse the OTE pipeline from the previous search, but change the filter strategy.</p>"},{"location":"examples/otelib/#search-through-mc3d-database-in-materials-cloud-for-all-structures-that-include-al-and-o-in-their-chemical-formula","title":"Search through MC3D database in Materials Cloud for all structures that include <code>Al</code> and <code>O</code> in their chemical formula\u00b6","text":"<p>Finally, let us reuse the same filter strategy we used for the previous search, but change the data resource strategy to point to the MC3D database in Materials Cloud.</p> <p>The base URL for the MC3D database is <code>https://aiida.materialscloud.org/mc3d/optimade</code> as found in the providers dashboard.</p>"},{"location":"examples/otelib/#python-based-backend","title":"Python-based backend\u00b6","text":"<p>With this backend, we do not need a running OTEAPI server.</p>"},{"location":"examples/otelib/#create-a-client","title":"Create a client\u00b6","text":""},{"location":"examples/otelib/#search-through-materials-project-for-all-structures-with-the-formula-al2o3","title":"Search through Materials Project for all structures with the formula <code>Al2O3</code>\u00b6","text":""},{"location":"examples/otelib/#search-through-materials-project-for-all-structures-that-include-al-and-o-in-their-chemical-formula","title":"Search through Materials Project for all structures that include <code>Al</code> and <code>O</code> in their chemical formula\u00b6","text":""},{"location":"examples/otelib/#search-through-mc3d-database-in-materials-cloud-for-all-structures-that-include-al-and-o-in-their-chemical-formula","title":"Search through MC3D database in Materials Cloud for all structures that include <code>Al</code> and <code>O</code> in their chemical formula\u00b6","text":""}]}